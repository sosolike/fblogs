# 多线程并发执行时的线程安全问题

​		多线程虽然能够提升任务执行效率，但是多线程环境下，会因为线程的执行方式无法保证线程间操作的原子性、因为java的内存模型而无法保证线程间共享数据的可见性、也会因为编译器和处理器的优化而无法保证线程执行指令的有序性；如果多条线程间不存在共享数据的读写，那么上述三个问题通常不会带来问题，但是如果线程间存在共享数据的读写，那么上述三个问题可能会导致程序的执行结果和预期结果不同，这些问题称之为线程安全问题，具体如下：

## 1关于原子性：

    ### 1.什么是原子性？

​        原子是最小的，不可再分割的，因此在程序中使用原子性表示一个最小的执行单元，作为最小的执行单元，同一时刻只会有一个处理器执行该执行单元，并且一旦开始执行就必须执行完成或者发生异常之后终止，中途不会暂停执行其他执行单元；

​		通常情况下，一个最小的具备原子性的执行单元由一个指令组成，但是单个指令并不一定具备原子性，一个指令是否具备原子性取决于处理器如何处理该指令，和指令的语义、个数无关；java中则只定义了8中原子性指令，其余指令或者由多条指令组成的代码块并不具备原子性；

### 2.原子性对于线程同步的意义:

​		在某些情况下，我们并不希望多条线程并发执行，而是以同步的方式执行，即一个线程执行完毕某段代码之后再由其他线程执行另一段代码；比如对于库存扣减场景，必须保证一个线程扣减完成之后，再由另一个线程在扣减之后的结果上继续扣减；

​		如果当前线程和其他线程执行的操作具备原子性，由于原子性的不可暂停特性，线程之间将自然以同步的方式执行，但如果线程执行的操作并不具备原子性，那么在执行期间就有可能失去执行机会而导致暂停，此时如果去执行需要和当前代码同步执行的代码将会造成程序执行结果与预期结果不符；

### 3.java中保证代码原子性的方式：

​		java中实现原子性的方式有两种：

​			1.悲观的方式：加锁；

​			2.乐观的方式：CAS；

​		两种实现原子性方式的原理不同，性能以及适用场景也有所不同；通常情况下，如果是需要保证多条代码执行的原子性，则需要使用加锁的方式；如果是将某个变量修改为新值则通过CAS的方式即可；

### 4.加锁的方式和原理：

#### 1.加锁实现原子性的原理:

​		加锁即认为当前操作一定会发生线程间竞争，因此在线程执行被锁锁住的代码之前，必须先获得该锁，只有获得锁的线程才能执行同步代码，而未获得锁的线程则不能执行同步代码块，只能处于阻塞等待状态；直到持有锁的线程释放锁之后，其他等待该锁的线程才能继续竞争锁，竞争到锁的线程才能执行其需要执行的同步代码块，而未竞争到锁的线程则继续处于阻塞等待状态；

​		特别注意的是，加锁是指为某个对象加锁，并非是为代码加锁，而且通过某个对象的锁可以锁住任意代码；多条线程在执行被同一把锁锁住的代码之前，无论代码是否是同一段代码，只要是被同一把锁锁住的代码都需要先获得该对象的锁，获取成功之后才能执行被锁住的代码，否则只能处于阻塞等待状态；

​		因此通过竞争锁的方式即可实现线程间同步执行被锁住的代码块；

#### 2.加锁的方式：

​		java中提供了两种加锁方式：synchronized和Lock；

#### 3.关于synchronized:

​		synchronized是java提供的一个关键字，用来保证代码以原子性方式执行；synchronized既可以修饰静态方法、实例方法也可以修饰代码块；

##### 1.synchronized修饰静态方法:

````java
public synchronized static void fun(){
  // synchronized修饰静态方法
}
````

##### 2.synchronized修饰实例方法:

```java
public synchronized void fun(){
  // synchronized修饰实例方法
}
```

##### 3.synchronized修饰代码块:

```java
public Object lock = new Object();
public void fun(){
  synchronized(lock){
    // synchronized修饰代码块
  }
}
```

##### 4.synchronized修饰方法和代码块的区别:

​	1.synchronized如果直接修饰一个方法，会在编译完成后将该方法属性表中的synchronizedAccess属性设置为1，在调用该方法时，会先检测该方法该属性是否为1，如果为1则先执行加锁逻辑，等到方法执行完成之后或者执行期间遇到异常、wait时才会主动释放锁；如果synchronized修饰一个代码块，编译完成之后会生成一个moniterenter指令和两个moniterexit指令，moniterenter指令和第一个moniterexit指令对应同步代码的入口和出口，为了保证在代码发生异常之后能够释放锁对象，编译器会隐式的添加一个异常处理块，并在finally中添加moniterexit指令；

​	2.synchronized修饰方法时，锁住的是整个方法，加锁粒度较大，并发度较低，synchronized修饰代码块时可以缩小加锁范围，提高并发度；

​	3.synchronized修饰静态方法时，其锁对象是静态方法所在类的Class对象，修饰实例方法时，锁对象是调用当前方法的实例对象；而修饰代码块时，可以手动指定任意对象作为锁；

#### 4.关于Lock:



#### 5.synchronized和Lock的区别:

​		在JDK1.6之前，由于synchronized以mutex的方式加锁，相对于Lock而言性能较差，常常选择Lock作为加锁方式，但是在JDK1.6之后，synchronized做了较多的优化，其性能相较于Lock并不差，甚至在某些情况下，synchronized的性能超出Lock，因此在JDK1.6之后对于synchronized和Lock的选择，性能已经不是决定因素，更多的是因为两者所提供的功能不同；

​		关于synchronized和Lock通常有以下几种不同：

​			1.synchronized是一个关键字，用来修饰一个方法或者锁住一段代码块，而Lock是一个接口，只能用来锁住代码块；

​			2.synchronized能够自动释放锁，当发生异常、线程wait、或者同步代码块执行完成后会自动释放持有的锁，而Lock则需要手动释放锁；

​			3.synchronized是不可中断的，而Lock则允许中断；

​			4.synchronized无法获取加锁结果，但是Lock可以获取加锁结果；

​			5.synchronized加的锁是非公平锁，而Lock可以选择加公平锁或者非公平锁；

​			6.synchronized加的锁是排它锁，而Lock则分别提供了读锁和写锁，通过读锁能够提高读的并发度；

### 5.CAS的原理的使用方式:

#### 1.CAS的原理

#### 2.CAS的具体实现:Atomic

#### 3.CAS缺陷:

	##### 1.ABA问题:

##### 2.CAS+自旋性能问题:

## 2.关于可见性：	

​		此处的可见性表示线程间内存的可见性，即一个线程是否能够看到另一个线程对共享变量的修改；

### 1.无法保证线程间内存可见性的问题:

### 2.java内存模型:

### 3.保证内存可见性的条件:

### 4.java中保证内存可见性的方式及其原理:

​	1.synchronzied

​	2.volatile

## 3.关于有序性:

​		此处的有序性并非指线程间按照顺序依次执行，而是指单个线程内指令的执行顺序是否和源码中的书写顺序一致；为了能够最大化提升程序执行的效率，编译器和处理器均会对源码的顺序进行调整，最终执行程序时的代码顺序不一定是源码中的顺序；

### 1.无法保证有序性带来的问题:		

### 2.关于指令重排序:

### 3.重排序as-if-serial的规则：

### 4.happens-before规则：

### 5.volatile能够禁止指令重排序的原理:

### 6.volatile和synchronized配合实现单利模式:







