# java类加载机制

## 1.类的生命周期和加载流程:

	### 1. 类的生命周期:

​	类从加载至虚拟机使用到销毁一共经历以下七个阶段：

![类生命周期](%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

​	这七个阶段就是类的生命周期；	

### 2.类的加载流程:

​	在类生命周期的7个阶段中，加载、验证、准备、解析、初始化这五个阶段的作用就在于将类加载至内存中，并进行验证，在验证通过之后进行解析并初始化为虚拟机可用的类型，这个过程也是类的加载流程；

​	类的生命周期中，加载、验证、准备、初始化、卸载的顺序是固定不变的，因此在类的加载阶段中，加载、验证、准备、初始化这四个流程的开始顺序都固定的；但是要注意：仅仅只是开始顺序固定，并非完全一步一步执行，各个阶段之间可能相互交叉混合执行；

## 2.类的加载时机:

​	类需要通过加载流程最终形成一个虚拟机可用的类型才能够在程序中使用，对于加载流程的加载阶段，虚拟机并未明确规定触发类加载的情况，但是对于初始化阶段，虚拟机规定了以下六种情况，必须立即对类进行初始化：

1. 遇到new、getstatic、putstatic、invokestatice四条字节码指令时，必须对类进行初始化，而能够生产上述四条字节码指令的场景有:	
   1. 使用new关键字实例化一个对象；
   2. 通过类访问类的静态属性；
   3. 通过类设置类的静态属性；
   4. 通过类执行类的静态方法；
2. 使用java.lang.reflect包的方法对类型进行反射调用时，如果类型没有初始化，必须对类型先进行初始化；
3. 在对类型进行初始化时，发现类型的父类还未初始化时会先对类型的父类进行初始化；
4. 在虚拟机启动时，会先执行主类(带有main方法的类)的main方法，此时虚拟机会先初始化主类；
5. 对于JDK8，如果一个接口中定义了default类型的方法(默认方法)，那么在初始化实现了该接口的类时，会先初始化该接口；
6. 如果使用JDK7之后新增的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

上述六种场景，是类需要进行初始化有且仅有的场景，称之为类的主动引用场景；与之相对的还有被动引用场景，有以下几种情况不会触发类的初始化，称之为类的被动引用：

1. 通过子类引用父类的静态字段，只会导致父类初始化，并不会导致子类初始化；
2. 通过数组定义引用类，并不会触发类的初始化；
3. 常量在编译阶段会存入调用类的常量池，常量本身会直接替换为常量的值，因此对于类中常量的引用本质上没有引用到定义常量的类，因此不会触发到类的初始化；

​	特别要注意的一点是接口，接口也有初始化过程，接口中虽然不能定义`static{}`静态代码块，但是编译器还是会为接口生成`<clinit>()`构造器，用来初始化接口中定义的成员变量；整个初始化过程和类相似，但是触发时机和类的触发时机略有不同，类在初始化时，要求类的所有父类必须已经完成初始化，但是接口在初始化时并不要求其父接口已经完成初始化，除非当前接口中引用了父接口中定义的成员变量；

## 3.类加载流程中的各个阶段：

### 1.类的加载阶段:

​	类的加载阶段是类加载流程的第一阶段，在这个阶段主要完成以下三个事情:

1. 通过类的全限定名称获取表示该类的二进制字节流；

2. 将表示该类的二进制字节流从静态存储结构(class文件格式结构)转换为方法区运行时数据结构；

3. 在内存中生成表示该类的java.lang.Class类型的对象，作为方法区这个类信息访问的入口；

   需要注意的有以下几点：

   1. 虚拟机通过类的全限定名称来查找类的二进制字节流，但并未规定需要从何处查找该二进制字节流，比如可以从zip压缩包、网络中请求、运行时动态生成、其他文件生成等等；

   2. 对于非数组类，类的加载阶段中获取表示类二进制字节流的过程需要通过类加载器来完成，既可以是虚拟机内置的类加载器，也可以是自定义的类加载器，因此用户可以通过自定义加载器来以自己的方式获取二进制字节流；

   3. 对于数组类，并不会通过类加载加载，而是由虚拟机在内存中动态的构造出来，但是数组类的元素类型最终还是需要通过类加载器加载；具体按照以下加载规则加载：

      1.如果数组的组件类型为引用类型(比如Object[])，那就递归的通过类加载流程加载该类；

      2.如果数组的组件类型是基本类型(比如int[])，虚拟机将会把数组标记C与引导类加载器关联

      3.数组类的可访问性和其组件类型的可访问性一致，如果组件类型是基本类型，其可访问性默认为public；

   4. 加载阶段完成之后，二进制流将以特定的数据结构存储在方法区中；但是虚拟机规范并未规定方法区中的数据结构细节，具体由虚拟机实现；

   5. 当二进制流转换为方法区中特定的数据结构之后，会创建一个表示该类的`java.lang.Class`的对象，这个对象中有一个`ReflectionData`的内部类，该内部类中缓存着类的各项信息，Class类持有该内部类的弱引用，通过反射的方式即可从表示该类的Class对象中获取类的各项信息；

   6. 加载阶段和连接阶段的三个子阶段一定是按照顺序开始启动，但是连接的三个子阶段会混杂在加载阶段，比如先加载一段二进制流，加载完成之后会立即激活连接阶段，连接阶段执行期间，还会有其他部分的二进制流加载进来执行加载阶段；

### 2.验证阶段:

​	验证阶段是连接阶段的第一步，目的在于验证加载进虚拟机的二进制流是否是符合规范的class文件格式以及语法逻辑等是否正确，以防止对虚拟机造成安全隐患，因此这个阶段极其重要，也是加载流程中占比最重的阶段，但却并不是一个必须的阶段，如果能充分信任当前加载至虚拟机的二进制流，那么可以通过`-Xverify:none`来关闭类的大部分验证来节省类的加载时间；

​	在JDK7以前验证阶段并未有明确的说明，在JDK7以后才有了明确的验证内容和验证规则；总的大概有以下几个部分的验证：1.文件格式验证、2.元数据验证、3.字节码验证、4.符号引用验证；

​	文件格式验证是指对二进制流的数据按照`class`文件格式规范进行验证，检查二进制流是否符合`class`文件格式规范，比如二进制流是否以魔数开头、主次版本号是否能够被当前虚拟机接收、常量池中是否有不被支持的常量类型等等；文件格式验证通过之后，二进制流就会被放入方法区中，等待后续的验证过程；

​	元数据验证是指对字节码描述的信息进行语义分析，主要是对类、接口相关定义进行检查，检查字节码描述的类、接口定义信息是否符合java语法规范；

​	字节码验证是指对程序的控制流和数据流进行分析，确定程序的语义是合法且符合逻辑的；分析对象是类中的方法体；这个阶段是整个验证阶段最复杂的一个阶段，但是这个阶段即便验证通过也不能完全保证方法是安全无bug的；由于这个阶段的复杂性会导致类的加载流程耗时较长，因此在JDK6对这个阶段做出了优化，将一部分检查交给编译器进行，然后在方法的属性表中Code属性添加一个StackMapTable的属性，虚拟机在验证时只需要验证这个属性的值是否合法即可；在JDK7以后，虚拟机完全使用此种方式进行字节码验证；

​	符号验证发生在虚拟机将符号引用转换为直接引用的过程中，只有解析阶段才会将符号引用转换为直接引用，因此该阶段最终在解析阶段执行，符号验证是指对类本身以外的信息进行验证，检查类本身是否缺少或者被禁止访问外部类、方法、字段等资源；

### 3.准备阶段：

​	在准备阶段，虚拟机会为类中的静态变量分配内存空间，并初始化静态变量为零值；在准备阶段需要注意以下事项：

​	1.准备阶段仅仅只会为静态变量分配内存并初始化为零值，并不会为实例变量分配内存并初始化，实例变量在创建对象时才会分配内存并初始化；

​	2.静态变量在此阶段仅仅只会按照以下规则初始化为零值，并不会按照代码中对静态变量的赋值语句进行赋值：

​		![各种类型的零值](%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png)

3.当静态变量被final修饰之后，编译阶段会将该字段的值放入字段的属性表ConstantValue属性中，在准备阶段会将静态变量的值直接设置为ConstantValue属性所指定的初始值，而不再是静态变量的零值；

### 4.解析阶段：

​		1.在解析阶段，主要工作是将常量池中的符号引用替换为直接引用；

​		2.**符号引用**是指以一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要使用时能够唯一确定一个资源即可；符号引用有以下特征：

​			1.符号引用与虚拟机实现的内存布局无关；

​			2.符号引用的目标不一定是已经加载到虚拟机内存中的内容；

​		3.**直接引用**是指能够直接定位到资源的指针、偏移量或者间接定位到资源的句柄；有以下特征：

​			1.直接引用和虚拟机实现的内存布局直接相关；如果有了直接引用，那么直接引用指向的目标一定在内存中存在；

​			2.同一个符号引用通过不同虚拟机翻译出来的直接引用通常并不相同；

​		4.虚拟机规范并未规定解析阶段发生的时间，虚拟机可以根据需要自行实现，有可能会在类加载时就对常量池中的符号引用进行解析，也有可能在使用到符号引用时时才会进行解析；但是在解析时，如果第一次对符号常量解析成功了，那么后续其他指令对该符号常量的引用解析一定能够成功，如果第一次对符号常量解析失败了，那么后续其他指令对该符号常量解析时，即便该符号常量已经被加载至内存，也依旧要报告异常；

​		5.虚拟机的解析阶段主要包括以下7符号引用进行解析：

​			1.类或者接口、2.字段、3.类方法、4.接口方法、5.方法类型、6.方法句柄、7.调用点限定符

​		6.关于类或者接口的解析：

​				类或者接口的解析是指按照表示类或接口的全限定名称的字符串来查找对应的类、接口，并通过类加载器加载该类或者接口，如果加载过程异常，就算解析失败；如果加载过程没有异常且加载完毕之后，还会继续检查当前类是否有对目标类或接口有访问权限，如果没有权限，将会抛出异常；

​		7.关于字段解析：

​				字段解析会先解析字段所属类或者接口的符号引用，如果字段所属的类或者接口解析失败，那么字段也将解析失败，如果字段所属类或者接口解析成功，那么会在当前类中以及按照类、接口的继承关系由下向上查找该字段，如果找到该字段那么将返回字段的直接引用，如果没有找到将会报告异常；找到之后还会进一步验证当前类是否有访问该字段的权限，如果没有权限，将会报告异常；

​		8.关于类方法和接口方法的解析：

​				类方法和接口方法的解析同字段的解析相似，第一步均需要先解析方法所属的类或者接口，如果其所属的类或者接口解析失败，那么方法解析失败；否则将在当前类、接口或者按照类、接口的继承关系由下向上查找与该符号匹配的方法，如果找到则返回方法的直接引用，如果没有找到则报告异常；找到之后还会进一步验证当前类是否有访问该字段的权限，如果没有权限，将会报告异常；

### 5.初始化阶段：

​	在初始化阶段，虚拟将会执行类的构造器`<clinit>()`，来为类的静态变量按照代码对静态变量的赋值操作进行初始化；

​	类的构造器`<clinit>()`并不是在程序中书写的，而是由虚拟机根据静态变量的赋值语句和静态代码块自动收集的；类构造器中的代码顺序和静态变量的赋值语句与静态代码块在源代码中定义的顺序相同；静态语句块只能访问到定义在静态代码块定义之前的静态变量，不能访问定义在静态代码块之后的变量，静态代码块中只能为定义在静态代码块之后的变量赋值，但是不能访问；

​	类构造器`<clinit>()`的执行和构造函数的执行不同，并不需要显式的调用父类的类构造器，虚拟机会保证在执行子类的类构造器之前，父类的类构造器一定执行完毕；

​	类构造器`<clinit>()`对于类或者接口来说并不是必须的，如果类或者接口中并没有静态变量的赋值语句，也没有静态代码块，那么将不需要类构造器`<clinit>()`；

​	接口中虽然不能定义静态代码块，但是仍然可以有静态变量的定义和赋值语句，因此接口仍然有`<clinit>()`构造器；但是执行接口的`<clinit>()`构造器之前，并不要求先执行父接口的`<clinit>()`方法，只有在当前接口使用了父接口的静态变量时才会触发父接口的加载流程，此时才会执行父接口的`<clinit>()`方法；对于继承了接口的类来说也是如此；

​	在多线程环境下，虚拟机会保证类的初始化阶段同步执行，同一时刻，只会有一个线程执行类的`<clinit>()`方法；在一个线程执行类的`<clinit>()`方法时，其他等待执行该类`<clinit>()`方法的线程将会处于阻塞等待状态，直至当前线程执行完毕，因此类的初始化阶段如果执行时间过长有可能会造成多个线程阻塞等待；并且当前线程执行完`<clinit>()`方法，其他线程唤醒之后将不会再执行该类的`<clinit>()`方法

## 4.类加载器:

### 1.类加载器:

​		执行类加载流程中加载阶段的程序称为类加载器；类在虚拟机中通过加载这个类的加载器和类的全限定名称共同确定其唯一性；

### 2.类加载器分类：

​		从虚拟机角来看，类加载器分为以下三类：

​		1.启动类加载器，由C/C++实现，是虚拟机的一部分，这个加载器负责加载存放在`<JAVA_HOME>/lib`或者被`-Xbootclasspath`参数指定的地址存放的可以被虚拟机接受的类；启动类加载器无法被java程序直接使用，如果自定义类加载器需要将类的加载委托给启动类加载器时使用null来表示启动类加载器即可；

​		2.扩展类加载器，这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。负责加载`<JAVA_HOME>\lib\ext`目录下的类，或者是被java.ext.dirs系统变量所指定的路径中的类库；用户可以将自定义类库添加在上述路径中，通过扩展类加载器加载以扩展java se的功能；由于该加载器是通过java实现的，因此可以在java代码中直接使用；

​		3.应用程序类加载器，有时候也叫做系统类加载器；负责加载用户类路径上的所有类库，如果程序中没有自定义过类加载器，那么该加载器是默认的加载器

### 3.双亲委派模型：

​		1.类在虚拟机中的唯一性非常重要，即一个类只能被虚拟机加载一次，如果加载多次，那么程序中将无法确定当前应该使用哪一个类；

​		2.类加载的双亲委派模型是指，当前类加载器加载类时会将需要加载的类委派给其父类加载，父类加载器也会将加载请求委派给其父类加载器，依次类推；如果父类加载器无法完成类的加载，那么会将类的加载请求交给其子类加载器，依次类推直至能够加载该类的加载器完成类的加载；双亲委派模型能够保证同一个类只会被同一个类加载器加载，进而保证类在虚拟机中的唯一性；

​		3.子类加载器和父类加载器仅仅只是加载职责上的父子关系，实际上并没有类之间的继承关系；

​		4.程序中通常使用以下两种方式加载类：Class.forName()和ClassLoader.loadClass()



