

# 泛型

## 1.泛型机制：

​	泛型本意是指将变量的数据类型进行泛化，能够让变量兼容不同的数据类型，称之为泛型能力；		

​	Java中的泛型是指：通过声明一个表示某种数据类型的泛型参数，可以通过该泛型参数来声明变量，而变量具体数据类型可以推迟到使用该变量时通过泛型参数指定，通过这种方式实现变量兼容不同数据类型的能力；

​	Java中可以为类、接口、方法声明泛型参数，在类、接口、方法内部可以直接使用泛型参数来声明变量；对于泛型参数，其作用类似于为方法声明的形参一样，可以由外部通过泛型参数将数据类型传递至类、接口、方法内部；

## 2.泛型本质：

### 1.Java泛型机制是如何实现的？

​        因为Java是强数据类型语言，在编译阶段要求变量必须有明确的数据类型，并且会对传递给变量的值进行严格的类型检查；但是对于具有通用性的代码，我们希望这段代码无论传递何种数据类型的参数都能够正常工作，那么我们有两种方式实现它：

​            1.通过方法重载机制：为不同数据类型的参数重写一遍一样逻辑的代码；

​            2.通过面向对象的多态特性：因为多态特性中子类也是一种父类类型，利用这个特点，只需要将变量的类型设置为参数的`父类型`或者`Object`，即可向下兼容不同的数据类型；

​        实际上Java的泛型机制就是通过面向对象的多态特性来实现的，虽然向类、接口、方法声明泛型时指定了一个表示数据类型的参数，但是这个参数仅仅存在于编译阶段，编译完成之后代码中并无任何泛型的信息；

​        Java在编译时，会检查当前泛型参数在声明时是否通过`extends`设置类型的上限：

​            如果有设置上限，那么编译完成之后，所有使用到该泛型参数的地方都被替换为该上限类型；通过字节码即可查看：

​            如果没有设置上限，那么编译完成之后，所有的使用到该泛型参数的地方都被替换为`Object`类型；通过字节码即可查看：

​		 所从上面的字节码信息也能看到，Java中的泛型参数并不会一直伴随着变量，只存在于编译阶段，编译完成之后，泛型信息会被擦除掉，转而使用泛型的上限或者Object来替代泛型参数，这个过程称为**泛型擦除**；因此，Java中的泛型本质上是一个伪泛型，只是利用多态来实现数据类型兼容的语法糖，并且能够自动将数据从父类型转换为子类型，免去手动转换的麻烦！

### 2.泛型擦除带来的问题：

> 1.因为泛型擦除的原因，泛型仅支持引用类型，不支持基本类型；

​        因为泛型是通过多态特性实现的，泛型擦除之后变量的类型只能是Object或者泛型的上限类型；无法对基本类型进行支持，需要将基本类型转换为其对应的包装类型才能使用泛型；

> 2.因为泛型擦除的原因，使用不同的泛型参数并不会产生新的类：

​    	对于同一个泛型类，即便其泛型参数不同，编译完成后，由于泛型擦除的原因，类中并不会有泛型参数的信息，因此，泛型参数的不同并不会引起泛型类的改变而产生新的类，无论泛型参数如何，泛型类始终都是同一个类！通过反射的方式也能确定不同泛型类的实例对象所属的类是同一个类；

> 3.为了保证泛型擦除之后的类型安全，在编译阶断会对使用了类、接口泛型参数的变量值进行类型检查，但是这种检查只和引用有关；

​    	如果使用类、接口声明的泛型参数来定义实例变量，或者定义实例方法中的形参以及局部变量，那么在编译阶段，该实例变量和实例方法中的泛型类型，只与调用其的引用的泛型类型有关，和引用具体指向的实例对象无关！

```java
//如下一个泛型类：
class Gen <T>{
    public Gen(){}
    public void add(T t){}
}
        
//客户端代码:
B b = new B();
A a = new A();
Gen<B> tb = new Gen<>();
tb.add(b); // 编译通过
tb.add(a); // 此时编译不会通过，
//对于上述代码，在通过tb调用泛型方法add时，编译器会只会检查泛型方法中的泛型类型是否和调用方法时引用的泛型类型一致，由于tb在声明时已经指明泛型的类型信息；因此泛型方法中泛型的类型就是B类型，因此只能添加B类型的实例对象；

Gen tn = new Gen<B>();
tn.add(a); // 编译通过
tn.add(b); // 编译通过
//对于上述代码，通过tn调用add方法，同样编译器会检查泛型方法中的泛型类型是否和调用方法时引用的泛型类型一致，虽然tn实际指向的实例对象的泛型是B类型 ，但是声明引用tn时并未指定泛型的类型信息，其泛型的类型信息会被默认为Object,而泛型方法的泛型只和调用其的引用的泛型类型有关，因此泛型方法的泛型类型信息同样是Object，所以可以将任意类型的数据作为add方法的参数；
```

> 4.因为泛型擦除的原因，为了保证运行时数据类型安全，在编译时编译器会严格检查泛型参数的类型,泛型参数不同的变量，不能互相赋值；

​        因为泛型擦除之后，泛型参数都是Object或者泛型的上限类型，虽然这样可以向下兼容不同的数据类型，但是在运行时所获取的变量值还是需要转换为泛型参数指定的具体数据类型，这是一个由父类型转换为子类型的过程；为了能够在类型转换时安全的进行，编译器在编译阶段会严格检查泛型参数的不同，并且要求：无论泛型参数之间是何种关系，泛型参数不同的相同泛型类型变量不能互相赋值；    

```java
//对于以下类结构:
class A {}
class B extends A { }
class C extends A { }
List<A> lista = new ArrayList<>();
List<B> listb = new ArrayList<>();
List<C> listc = new ArrayList<>();

lista = listb;   // 编译无法通过
listb = listc;   // 编译无法通过
```

## 3.泛型声明：

### 1.声明泛型类:

​           `` 权限 修饰符 calss 类名<T>{\*类成员*/}``

```java
public class ClassGenericity<T>{ 
    public T var;
}
```

### 2.声明泛型接口:

​            `权限 interface 接口名<T>{/*接口成员*/}`

```java
public interface InterfaceGenericity<T>{ 
    public T var;
}
```

### 3.泛型类/接口派生子类：

​		1.子类不确定泛型值：

​			`权限 修饰符 calss 类名<T> implements/extends InterfaceGen<T>/ClassGen<T>{/*类成员*/}`

​		2.子类确定泛型值：

​			`权限 修饰符 calss 类名 implements/extends InterfaceGen<String>/ClassGen<String>{/*类成员*/}`

```java
// 子类在继承时明确父接口泛型表示的数据类型：
     public class TestGenericity implements InterfaceGenericity<String>{}

// 子类在继承时不明确父接口泛型表示的数据类型：
    public class TestGenericity<T> implements InterfaceGenericity<T>{}

// 子类直接忽略掉父接口的泛型, 此种情况，由于子类在继承父接口时直接抹掉了父接口声明的泛型！所以子类中将不再有父接口声明的泛型:
    public class TestGenericity implements InterfaceGenericity{}
```

### 4.声明泛型方法：

​		`权限 修饰符 <T> 返回值类型 方法名(形参列表){/*方法体*/}`

```java
public <T> void testFun(T a){
	T b;
}

public <T,K> void testFun(T a){
	T b;
	K e;
}
```

## 4.指定泛型 上限和下限:

### 1.泛型上限：

​		如果直接使用泛型，那么类型的范围太大，类型参数的值太随意，可以通过泛型上限约束泛型的范围；泛型上限表示当前泛型最高支持的数据类型，只能接受上限类型以及上限类型的子类；

​		**1.对于类：**

​			` 权限 修饰符 class 类名<T extends ParentClass>{/*类成员*/}`

​		**2.对于接口：**

​			`权限 interface 接口名<T extends ParentClass>{/*接口成员*/}`

​		**3.对于方法：**

​			`权限 修饰符 <T extends ParentClass> 返回值类型 方法名(形参列表){/*类成员*/}`

### 2.泛型下限：

​		表示当前泛型最低支持的数据类型，只能接受下限类型和下限类型的超类；

​		**1.对于类：**

​                `权限 修饰符 class 类名<T super ParentClass>{/*类成员*/}`

​		**2.对于接口：**

​                `权限 interface 接口名<T super ParentClass>{/*接口成员*/}`

​         **3.对于方法：**

​                `权限 修饰符 <T super ParentClass> 返回值类型 方法名(形参列表){/*类成员*/}`

## 5.使用泛型:

​		在使用声明了泛型的类、接口、方法时，必须要为对应的泛型参数传递一个确定的数据类型；但是如果当前代码在使用泛型时仍然无法确定传递何种数据类型时，可以使用通配符来传递给泛型参数，表示泛型参数的值由上级调用者确定，当前只是占位而已；

		### 1.使用具体数据类型填充泛型参数：

​	**1.对于类：**
​            类中的泛型需要在创建对象时指定，或者在其他类继承时指定：

```java
  //创建对象时指定
TestClass<String> ts = new TestClass<>();
  //继承时指定
class OtherClass extends TestClass<String>;
```

​    **2.对于接口：**
​        接口中的泛型需要其他接口或者类继承时指定：

```java
// 其他类继承时指定
class OtherClass implements TestInterface<String>
// 其他接口继承时指定
class OtherInterface implements TestInterface<String>
```

​    **3.对于方法：**

```java
// 在以下方法中声明了泛型参数T和E
public <T,E> void test(T a,E b){
    // 使用泛型参数T声明局部变量；
    T c;
};
```

​        1.无需注明方法的泛型类型信息，系统会根据传入的参数自动推断当前数据形参对应的类型形参的数据类型；  如：

```java
// 系统会自动推断泛型的类型信息，因此T的类型将会是int,E的类型将会是String；
test(1,"test");
// T的类型将会是String,E的类型将会是Int；
test("test",2):
```

 		2.注明方法的泛型类型信息，此时只能按照指定的类型信息传递形参：如：

```java
// 此时只能为形参a传递int类型的值，为形参b传递String类型的值；
test<Integer,String>(1,"test");
// 此时只能为形参a传递String类型的值，为形参b传递int类型的值；
test<String,Integer>("test",1);
```

​    **4.对于构造方法：**
​        构造方法使用泛型机制和泛型方法相同；需要先声明类型形参，然后再使用；只是在创建对象时略有不同：如：

```java
class Test{
    public <T> Test(T a)
    {
    	/*构造方法实体*/
    }
}

//使用泛型构造方法Test创建对象
Test t = new <String> Test("string");
```

### 2.使用通配符填充泛型参数:

​    1.通配符使用场景：

​			通配符常用在方法形参声明中，表示当前方法形参的泛型参数未知，由方法的调用方指定；声明方法如下：

```java
//对于以下泛型方法，表示方法的参数list泛型参数未知，由方法的调用方指定；调用方可以根据需要传递任意类型的List
public void test(List<?> list){};

// 比如传递String类型的List
test(new ArrayList<String>());
// 比如传递Integer类型的List
test(new ArrayList<Integer>());
```

​    		通配符也可以指定上限和下限，来约束调用方传递的参数类型：

```java
// 通配符上限,设置了通配符上限之后，调用方仅能传递ClassGenericity以及子类类型的List；
public void test(List<? extends ClassGenericity> list){};
// 通配符下限,设置了通配符下限之后，调用方仅能传递ClassGenericity以及超类类型的List；
public void test(List<? super ClassGenericity> list){};

//比如对于以下继承结构
class A{}
class B extends A{}
class C{}
// 对于以下泛型方法，在调用该方法时，仅能够传递A、B类型的List，不能传递C类型的List
public void test(List<? extends A>){}

//传递A类型的List
test(new ArrayList<A>())
//传递B类型的List
test(new ArrayList<B>)
```

​	2.使用通配符声明变量:

​		如果将通配符用在变量声明时，需要遵守PECS规则，即Producer extends Consumer super；即:
​        1.可以从 <? extends Type> 声明的容器中获取数据，但是不能向其添加数据；

​        2.可以向 <? super Type> 声明的容器中添加数据；并且添加数据时也仅能添加Type及其子类类型，不能添加Type父类类型；

​    	