# Java面向对象-基础语法

## 1.面向对象简介

​	**面向对象思想 **是指一种将每一个事物都看成一个独立的个体，而每一个独立的个体就是我们所面对、研究和使用的对象，每一个对象都会有自己的静态特征和动态特征，可以借助不同对象的静态或动态特征来解决问题，并且可以将对象按照共同的特征进行分类，称为该对象的类型；

​	**面向对象编程 **是指按照面向对象的思想来组织和实践代码，将数据和指令封装为对象，称之为对象的属性和方法，将过程化的编码方式改变为组合不同对象并借助对象的属性和方法来解决问题；并将有共同特征的实例对象抽象为类，对象的共同特征由类来提供和保证，类就是对象的模板，对象就是类的实体化；

## 2.类(class)

### 	1.类的特征

​		1.**从面向对象概念来看**，类是实例对象的模板，抽象了实例对象共有的一些特征，通过同一个类可以创建出的独立且具有相同特征的实例对象，因此类(class)是面向对象编程的基石；

​		2.**从数据处理角度看**，我们所处理和面对的一切都是数据，实例对象本身也是具有数据值和动态行为的一种数据；而创建实例对象的类就是该数据的类型。因此类也可以看做是一种自定义的数据类型，同样也可以通过类来声明变量引用该类的实例对象；

### 2.类的声明方式

​	**1.类的声明语法**

```java
权限 修饰符 class ClassName{
  /*
  * 类成员：
  *	1.构造方法
  *	2.成员属性
  *	3.成员方法
  *	4.初始化块
  *	5.内部类
  */
}
```

**类声明语法的相关说明**

> **1.权限:**不同的权限表示该类的可访问位置：

​			1.类的权限只有 ***public*** 和 ***默认权限(无权限修饰符)***  两种；

​			2.**public** 权限表示：该类可被其所在包的类和所在包以外的类访问；**默认权限**表示：着该类只能被其所在    包中的类访问；

​			3.一个java源文件只能有一个public权限的类，且此时java源文件的名称也必须和public修饰的类名相同；

> **2.修饰符：**通常情况下，无需任何修饰符，表示一个普通的类；但在以下情况下需要修饰符：

​			1.如果该类中有抽象方法时，该类也成为抽象类，必须使用 **abstract** 修饰；

​			2.如果该类不希望被子类继承，需要使用 **final** 修饰；			

> **3.class关键字：**

​		class关键字表示该代码块时一个类，该关键字在类声明时必须有，不能省略；

> **4.ClassName：**

​		类名，类的名称必须符合java标识符命名规范，推荐采用首字母大写的方式命名；

> **5.类成员：**类的组成部分：

​		包括*构造方法*、*成员属性*(静态属性和实例属性)、*成员方法*(静态方法和实例方法)、*初始化块*(普通初始化块和静态初始化块)、*内部类*(静态内部类和普通内部类)，类成员需要使用 **{}** 包裹；

### 3.类成员

#### 1.构造方法：

​	**1.构造方法功能：**构造方法用来对该类新创建的实例对象进行初始化操作；

> 需要注意的是，构造方法并不创建对象，而是对创建好的对象进行初始化；

​	**2.构造方法的声明方式:**

​			2.构造方法的声明方式:

```java
权限 构造方法名(形参列表){
  /*构造方法实体*/
}				
```
> 说明：

> 1.权限：

​		1.权限取值：public(公共权限)、protected(受保护权限)、private(私有权限)，default(默认权限)；

​		2.如果创建该类实例对象时，构造方法的访问权限不足，将无法通过构造方法初始化实例对象，对象的创建将会失败；

​		3.通常情况下，类的权限必须是public权限，如果不希望通过类的构造函数创建对象，可以将构造函数设置为private权限即可；

> 2.构造方法名:构造方法名称必须和类名保持相同；

> 3.形参：

​		1.形参表示传递给构造方法的参数，由(参数类型 参数名称组成)组成，多个参数之间使用 **,** 隔开，形参不允许设置默认值；

​		2.如果有多种不同传参的方式，可以通过重载构造方法实现；

> 4.返回值：

​		1.构造方法不允许注明返回值类型或者使用void关键字标记返回值，如果有void或者注明返回值类型，那么该方法将成为一个普通的实例方法；

​		2.虽然不能注明构造方法的返回值，但构造方法实际是有返回值的，返回的是当前类创建并初始化完成的实例对象；

​		3.构造方法中也不允许使用return关键字返回表示当前类实例对象的this或者其他值，构造方法的返回值是隐式返回的；如果使用return关键字返回了具体值，该方法将成为一个普通的方法；

> 5.构造方法的必要性：

​		1.类中必须要有构造方法，如果没有显式的声明该类的构造方法，系统将会为类创建一个无参的构造方法；

> 6.构造方法的重载：

​		1.Java支持根据传递参数的不同，来对构造方法重载，实际创建对象时会自动根据传入的参数来确定调用的构造方法；

​		2.构造方法中允许通过this关键字调用其他被重载的构造方法，通过这种方式可以实现构造方法复用；

​	 1.类中必须要有构造方法，构造方法可以显式的声明，并且可以根据初始化参数不同来对构造方法进行重载；

​	3.如果当前类没有构造方法，系统将会按照继承顺序依次向上查找该类父类中的构造方法	

#### 2.实例属性：

​	**1.实例属性特征：**

​		1.实例属性是指该属性属于实例对象，类中声明的所有实例属性在创建实例对象时都会为该对象创建一份；

​		2.同一个类的每个实例对象中都有类型相同、名称相同的实例属性，但是各自对象的实例属性属于各自对象，不同的对象同样的实例属性其值可能相同也可能不同，由其所属对象决定；

​		3.实例属性只能通过其所属的实例对象访问，访问时各自对象访问的是各自对象中的实例属性；

​	**2.实例属性声明方式：**	

```java
权限 修饰符 数据类型 变量名 [= 值];
//示例：
public String tmpString = "tmpString";
```

​	**3.实例属性的权限：**

​		1.可以是public、protected、default、private权限，权限不同，能够访问该属性的位置不同；

​	**4.修饰符：**

​		1.默认情况下，实例属性无需任何修饰符；

​		2.如果需要将该实例属性设置为常量，则需要使用final修饰符；

​	**5.数据类型：**

​		1.实例属性可以是任意Java允许的数据类型，可以是基本数据类型也可以是引用类型；

​	**6.属性名：**

​		1.属性名必须符合Java标识符命名规范，推荐使用驼峰式命名法命名；

​		2.同一个类中不允许出现名称相同的成员属性，该属性的权限、修饰符、数据类型都不同也不允许同名；

**7.初始值：**

​		1.实例属性只有在创建实例对象时才会进行初始化；

​		2.实例属性可以在声明时给予默认值，如果没有显式的声明默认值，系统将会根据实例属性的数据类型设置默认值：

​			1.*引用类型，默认值是null；*

​			2.*byte、short、int、long型，默认值是0；*

​			3.*float和double类型，默认值是0.0；*

​			4.*boolean类型，默认值是false；*

**8.访问方式：**

​		1.属性所在类内部：this.实例属性名  或者  实例属性名

​		2.属性所在类外部：实例对象.实例属性名

> 注意：在类内部访问实例属性时，可以省略this关键字，直接使用实例属性名，使用此种方式时，系统将会优先查找是否有同名局部变量，如果有同名局部变量时，实例属性必须通过this关键字访问；

**9.生命周期：**

​		1.实例属性在创建对象时，分配存储空间，并初始化；其所在的实例对象被销毁时，实例对象也将被销毁；

​		2.实例属性的生命周期和其所在的实例对象生命周期相同；

**10.实例属性在内存中的位置：**

​		1.实例属性属于对象本身，是实例对象的组成部分，因此实例属性会存储在系统为实例对象分配的堆内存中；



#### 3.静态属性：

​	**1.静态属性特征：**

​		1.静态属性属于类，不属于对象，和对象的创建无关，仅和类的加载流程有关，一个类中只会有一个同名静态属性；

​		2.静态属性允许通过类和该类的实例对象访问，由于静态属性和实例对象无关，所以通过实例对象访问静态属性时访问的是同一个数据；

​	**2.静态属性声明方式：**	

```java
权限 static 修饰符 数据类型 变量名 [= 值];
//示例：
public static String tmpString = "tmpString";
```

​	**3.静态属性的权限：**

​		1.可以是public、protected、default、private权限，权限不同，能够访问该属性的位置不同；

​	**4.修饰符：**

​		1.静态属性必须要有static修饰符修饰；

​		2.如果需要将该静态属性设置为常量，则需要使用final修饰符；

​	**5.数据类型：**

​		1.静态属性可以是任意Java允许的数据类型，可以是基本数据类型也可以是引用类型；

​	**6.属性名：**

​		1.属性名必须符合Java标识符命名规范，推荐使用驼峰式命名法命名；

​		2.同一个类中不允许出现名称相同的成员属性，该属性的权限、修饰符、数据类型都不同也不允许同名；

**7.初始值：**

​		1.静态属性会在类的准备阶段分配存储空间并设置为0值；不同数据类型的静态属性有不同的0值：

​			1.*引用类型，默认值是null；*

​			2.*byte、short、int、long型，默认值是0；*

​			3.*float和double类型，默认值是0.0；*

​			4.*boolean类型，默认值是false；*

​		2.静态属性在类的初始化阶段会被设置为程序中指定的初始值，如果声明静态属性时没有给定初始值，那么该静态属性的初始值就是准备阶段为该静态属性设置的0值；			

 **8.访问方式：**

​		1.属性所在类内部：类名.静态属性名  或者 this.静态属性名  或者  静态属性名

​		2.属性所在类外部：类名.静态属性名  或者 实例对象.静态属性名

> 注意：

​		1.静态属性既可以通过类名访问也可以通过类实例对象访问，但是并不推荐使用实例对象访问类变量；并且在类外部通过实例对象访问的时候，会优先查找实例变量，如果没有实例变量时才会访问类变量；

​		2.在类内部直接使用静态属性名称访问时，系统将会按照以下顺序查找：同名局部变量、同名实例属性、同名静态属性；因此为了避免出错尽量使用类名.静态属性名访问；

 **9.生命周期：**

​		1.在类的准备阶段将会为静态属性分配内存空间并设置0值，在程序运行期间，该静态属性会一直存在，直至程序结束；

​		2.静态属性的生命周期和类的生命周期相同；

 **10.静态属性在内存中的位置**：

​		1.静态属性作为类的一部分，存储在方法区中；

#### 4.局部变量：

> 局部变量是指方法中定义的变量，和成员属性相比有以下不同点：

​	**1.声明位置不同：**

​		成员属性指类中声明的变量，成员属性包括：实例属性和静态属性；	

​		局部变量是指方法中声明的变量，局部变量包括：方法形参、方法体中声明的变量、代码块中声明的变量；

​	**2.声明方式不同：**

​		成员属性：权限 修饰符 数据类型 属性名 [= 值]

​		局部变量：数据类型 变量名 [= 值]

​	**3.作用域不同**：

​		成员属性是全局状态，可以在类中的任意一个方法内通过对应的访问方式访问；

​		局部变量是局部状态，只能在定义的方法体内和代码块内访问：

​			1.形参可以在整个方法体内访问；

​			2.方法体内声明的局部变量的作用域是当前方法体内，变量声明语句之后的区域；

​			3.代码块中的局部变量作用域是变量所在的代码块内部，变量声明之后的区域(如if...for语句块等)；

​	**4.访问方式不同：**

​		成员变量可以直接通过变量名称访问，也可以按照对应的访问语法访问；

​		局部变量只能通过变量名称访问；		

​	**5.初始化方式不同：**

​		成员属性系统会自动进行初始化，会根据成员属性的数据类型不同设置不同的初始值；	

​		局部变量系统不会自动进行初始化，必须显式进行初始化，并且不同的局部变量初始化方式不同：

​			1.形参不能设置初始值，只能接受来自实参的值；

​			2.方法体以及代码块中的变量必须手动设置初始值，否则直接访问将会出错；

​	**6.生命周期不同：**

​		成员属性：静态属性的生命周期和类的生命周期相同；实例属性的生命周期和实例对象相同；
​        局部变量：局部变量的生命周期和方法体的生命周期相同；

​	**7.关于命名：**

​		1.成员属性：同一个类中不允许出现同名成员属性；

​		2.局部变量：

​			1.形参之间不允许同名，不允许和成员属性同名；

​			2.方法体和代码块中的局部变量之间不允许同名，不允许和形参同名，但是可以和成员属性同名；

​	**8.关于访问顺序：**

> 类中通过名称直接访问成员属性或者局部变量时系统将会按照以下顺序查找：

代码块中直接通过变量名称访问变量时查找顺序：
     1：先查找当前代码块中是否局部变量的定义；
     2：如果没有则查找方法体内部是否有局部变量的定义；
     3：如果没有则查找是否有对应名称的形参；
     4：如果没有则查找是否有同名实例变量；
     5：如果没有则查找是否有同名静态变量；
方法体内中访问变量顺序：
     1：先查找方法体内部是否有变量的定义；
     2：如果没有则查找是否有对应名称的形参；
     3：如果没有则查找是否有同名实例变量；
     4：如果没有则查找是否有同名静态变量；

> 对于成员变量的访问：推荐以特定的语法形式调用，避免和局部变量同样的调用方式，便于查看维护，避免歧义；		

#### 5.实例方法：

   **1.实例方法特征：**
        1.实例方法属于实例对象，只能通过实例对象访问；
         2.实例方法存储在方法区，所有实例对象共用实例方法；

   **2.定义方式：**

```java
权限 修饰符 返回值类型 方法名(形参列表){/*方法体*/} 
```

   **3.访问方式：**
            类内部访问：this.实例方法
            类外部访问：实例对象.实例方法

   **4.权限：**public(公共权限)、protected(受保护权限)、default(默认权限)、private(私有权限)

   **5.修饰符：**

​			1.实例方法默认无修饰符，表示普通的实例方法；

​			2.实例方法的修饰符不能是static；

​            3.如果该方法只有方法声明，没有方法体，那么该方法是一个抽象方法，必须使用**abstract**修饰；

​            4.如果该方法不希望被子类重写，可以使用**final**修饰；

   **6.返回值类型：**

​			1.表示该方法调用之后返回值的数据类型，可以是java允许的任意数据类型；

​             2.如果有返回值返回必须在声明方法时注明返回值数据类型；如果该方法没有返回值，则使用void来表示；

  **7.方法名：**方法名称，要符合java标识符命名规范，推荐使用驼峰式命名法命名；

  **8.形参：**表示调用该方法时需要传入的参数。

​            1：每一个形参由参数的数据类型和参数名称组成(参数类型 参数名)，多个参数使用 , 隔开；

​            2：如果方法声明了参数，调用该方法时必须按照参数的数量、顺序、数据类型给予实参；

​            3：形参只能接收来自实参的值，不允许设置默认值；

​            4：形参和实参的传递只有值传递，如果是基本类型的形参，则传递的是具体的数值；如果是引用类型的形

参，则传递的是实例对象的地址，总之传递给形参的是实参的值本身；

​            5：不同类型形参对数据产生的影响不同：

​                 1：如果参数是基本类型的数据，实参对形参的赋值等同于将一个变量值赋值给另一个变量；因为复制的

就是数据本身，因此在方法内部修改了形参值也不会影响实参的值；

​                  2：如果参数是引用类型的数据，那么实参的值和形参的值相同，表示同一个地址，因此指向同一个对

象，在方法内部通过形参改变该地址的数据之后，凡是通过指向该地址的引用变量获取到的数据都将是被修改之后

的数据；要特别注意；

​            6：java在JDK1.5之后允许使方法接收不定个数的参数，即以 (数据类型 … 形参名) 声明的形参可以接收多个

参数，多出的参数会以数组的方式按顺序存放；

​     **9：方法体：**

​			1.方法的具体实现，由多条语句组成；

​             2.如果该方法没有方法体，那么该方法称之为抽象方法，必须要使用abstract修饰；此时类也必须使用abstract修饰；

​    **10：方法重载：**

​			1.java中允许一个类中定义多个参数列表不同，但是方法名相同的方法，这种定义方法的方式称之为方法的重载；
​            2.方法重载只关注同名方法的形参是否不同(类型、数量)，与方法的权限以及修饰符、是否有返回值以及返

回值的数据类型等无关；

#### 6. 静态方法：
 **1.静态方法特征：**静态方法属于类，只能通过类名访问；

 **2.定义方式：**

```java
权限 static 修饰符 返回值类型 方法名(形参列表){/*方法体*/}     
```

 **3.访问方式：**

​            类内部访问：类名.静态方法  或者  this.静态方法

​            类外部访问：类名.静态方法  或者  实例对象.静态方法

> 不推荐使用this或者实例对象访问静态方法

 **4：权限：**public(公共权限)、protected(受保护权限)、default(默认权限)、private(私有权限)

 **5.修饰符：**

​	 1.实例方法默认无修饰符，表示普通的实例方法；

​	 2.实例方法的修饰符不能是static；

​     3.如果该方法只有方法声明，没有方法体，那么该方法是一个抽象方法，必须使用**abstract**修饰；

​     4.如果该方法不希望被子类重写，可以使用**final**修饰；

 **6.返回值类型：**

​	  1.表示该方法调用之后返回值的数据类型，可以是java允许的任意数据类型；

​      2.如果有返回值返回必须在声明方法时注明返回值数据类型；如果该方法没有返回值，则使用void来表示；

  **7.方法名：**方法名称，要符合java标识符命名规范，推荐使用驼峰式命名法命名；

  **8.形参：**表示调用该方法时需要传入的参数。

​            1：每一个形参由参数的数据类型和参数名称组成(参数类型 参数名)，多个参数使用 , 隔开；

​            2：如果方法声明了参数，调用该方法时必须按照参数的数量、顺序、数据类型给予实参；

​            3：形参只能接收来自实参的值，不允许设置默认值；

​            4：形参和实参的传递只有值传递，如果是基本类型的形参，则传递的是具体的数值；如果是引用类型的形

参，则传递的是实例对象的地址，总之传递给形参的是实参的值本身；

​            5：不同类型形参对数据产生的影响不同：

​                 1：如果参数是基本类型的数据，实参对形参的赋值等同于将一个变量值赋值给另一个变量；因为复制的

就是数据本身，因此在方法内部修改了形参值也不会影响实参的值；

​                  2：如果参数是引用类型的数据，那么实参的值和形参的值相同，表示同一个地址，因此指向同一个对

象，在方法内部通过形参改变该地址的数据之后，凡是通过指向该地址的引用变量获取到的数据都将是被修改之后

的数据；要特别注意；

​            6：java在JDK1.5之后允许使方法接收不定个数的参数，即以 (数据类型 … 形参名) 声明的形参可以接收多个

参数，多出的参数会以数组的方式按顺序存放；

​    **9：方法体：**

​			1.方法的具体实现，由多条语句组成；

​             2.如果该方法没有方法体，那么该方法称之为抽象方法，必须要使用abstract修饰；此时类也必须使用abstract修饰；

​    **10：方法重载：**

​			1.java中允许一个类中定义多个参数列表不同，但是方法名相同的方法，这种定义方法的方式称之为方法的重载；
​            2.方法重载只关注同名方法的形参是否不同(类型、数量)，与方法的权限以及修饰符、是否有返回值以及返

回值的数据类型等无关；   

#### 7.初始化块：

​	**1.初始化块特征：**

​          1.没有名称、不能接受参数的代码块；

​           2.包括静态初始化块和普通初始化块；

​           3.静态初始化块在类初始化阶段执行，用来对类的静态属性进行初始化；普通初始化块在创建实例对象时执行，用来对实例对象初始化；

​    **2.初始化块语法：**

```java
[修饰符]{/*任意的可执行语句*/}：
```

> 说明：		

 	1.修饰符：

​			1.如果是普通初始化块，无需任何修饰符，如果是静态初始化块，需要使用static修饰符；

​            2.除过static以外不能使用其他任何修饰符修饰初始化块；

​      2.初始化块的组成：

​			1.初始化块和普通的方法体相同，代码块中可以是任意可执行语句；

​			2.但是初始化块没有名称，不能被调用；不接受参数，因此也不能被传参，只能执行一些固定的可执行语句；

​      3：类中允许的初始化块个数：

​			一个类中可以声明多个初始化块，在执行时会按照初始化块在代码中的声明顺序执行，实际编写代码时尽

量将多个初始化块合并为一个初始化块；

​      4：代码块的执行时机：

​			1.静态初始化会在类的初始化阶段执行，实际执行时，会按照类的继承顺序从顶级父类向下并按照类中静态属性的声明和静态初始化化块声明的位置依次执行，直至当前正在执行加载流程的类；

​				静态初始化块属于类，同样不能在静态初始化块中访问实例属性或者实例方法，确需访问的，必须先创建该类的实例对象，并通过实例对象访问；

​			2.普通初始化块会在创建对象时执行，实际上普通初始化块只是一个语法糖，在编译阶段所有的普通初始化块的内容就已经被编译至构造函数原有代码之前；因此普通初始化块会先于构造方法执行；

​			   本质上普通初始化块和构造方法并无不同，普通初始化块的意义就在于可以执行初始化对象的公共操作，其余个性化的初始化操作可以交给构造函数执行；

#### 8.内部类：
​     **1：内部类：**

​            定义在一个类内部的类称之为内部类，相对的，内部类所属的类称为外部类，内部类是外部类的成员；

​     **2：内部类特征：**
​            1.内部类是一个class，因此具备类的基本特征，和外部类一样可以声明类成员；

​			2.内部类同时又是外部类的一个成员，所以也具备类成员的特征，比如可以设置四种权限，可以被static修

饰，访问时也需要以外部类成员的方式访问；

​            3.内部类通常情况下可以帮助外部类实现数据封装、多继承等功能；

​            4.内部类作为外部类的成员，同样有非静态内部类和静态内部类；

​     **3：非静态内部类：**

​            1.非静态内部类属于实例对象的成员，每一个实例对象都有一个相同的内部类；

​            2.声明方式：

```java
权限 class 类名{/*内部类成员*/}
```

​            3.关于权限：

​				内部类作为外部类的成员，和其他类成员一样有四种访问权限：public、protected、default、private；
​            4.非静态内部类成员：

​                1.由实例属性、实例方法、构造方法、普通初始化块组成；

​                2.非静态内部类中不能有静态属性、静态初始化块、静态方法；

​            5.非静态内部类与外部类之间的互相访问

​                1.外部类内访问内部类成员：

> 外部类不能通过非静态内部类名直接访问非静态内部类成员，必须通过非静态内部类实例对象访问：

​                        InnerClass ic = new InnerClass()

​                        访问内部类实例属性：ic.实例属性

​                        访问内部类实例方法：ic.实例方法

​                    ***注意：不能在外部类中的静态方法中创建非静态内部类实例对象和访问非静态内部类成员；***

​                2.外部类外部访问内部类成员：

> 非静态内部类属于外部类的实例对象成员，因此必须先创建外部类的实例对象，然后创建非静态内部类实例对象：

​                        OutClass oc = new OutClass;

​                        OutClass.InnerClass ic = oc.new InnerClass();

​                        访问内部类实例属性：ic.实例属性

​                        访问内部类实例方法：ic.实例方法

​                3.内部类访问外部类成员：

​                    1.内部类可以直接访问外部类成员：

> 外部类实例属性、实例方法：

​                            1.直接通过名称访问：实例属性  或者 实例方法()

​                            2.通过this关键字访问：this.实例属性 或者 this.实例方法()

​                            3.通过外部类名访问：OutClass.this.实例属性 或者 OutClass.this.实例方法()

​                           说明：

​								1.直接通过名称访问时按照以下顺序查找：

​                                    1.内部类局部变量(代码块局部变量、方法局部变量、形参)

​                                    2.内部类实例属性

​                                    3.外部类成员属性(外部类实例属性、外部类静态属性)；

​                                2.通过this关键字访问时按照以下顺序查找：

​                                    1.内部类实例属性

​                                    2.外部类成员属性(外部类实例属性、外部类静态属性)； 

> 外部类静态属性、静态方法：

​                            1.直接通过名称访问：静态属性  或者 静态方法()

​                            2.通过this关键字访问：this.静态属性 或者 this.静态方法()

​                            3.通过外部类名访问：OutClass.静态属性 或者 OutClass.静态方法()

​                            说明：

​								1.直接通过名称访问时按照以下顺序查找：

​                                    1.内部类局部变量(代码块局部变量->方法局部变量->形参)

​                                    2.内部类实例属性

​                                    3.外部类成员属性(外部类实例属性->外部类静态属性)；

​                                2.通过this关键字访问时按照以下顺序查找：

​                                    1.内部类实例属性

​                                    2.外部类成员属性(外部类实例属性->外部类静态属性)； 

​      **4：静态内部类：**

​            1：静态内部类：被static修饰的内部类称之为静态内部类，属于类成员；

​            2：声明方式：

```java
权限 static class 类名{/*类成员*/}
```

​            3：关于权限：

​					1.内部类作为外部类的成员，和其他类成员一样可以有四种访问权限：public、protected、default、private；
​            4.静态内部类成员：

​                1.由实例属性、静态属性、实例方法、静态方法、构造方法、非静态初始化块、静态初始化块组成；

​            5.静态内部类与外部类之间的互相访问：

​                1.外部类内访问内部类成员：

​                    1.外部类可以通过静态内部类名直接访问静态内部类静态成员；

​                    2.静态内部类的非静态成员只能通过静态内部类的实例对象访问：

​                        InnerClass ic = new InnerClass()

​                        访问内部类实例属性：ic.实例属性

​                        访问内部类实例方法：ic.实例方法

​                    **注意：不能在外部类中的静态方法中创建静态内部类实例对象和访问静态内部类实例成员；**

​                2.外部类外部访问内部类成员：

​                    1.外部类可以通过静态内部类名直接访问静态内部类静态成员：

​                        OutClass.InnerClass.静态属性

​                        OutClass.InnerClass.静态方法

​                    2：外部类必须通过静态内部类实例对象访问静态内部类的实例属性和实例方法；

​                        OutClass.InnerClass ic = new OutClass.InnerClass();

​                        访问内部类实例属性：ic.实例属性

​                        访问内部类实例方法：ic.实例方法

​                3.内部类访问外部类成员：

​                    1.静态内部中的静态方法不允许访问任何非静态成员；对于内部类本身的非静态成员也不允许在静态方法中直接访问，必须创建内部类实例对象访问；对外部类的非静态成员均不允许在任何位置访问；

​                    2.内部类静态方法中访问外部类静态属性、静态方法：

​                        1.直接通过名称访问：静态属性  或者 静态方法()

​                        2.通过外部类名访问：OutClass.静态属性 或者 OutClass.静态方法()

​                        说明：

​							1.直接通过名称访问时按照以下顺序查找：

​                                1.内部类局部变量(代码块局部变量->方法局部变量->形参)

​                                2.内部类静态属性

​                                3.外部类静态属性



​       **5：匿名内部类：**
​            1：没有名称的内部类称之为匿名内部类；
​            2：匿名内部类在声明时即创建对象，且匿名内部类不能单独出现，必须继承自一个父类或者接口，如下方式：

```java
new 实现接口() | 父类构造器(参数列表){/*匿名内部类成员*/}
```

​            3：关于匿名内部类的说明：

​                1：匿名内部类必须实现某个接口或者继承某个父类；不能单独声明；

​                2：匿名内部类在声明时即创建对象；

​                3：匿名内部类没有名称，因此匿名内部类没有构造方法；

​                4：匿名内部类没有名称，无从被其他类来继承，因此匿名内部类不能是抽象类；