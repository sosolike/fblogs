一：关于持久化：
    1：Redis是基于内存的数据存储结构，但是Redis支持以RDB或者AOF的方式将内存中的数据持久化到磁盘文件中，并在Redis服务启动时读取持久化文件来将数据恢复至内存中；
    2：Redis中可以单独使用RDB和AOF其中一种，也可以两者同时使用，也可以两者都不使用；

二：关于RDB方式持久化：
    1：RDB方式持久化数据特点：
        1：以快照的方式获取当前Redis中存储的数据；
        2：将内存中存储的数据全量持久化至rdb文件中；
        3：文件中保存的是所有key的值，而非对该key的操作记录；
        4：使用rdb文件恢复数据时是通过读取rdb文件中的键值对并将键值对一一写入数据库；

    2：RDB方式持久化数据的相关配置：
        1：触发RDB持久化条件：
            save <seconds> <changes>
                1：指定在多长时间内有多少次更新操作就将数据同步到数据文件，可以多个条件配合；
                2：默认策略为: save 900 1         # 900s之内至少有1次更新操作就会触发RDB持久化
                              save 300 10        # 300s之内至少有10次更新操作就会触发RDB持久化
                              save 60 10000      # 60s之内至少有10000次更新操作就会触发RDB持久化   
                3：该行注释掉之后将会禁用以RDB方式持久化数据至文件；
        2：配置rdb文件名称：
            dbfilename dump.rdb
                1：设置rdb文件名称；
        3：配置rdb文件
            dir /redis/path/rdb
                1：设置rdb文件保存目录；
        4：是否压缩Rrdb文件
            rdbcompression yes
                1：默认为启用压缩；
                2：如果不压缩rdb文件，在数据量比较多的情况下文件将会变得较大；开启该参数之后会更节省磁盘空间，但是持久化和恢复时间都会增长；

    3：RDB的执行方式：
        1：Redis中执行RDB持久化数据的方式有两种：
            当前进程直接执行持久化操作：SAVE；
            当前进程fork子进程，由子进程执行持久化操作：BGSAVE；
            Redis中主要在rdb.h和rdb.c两个文件中实现RDB的具体操作；

        2：关于SAVE:
            1：由当前Redis进程直接执行持久化操作，在当前进程执行持久化操作时将会阻塞一切客户端的请求；
            2：如果内存中存储数据较多，持久化时间可能会比较长，阻塞客户端请求的时间会比较长，导致业务本身受到影响；因此尽量避免使用该方式持久化数据；
            3：触发SAVE的方式：
                1：通过客户端向服务端发送 save 命令，服务端将会执行 RDB 流程；
                2：手动关闭服务端或者向服务端发送shutdown命令关闭服务端时，服务端会先执行 RDB 流程，然后再退出服务；

        3：关于BGSAVE:
            1：由当前Redis进程fork一个子进程，然后由子进程执行 RDB 流程，父进程fork完子进程之后将会继续响应客户端请求；
            2：BGSAVE流程分析：
                1：当Redis开始以BGSAVE的方式执行 RDB 流程时，首先会检查当前父进程是否已经有一个子进程，如果已经有一个子进程表示当前服务正在以BGSAVE的方式执行 RDB，将会向客户端返回一个错误；如果没有子进程将会检查是否正在进行AOF持久化，如果正在进行AOF持久化那么会检测是否有schedule参数，如果有该参数，那么本次BGSAVE将会被提上日程等待执行，如果没有该参数将直接返回错误；

                2：如果当前Redis进程创建子进程成功，那么将会由子进程来执行 RDB 流程，而父进程则继续响应客户端请求；但是特别注意，父进程在fork子进程的过程中，父进程将会阻塞一切客户端响应，直至子进程 fork 完成；由于fork子进程时需要复制父进程的虚拟地址空间表，此时如果Redis父进程中存储数据较多，那么这个复制过程将会比较缓慢，会影响客户端业务流程，需要注意；

                3：子进程创建成功之后开始以 SAVE 的方式执行 RDB 流程，直至完成；其中子进程和父进程虽然各自独有一份虚拟地址空间表，但是Redis采用了copy-on-write技术，即子进程和父进程共享同一份数据块，并且数据块中的数据均被设置为只读状态，copy-on-write虽然不回引起内存翻倍，但是如果此时主进程中收到更新操作，子进程和父进程共享的数据块中被修改的数据将会为子进程单独复制一份，并将该数据设置为可写状态，如果主进程更新操作较多，那么主进程中会发生较多内核调用来复制数据，造成CPU压力过高，客户端响应速度过慢，以及内存占用率过高等问题；
            3：触发BGSAVE的方式：
                1：满足Redis配置文件中 save 配置项的策略时Redis将会以BGSAVE的方式执行持久化操作；
                2：手动向服务端发送 bgsave 命令；
                3：在主从复制过程中，从节点连接上主节点之后，主节点将会以BGSAVE的方式执行RDB来创建rdb文件，并将rdb文件发往从节点；
            
        4：BGSAVE和SAVE对比：
            1：执行效率上：SAVE 因为无需创建子进程，因此效率高于 BGSAVE；
            2：业务处理上：SAVE 是当前进程在执行RDB流程，因此会完全阻塞客户端一切请求，而BGSAVE是子进程在执行RDB流程，父进程仍能够继续响应客户端请求；
            3：内存使用上：SAVE 方式不会额外增加内存占用，但是 BGSAVE 中虚拟地址空间表以及数据本身有可能会占用额外较多内存空间；
        
        5：关于Redis配置文件中 save 项的实现：
            1：Redis中使用saveparam结构体来存放配置文件中的save配置；saveparam结构体定义如下：
                struct saveparam {
                    time_t seconds;    // 秒数
                    int changes;    // 变更次数
                }

            2：Redis在redisServer结构体中定义了两个字段用来保存Redis中键的更新状态：
                long long dirty;    // 上次成功执行save或者bgsave命令之后至现在key被变更的次数；
                time_t lastsave;    // unix时间戳，表示上次成功执行save或者bgsave命令时的时间；
                这两个字段会在Redis的周期函数serverCron中来检测当前是否需要执行bgsave；其中serverCron函数用来对Redis进程状态进行维护，每个1s调用一次；

    4：RDB文件格式：
        1：RDB文件特征：RDB文件是二进制格式的，文件中无新行或者空格，并且存储的是每一个键的最终数据而不是操作记录；
        2：RDB文件格式：
            RDB文件组织格式为：
                REDIS:db_version:database:EOF:check_sum
                    REDIS：
                        大写的REDIS字符串，表示该文件是Redis的RDB文件，帮助Redis快速检测文件类型；大小为5个字节；
                    db_version：
                        RDB文件版本号；大小为4个字节
                    database：
                        数据库信息，包括数据号和数据库中存储的键值对，如果数据库中无数据，该值为0；如果有数据则按照database格式存储；
                    EOF：
                        RDB文件结束符，标志RDB文件正文内容的结束，使用RDB文件恢复数据时，如果遇到该值说明所有的键值对都已经载入内存了；
                    check_sum：
                        检测RDB文件是否有错误或者损坏，该值是根据REDIS、db_version、database、EOF四个部分的内容进行计算而出的；载入RDB文件时会将载入的数据计算得到的校验值和check_sum进行对比；大小为8个字节；
            
            database具体数据组织格式：
                SELECTDB:db_number:key_value_pairs
                    SELECTDB：
                        数据库标识，常量，读取程序遇到该值时接下来的数据会被当做数据库号；
                    db_number：
                        具体的数据库号；
                    key_value_pairs：
                        保存该数据库中的所有的键值对；
            
            key_value_pairs键值对组织格式：
                EXPIRETIME_MS:ms:TYPE:key:value
                    EXPIRETIME_MS：
                        表示键值对过期时间标识，遇到该值时接下来读取到的内容会被当做过期时间，以ms为单位；长度为1字节；
                    ms：
                        具体的过期时间，8个字节大小
                    Type：
                        value的数据类型；Redis中的数据类型之一，长度为1字节
                    Key：
                        键名
                    value：
                        键值
三：AOF方式持久化
    1：AOF方式持久化数据特点：
        1：AOF是将每一次对key的修改命令追加至aof文件中；
        2：aof文件中存储的是键的修改命令，而非键值本身；
        3：同一个键值多次修改也会记录多个修改命令；
        4：使用aof文件恢复数据是是通过读取aof文件中的命令，并一一执行读到的命令来恢复数据的；
    
    2：AOF持久化方式相关配置：
        1：是否使用AOF的方式持久化数据：
            appendonly no 
                1：默认是no，即不开启AOF的方式持久化数据；设置为yes即可开启；
        2：使用AOF方式持久化数据时使用的策略：
            appendfsync everysec 
                1：有三种策略可选，如下：no,always，everysec；
                3：no：指通过操作系统来保证数据同步到磁盘，速度最快但是可靠性最差，有可能会丢失较多的数据；
                   always：指每更新一次数据就将更新命令写入aof文件，可靠性最高，使用该方式会频繁产生系统调用来将更新命令写入aof文件，会给Redis带来较大压力，导致响应速度变慢；
                   everysec：指每秒执行一次持久化，可靠性较高，服务端压力适中，但是有可能丢失1s的数据；推荐设置为该值；
        3：以AOF方式持久化时aof文件的名称：
            appendfilename appendonly.aof   
                1：AOF方式持久化数据时的文件名；

    3：AOF持久化流程：
        1：当Redis接收到一个更新命令时，Redis首先会检查是否开启AOF方式持久化数据，如果启用了AOF，那么Redis会将更新命令格式化之后写入到Redis创建的缓冲区中(注意：这个缓冲区是Redis本身创建的缓冲区，不是文件系统的缓冲区)；
        2：检查配置文件中对于AOF方式持久化所配置的持久化策略，根据不同的策略进行刷盘操作：
            如果配置为 no：更新命令写入aof_buf后直接调用系统函数write将更新命令写入内核页缓冲区，具体何时同步至硬盘中则由操作系统来保证；

            如果配置为always：更新命令写入aof_buf之后，进程会直接调用fsync系统函数来将更新命令同步至磁盘中；fsync完成后进程才会返回；

            如果配置为everysec：更新命令写入aof_bug之后，进程会调用write系统函数将更新命令写入内核页缓冲区，然后由Redis的周期函数cronServer每秒调用一次fsync将更新命令同步至磁盘中；
        3：如果配置为everysec；那么系统如果真的崩溃，丢失数据将会丢失2s而不是1s的数据；
    


            
                



                

