一：关于持久化：
    1：Redis是基于内存的数据存储结构，但是Redis支持以RDB或者AOF的方式将内存中的数据持久化到磁盘文件中，并在Redis服务启动时读取持久化文件来将数据恢复至内存中；
    2：Redis中可以单独使用RDB和AOF其中一种，也可以两者同时使用，也可以两者都不使用；

二：关于RDB方式持久化：
    1：RDB方式持久化数据特点：
        1：以快照的方式获取当前Redis中存储的数据；
        2：将内存中存储的数据全量持久化至rdb文件中；
        3：文件中保存的是所有key的值，而非对该key的操作记录；

    2：RDB方式持久化数据的相关配置：
        1：触发RDB持久化条件：
            save <seconds> <changes>
                1：指定在多长时间内有多少次更新操作就将数据同步到数据文件，可以多个条件配合；
                2：默认策略为: save 900 1         # 900s之内至少有1次更新操作就会触发RDB持久化
                              save 300 10        # 300s之内至少有10次更新操作就会触发RDB持久化
                              save 60 10000      # 60s之内至少有10000次更新操作就会触发RDB持久化   
                3：该行注释掉之后将会禁用以RDB方式持久化数据至文件；
        2：配置rdb文件名称：
            dbfilename dump.rdb
                1：设置rdb文件名称；
        3：配置rdb文件
            dir /redis/path/rdb
                1：设置rdb文件保存目录；
        4：是否压缩Rrdb文件
            rdbcompression yes
                1：默认为启用压缩；
                2：如果不压缩rdb文件，在数据量比较多的情况下文件将会变得较大；开启该参数之后会更节省磁盘空间，但是持久化和恢复时间都会增长；

    3：RDB的执行方式：
        1：Redis中执行RDB持久化数据的方式有两种：
            当前进程直接执行持久化操作：SAVE；
            当前进程fork子进程，由子进程执行持久化操作：BGSAVE；
            Redis中主要在rdb.h和rdb.c两个文件中实现RDB的具体操作；

        2：关于SAVE:
            1：由当前Redis进程直接执行持久化操作，在当前进程执行持久化操作时将会阻塞一切客户端的请求；
            2：如果内存中存储数据较多，持久化时间可能会比较长，阻塞客户端请求的时间会比较长，导致业务本身受到影响；因此尽量避免使用该方式持久化数据；
            3：触发SAVE的方式：
                1：通过客户端向服务端发送 save 命令，服务端将会执行 RDB 流程；
                2：手动关闭服务端或者向服务端发送shutdown命令关闭服务端时，服务端会先执行 RDB 流程，然后再退出服务；

        3：关于BGSAVE:
            1：由当前Redis进程fork一个子进程，然后由子进程执行 RDB 流程，父进程fork完子进程之后将会继续响应客户端请求；
            2：BGSAVE流程分析：
                1：当Redis开始以BGSAVE的方式执行 RDB 流程时，首先会检查当前父进程是否已经有一个子进程，如果已经有一个子进程表示当前服务正在以BGSAVE的方式执行 RDB，将会向客户端返回一个错误；如果没有子进程将会检查是否正在进行AOF持久化，如果正在进行AOF持久化那么会检测是否有schedule参数，如果有该参数，那么本次BGSAVE将会被提上日程等待执行，如果没有该参数将直接返回错误；

                2：如果当前Redis进程创建子进程成功，那么将会由子进程来执行 RDB 流程，而父进程则继续响应客户端请求；但是特别注意，父进程在fork子进程的过程中，父进程将会阻塞一切客户端响应，直至子进程 fork 完成；由于fork子进程时需要复制父进程的虚拟地址空间表，此时如果Redis父进程中存储数据较多，那么这个复制过程将会比较缓慢，会影响客户端业务流程，需要注意；

                3：子进程创建成功之后开始以 SAVE 的方式执行 RDB 流程，直至完成；其中子进程和父进程虽然各自独有一份虚拟地址空间表，但是Redis采用了copy-on-write技术，即子进程和父进程共享同一份数据块，并且数据块中的数据均被设置为只读状态，copy-on-write虽然不回引起内存翻倍，但是如果此时主进程中收到更新操作，子进程和父进程共享的数据块中被修改的数据将会为子进程单独复制一份，并将该数据设置为可写状态，如果主进程更新操作较多，那么主进程中会发生较多内核调用来复制数据，造成CPU压力过高，客户端响应速度过慢，以及内存占用率过高等问题；
            3：触发BGSAVE的方式：
                1：满足Redis配置文件中 save 配置项的策略时Redis将会以BGSAVE的方式执行持久化操作；
                2：手动向服务端发送 bgsave 命令；
                3：在主从复制过程中，从节点连接上主节点之后，主节点将会以BGSAVE的方式执行RDB来创建rdb文件，并将rdb文件发往从节点；
            
        4：BGSAVE和SAVE对比：
            1：执行效率上：SAVE 因为无需创建子进程，因此效率高于 BGSAVE；
            2：业务处理上：SAVE 是当前进程在执行RDB流程，因此会完全阻塞客户端一切请求，而BGSAVE是子进程在执行RDB流程，父进程仍能够继续响应客户端请求；
            3：内存使用上：SAVE 方式不会额外增加内存占用，但是 BGSAVE 中虚拟地址空间表以及数据本身有可能会占用额外较多内存空间；
        
        5：关于Redis配置文件中 save 项的实现：
            1：Redis中使用saveparam结构体来存放配置文件中的save配置；saveparam结构体定义如下：
                struct saveparam {
                    time_t seconds;    // 秒数
                    int changes;    // 变更次数
                }

            2：Redis在redisServer结构体中定义了两个字段用来保存Redis中键的更新状态：
                long long dirty;    // 上次成功执行save或者bgsave命令之后至现在key被变更的次数；
                time_t lastsave;    // unix时间戳，表示上次成功执行save或者bgsave命令时的时间；
                这两个字段会在Redis的周期函数serverCron中来检测当前是否需要执行bgsave；其中serverCron函数用来对Redis进程状态进行维护，每个1s调用一次；

    3：触发RDB的方式：
        1：在 redis.conf 配置文件中设置自动触发 save 的条件，在相应的时间点内对key的更新次数符合设置条件时将会自动执行RDB操作；
        2：向Redis服务发送save命令或者bgsave命令；

                

