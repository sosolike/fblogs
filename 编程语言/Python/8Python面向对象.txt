一：python面向对象基本语法：
    python中面向对象和传统意义上的面向对象类似，由类(class)和对象(object)组成面向对象的体系；
    1：类的定义：
        1：定义语法：class ClassName(inheritedClass):
                        class_attr = value    # 定义类属性

                        def __init__(self):
                            """构造方法""" 
                            self.obj_attr = value    # 定义一个实例属性    
                        
                        def func(self):
                            """实例方法""" 
                        
                        @staticmethod
                        def func():
                            """静态方法"""
                        
                        @classmethod
                        def func(cls):
                            """类方法"""
        
        2：类定义说明：
            1：python中使用class关键字定义一个类；
            2：类名应当使用每个单词首字母大写的方式命名；并且要符合python中标识符命名规范；
            3：在类后使用()来声明当前类需要继承的父类，python中支持多继承，因此继承多个父类时使用','分隔开多个父类；
            4：类中成员包括：类属性，实例属性，类方法，静态方法，实例方法，构造方法以及一些魔术方法；类成员无需{}包裹，但是需要保持相同的缩进；

    2：对象的创建：
        1：对于对象和类的关系：
            类是用来创建对象的模板，对象则是类具体化的实例；

        2：对象的实例化：
            obj = ClassName()           #构造方法无明确需要传入的形参
            obj = ClassName(arg1,arg2)  #构造方法有明确需要传入的形参
        
        3：几个操作对象的常用内置函数：
            # 获取对象的所有属性以及方法
                dir(obj)   
            # 检测对象是否是指定类的实例
                isinstance(obj,ClassName)    
            # 检测对象的类型，即创建该对象的类
                type(obj)    
            # 检测对象是否有指定属性
                hasattr(obj,'attr')
            说明：
                type()返回的是直接创建该对象的类，并不会考虑类的继承关系，即type函数不会将子类当做一种父类类型；
                isinstance()在检测对象是否是指定类的实例时会认为子类是一种父类类型，会考虑类的继承关系；

    3：类成员-属性：
        1：属性有两种：类属性和实例属性；
        2：类属性：该属性属于类，不属于实例对象；只能通过类来访问，不能通过实例对象访问；
            1：类属性的特征：
                1：类属性属于类本身，不属于实例对象；
                2：在类初始化的时候就会初始化类属性，类被销毁时才会被销毁，类属性的生命周期和类相同；
                2：类属性只能在类内部定义；不能在类中其他方法中定义，如：
                    class ClassName():
                        class_attr = 1      #class_attr是在类内部定义类属性

                        def func(self):
                            var_name = 1    #var_name属于实例方法func的局部变量
                3：类属性只能通过类名访问：无论是在类内部的方法中还是类外部访问，类属性都必须使用类名来访问；如：
                    class ClassName():
                        class_attr = 1    #类属性

                        def func(self):
                            print(ClassName.class_attr)         #在类内部方法中访问类属性
                        
                    ClassName.class_attr    #在类外部方法中访问类属性
                
        3：实例属性：该属性属于对象本身；并且不同对象中的实例属性属于各自对象；
            1：实例属性特征：
                1：实例属性属于对象，每创建一个对象，这些实例属性就会被创建一次；每一个对象中都有各自的实例属性，不同对象的实例属性互相独立；
                2：实例属性在创建对象时初始化，对象被销毁时也将被销毁，其生命周期和对象本身相同；
                3：实例属性定义：
                    1：在类内部，可以在构造方法、实例方法中通过 self.实例属性名 来定义；构造方法中和实例方法中定义的实例属性，每一个对象中都会存在一份；
                    2：在类外部，可以通过实例对象定义，obj.实例属性名；通过实例对象定义的属性只有当前实例对象有；
                    3：不允许再静态方法、类方法中定义或者调用实例属性；
                    示例：
                        1：在类构造方法中和实例方法中定义：
                        class ClassName():
                            def __init__(self):
                                self.obj_attr = 1    #在构造方法定义实例属性
                            
                            def func(self):
                                self.obj_attr = 1    #在实例方法中定义实例属性
                        
                        2：通过实例对象定义：
                            obj = ClassName()
                            obj.obj_attr = 1    #通过实例对象定义实例属性

                4：实例属性的访问：
                    1：在类内部需要使用self关键字来访问：self.obj_attr；
                    2：在类外部需要通过实例对象来访问：obj.obj_attr；
                    3：通过实例对象访问实例属性时，如果实例属性不存在，那么会查找同名类属性；并返回该属性的值；
                
    4：类成员-方法：
        1：构造方法：
            1：构造方法的定义：
                def __init__(self):
                    #构造方法体
            
            2：关于构造方法的说明：
                1：构造方法第一个参数是self,代表被初始化的实例对象本身，构造方法中必须要有该参数；
                2：构造方法用来初始化对象，比如初始化实例属性等；而非创建对象；被初始化的对象就是self参数传入的对象；
                3：构造方法的名称必须是__init__，不能是其他名称；
        
        2：实例方法：
            1：实例方法的定义：
                def func_name(self):
                    #实例方法体
            
            2：关于实例方法的说明：
                1：实例方法属于对象，每一个对象中都有一份实例方法；
                2：实例方法第一个参数必须为self,代表实例对象本身，传入实例方法的参数从第二个参数开始，且第一个参数self不能省略；
                3：实例方法在类内调用时，使用 self.func_name() 的方式调用，在类外使用 obj.func_name() 调用；
            
        3：类方法：
            1：类方法的定义：
                @classmethod
                def func_name(cls):
                    #类方法体
            
            2：关于类方法的说明：
                1：类方法属于类，和对象的创建无关；类方法的定义必须使用 classmethod 装饰器装饰；
                2：类方法的第一个参数为cls(或者其他名字),代表当前类本身；
                3：类方法无论是在类的外部还是类的内部，都是通过：ClassName.func_name()来调用；
                4：类方法中不能直接通过 self 关键字访问实例属性和实例方法；
        
        4：静态方法：
            1：静态方法的定义：
                @staticmethod
                def func_name():
                    #静态方法体
            
            2：关于静态方法的说明：
                1：静态方法同样属于类，和实例对象的创建无关；静态方法的调用必须使用 staticmethod 装饰器装饰；
                2：静态方法中无需代表类本身的参数，传入方法的参数从第一个开始；
                3：静态方法无论是在类的内部还是类的外部，都可以通过ClassName.func_name()或者obj.func_name()来调用；
                4：静态方法中不能直接通过 self 关键字访问实例属性和实例方法；
                5：静态方法和类方法都是用来表示和实例对象无关的逻辑；不同点在于，类方法中使用类本身时可以使用表示类本身的参数cls，无需将类名硬编码至代码中；
        
面向对象的三个特性：
    封装：面向对象中，一个类只需向外暴露合适的接口即可，无需让类外部看到类内部的所有实现，因此需要给类成员添加不同的访问权限，称之为封装；
        1：python中不使用public、protected、private等关键字来表示类成员的权限，而是通过给类成员名称前加 __ 来实现成员的私有性；

        2：python中，如果属性名称以__作为前缀，那么该属性将是private权限，该属性只能在类内通过属性名称访问，无法在类外部访问；

        3：python中为类成员添加 __ 作为名称前缀，来实现成员私有性的本质并非是直接让外部不可访问，而是在python解释器中重新设置私有成员的名称：一般情况下，__name 会被转换为 _ClassName__name;

        4：在类的内部，可直接使用self.__name来访问私有权限的实例属性/方法，或者通过ClassName.__name来访问私有类属性和类方法；但是在类的外部，不推荐直接使用_ClassName__name的方式访问私有成员(不同的python解释器会重置成不同的名称，因此并不推荐在类外部访问私有属性，而是遵守python规范)；

        5：如果出于特殊情况，必须访问类内私有属性，可以为该属性提供set/get方法，保证能够在外部访问私有属性；

        6：在python面向对象中，__name__和__name不同；__name__表示系统成员，在类的外部和内部均可直接通过__name__来访问，但是__name表示私有成员；
    
    继承：
        1：python中继承一个类，需要将被继承的类写在类名后的()中；

        2：并且python支持多继承，多个被继承的类需要使用 , 隔开；如类A继承类B和类C： class A(B,C);

        3：继承的特征：一个类继承了另一个类之后，除过子类中自定义的属性和方法以外，还将具有被继承类的所有非私有权限的方法和属性，并且允许重写和重载父类方法；

        4：子类访问父类的属性和方法：
            在子类内部访问：
                通过类名访问：
                    1：类属性
                        ParentClassName.attr_name     # 使用父类类名访问父类的类属性
                    
                    2：类方法：
                        ParentClassName.func_name()     # 使用父类类名访问父类的类方法
                    
                    3：静态方法：
                        ParentClassName.func_name()     # 使用父类类名访问静态方法
                    
                    4：实例方法：
                        ParentClassName.func_name(self)    # 使用父类类名访问父类的实例方法
                    
                    5：构造方法：
                        ParentClassName.__init__(self)    # 使用父类类名访问父类的构造方法

                通过super()函数访问：
                    1：python2中使用super()函数：super(ClassName,self).func_name/attribute_name

                    2：python3中使用super()函数：super().func_name/attribute_name

                    3：super()函数在调用父类方法时，会根据__mro__顺序(父类继承顺序)来依次查找父类的方法，只要找到父类的该方法将会立即停止查找，并由继承链的最高点向下依次执行该方法；

            在子类外部：
                1：通过子类对象访问实例属性和实例方法：
                    1：检测子类本身是否有对应的实例属性和实例方法；如果有则直接访问子类本身的实例属性和实例方法；如果无：
                    2：检测子类本身是否有对应的类属性和类方法(或者静态方法)，如果有则直接访问子类本身的类属性和类方法(或者静态方法)；如果无：
                    3：根据__mro__顺序(父类继承顺序)依次检测父类是否有对应的实例属性和实例方法，如果有则访问父类的实例属性和实例方法；如果无：
                    4：根据__mro__顺序(父类继承顺序)依次检测父类是否有对应的类属性和类方法(或者静态方法),如果有则访问父类的类属性和类方法(或者静态方法)；如果无：
                    5：直接AttributeError异常；
               
                2：通过子类类名访问类属性和类方法以及静态方法：    
                    1：检测子类本身是否有对应的类属性和类方法(或者静态方法)；如果有则直接访问子类本身的类属性和类方法(或者静态方法)；如果无：
                    4：根据__mro__顺序(父类继承顺序)依次检测父类是否有对应的类属性和类方法(或者静态方法),如果有则访问父类的类属性和类方法(或者静态方法)；如果无：
                    5：直接AttributeError异常

                3：关于继承时的构造方法调用顺序(父类再无父类)：
                    1：如果当前类中有构造方法，则执行当前类的构造方法；如无：
                    2：根据__mro__顺序(父类继承顺序)查看父类是否有构造方法，如果有则执行父类的构造方法；如无：
                    3：执行object类的构造方法；
                
                4：在父类还有其他父类的情况：根据父类的继承情况不同，可以分为：菱形继承和U型继承；
                    1：如果是菱形继承，那么类方法，类属性，实例方法，实例属性的查找顺序则是先本类，后所有直接父类，再是父类的父类；如以下几个类：
                        class B(E):
                            pass
                        class C(E):
                            pass
                        class D(E):
                            pass
                        class A(B,C,D):
                            pass
                        那么在查找类A的父类属性和方法时，将会先安装B、C、D的顺序查找，如果还未找到则查找按照E；

                    2：如果是U型继承，那么类方法，类属性，实例方法，实例属性的查找顺序则是先本类，再是第一个父类，然后插座第一个父类的父类，直至当前父类的继承链查找完毕再从下一个父类按照上述顺序查找；如下几个类：
                        class B(E):
                            pass
                        class C(F):
                            pass
                        class D(G):
                            pass
                        class A(B,C,D):
                            pass
                        那么在查找A类的父类属性和方法时，将会按照B->E、C->F、D->G的顺序查找；
        5：因为子类继承父类之后子类也将拥有父类的某些属性，因此继承特性主要用来实现代码之间的复用；
        
    多态：
        多态的本质：
            1：在面向对象中多态是继承的一个衍生特征：即系统承认子类是一种父类类型；也就是如果某个参数接受父类类型的值，那么同样接受子类类型的值；这种特征称之为多态；

        多态的作用：
            1：根据多态的会将子类当做一种父类类型的特性，多态最大的作用就在于打破同一个父类不同子类之间的类型限制，能够让一个接受父类类型的参数接受该父类不同的子类类型；
            2：该作用的具体应用就是实现设计模式中的"开闭原则"，即对扩展开放，对修改关闭；如下示例：
                # 调用方代码：
                def out(ob):
                    # 因为多态，out函数可以接受不同类型的实例对象，因此可以通过传入不同的ob对象，即可调用不同对象的tfun方法；避免为不同的ob对象编写不同的调用方代码，实现调用代码的共用，并且无需关心不同对象中tfun方法的具体实现细节；
                    ob.tfun()  

                # 被调用方代码
                class A():
                    pass

                class B(A):
                    # 被调用方对只需按照调用方要求对外提供对应的方法即可
                    def tfun(self):
                        print "B-tf"

                class C(A):
                    # 被调用方对只需按照调用方要求对外提供对应的方法即可
                    def tfun(self):
                        print "C-tf"

                # 客户端代码：客户端在调用不同子类实例对象的同一个方法时只需通过out函数传入不同对象即可；对于客户端代码更加简洁；
                # 传入B类的实例对象，即可执行B类的tfun方法；
                out(B())
                # 传入C类的实例对象，即可执行C类的tfun方法；
                out(C())

            根据以上示例来看：使用多态特性编码之后有以下几个优势：
                1：客户端代码更简单，对功能提供方的调用更统一协调；
                2：对于客户端而言，如果有新增tfun，只需新增一个A类的子类，并在子类中实现tfun功能即可，无需修改中间的调用方out函数；

        多态的实现：
            1：在弱数据类型的脚本语言中(如：python、php等)，参数没有类型的严格限制；语言本身就天然支持多态，并且不仅仅只是父子类型之间的兼容，更扩展到了任意类型之间的兼容；
            3：在强数据类型的语言中(如：java等)，参数有严格的类型限制；如果没有多态特性的支持，那么将无法做到屏蔽类型细节，实现代码共用的能力；

python中的魔术方法和特殊属性：
    特殊属性：
        1：python中以__作为前缀，且以__作为后缀的属性称之为特殊属性，存储了实例对象的元数据；
        2：常见的特殊属性：
            1：__doc__：存储模块、类、函数/方法的文档字符串
                类的文档字符串可以通过ClassName.__doc__和obj.__doc__来获取；
                方法的文档字符串可以通过ClassName/obj.func_name.__doc__来获取；
            
            2：__name__：表示类、函数/方法、模块的名称
                对于模块：当模块作为可执行文件执行时，__name__=__main__,否则__name__=模块名称
                对于类：__name__即为类名，需要使用类名来访问
                对于函数/方法：__name__即为函数/方法名，需要使用对应的函数/方法来调用
            
            3：__module__：类所在的模块的名称
                如果当前文件作为可执行文件执行时：__module__=__main__
                如果当前文件作为其他模块引入时：__module__=模块名

            4：__bases__：类的父类，返回结果是元祖
                访问时，只能以类名调用：ClassName.__bases__
            
            5：__class__：对象或者所属的类
                对象调用时：obj.__class__：返回对象所属类
                由于python中类本身也是对象，因此类调用__class__时，返回的是改类所属的类
            
            6：__dict__：返回类或者实例对象的属性；返回结果为字典，且可写；
                类调用时：返回类锁具有的所有属性(一些特殊属性和类属性)
                对象调用时：返回对象的所有实例属性
            
            7：__mro__：返回类的方法解析顺序表：
                访问时，只能以类名调用，返回一个元祖，内容为类的方法解析顺序表；
            
            8：__file__：返回当前文件的文件名
            
    魔术方法：  
        1：python中以__作为前缀，且以__作为后缀命名的方法称之为魔术方法；魔术方法能够修改实例对象的特征，能够为实例对象添加某些特征；python语言本身也对魔术方法做了深度支持：即类中如果实现了特定的魔术方法后，某些标准库函数也能够支持该类的实例对象参与运算；

        2：魔术方法在定义之后，无需手动直接调用定义的魔术方法；所定义的魔术方法会修改或者增加当前类实例对象的特性，在当前类的实例对象参与某些运算或者表达式时会自动调用所定义的魔术方法；

        3：常用的魔术方法：
            实例化相关的魔术方法：__new__、__init__、__del__
                __new__(cls,*args,**kwargs):
                    1：该方法用来创建一个实例对象，并且需要使用super().__new__(cls)基于父类的__new__方法创建实例并返回；
                    2：该方法在创建类的实例对象时会自动调用，无需手动调用；
                    3：该方法的返回值即为该类的实例对象，返回的是什么，实例对象就是什么；并且只有返回的是cls的实例时，才会调用__init__(self)方法对该实例对象进行初始化；
                
                __init__(self)：
                    1：该方法是构造方法，用来对当前类的实例对象进行初始化；
                    2：该方法只有在__new__方法返回的是当前类的实例对象时才会调用，否则不会调用该方法；
                    3：该方法第一个参数是self,表示新创建的实例对象；
                
                __del__(self)：
                    1：该方法是析构方法，在当前类的实例对象无任何引用时，系统会自动调用该方法来销毁对象；调用完该方法之后，对象所分配的内存开始等待gc进行清理；

            可视化相关的魔术方法：__str__、__repr__、__bytes__
                __str__(self)：
                    1：返回实例对象的字符串形式；该方法的返回值即为直接打印实例对象的输出值；
                    2：该方法在print(obj)、format(obj)以及str(obj)被调用时会自动调用；
                
                __repr__(self)：
                    1：返回实例对象的字符串形式；该方法的返回值即为直接打印实例对象的输出值；
                    2：该方法只有在__str__(self)没有被定义时才会调用；
                    3：如果该方法和__str__都没有定义，那么打印实例对象时将直接返回对象的内存地址信息；
                    4：该方法会在repr()被调用时调用该方法，在 print()、format()、str()被调用时会优先调用__str__方法，只有__str__没有被定义时才会调用__repr__方法
                
                __bytes__(self)：
                    1：该方法返回实例对象的bytes形式，在调用bytes(obj)时会调用__bytes__方法；

            支持hash和==运算：__hash__、__eq__
                __hash__(self)：
                    1：如果类中重写了该方法，那么该类的实例对象即可使用内建函数hash()进行hash运算；
                    2：如果重写该方法，务必返回一个整数；所返回的整数即为hash(obj)的返回值；
                    3：__hash__方法的返回值不会影响到==运算以及当对象作为set、dict的key时的唯一性检测；

                __eq__(self,other)：
                    1：该方法在判断实例对象是否相等(==)以及将实例对象作为set、dict的key时会被调用，以检测是否有相同的对象；
                    2：该方法返回True，则说明当前类的实例对象和other相等；返回False，则说明当前类的实例对象和other不相等；
            
            支持bool运算：__bool__
                __bool__(self)：
                    1：该方法的返回值必须是个布尔值，当实例对象需要被转换为布尔类型时，会调用该方法；该方法的返回值即为转换之后的布尔值；
                    2：如果该方法没有定义，那么会查找__len__()方法，如果__len__()方法返回0则是False,大于0则是True;如果__len__()方法也未定义，那么所有实例对象都返回True;
                
            容器相关方法：__len__、__iter__、__contains__、__getitem__、__setitem__、__missing__
                __len__(self)：
                    1：当实例对象作用于len()函数的时候将会调用该方法；该方法务必返回一个正整数，该方法的返回值即为len()函数的返回值；
                    2：该方法在实例对象转换为布尔值时，如果没有定义__bool__()方法，那么也会根据该方法返回的值来转换为布尔值；
                
                __iter__(self)：
                    1：如果重新定义了该方法，那么该类的实例对象将会成为可迭代对象；
                    2：该方法务必返回一个实现了__next__方法和__iter__的对象(即迭代器)，如果是类自己实现了__next__方法，那么返回self即可；如果返回值不是一个实现了__next__和__iter__的对象，那么该实例对象虽然是一个Iterable类型的对象，但是无法使用next()函数顺序获取元素并且也无法使用for循环遍历元素；
                    3：python中可以使用iter()函数将一个可迭代对象转换为迭代器；
                
                __next__(self)：
                    1：如果一个类实现了__next__(self)方法，那么该对象可作用于next()函数，即使用next(obj)时将会调用该实例对象的_next__()方法，该方法的返回值也是next()函数的返回值；
                    2：如果一个类实现了__next__方法，那么该类的实例对象也可以通过for循环遍历，和通过next()函数调用；
                    3：在for循环中，遍历一个对象时，也是不断调用该对象__next__()方法的过程；
                
                __contains__(self,item):
                    1：如果重新定义了该方法，那么在使用in 和 not in运算符检测子项是否在对象中时会调用该方法；
                    2：如果未重新定义该方法，那么在使用in 和 not in运算符检测自相是否在对象时会调用__iter__遍历，如果两个方法都未定义，那么将会报错；

                __getitem__(self,key)：
                    1：如果重新定义该方法，那么该类的实例对象将会转换为一个序列对象；支持使用key来获取键值：obj[key]
                    2：该函数内部可以根据业务需求，来实现根据key返回值的逻辑；
                
                __setitem__(self,key,value):
                    1：如果重新定义该方法，那么该类的实例对象将会转换为一个序列对象；支持通过key来设置键值：obj[key]=value
                    2：该函数内部可以根据业务需求，来实现根据key设置某个序列键值的逻辑；
                
                __missing__(self,key)：
                    1：在使用__getitem__时如果key不存在，那么会调用该方法，可以在该方法中实现key不存在是的处理逻辑

            可调用对象：__call__
                __call__(self):
                    1：该方法被重新定义之后，该类的实例对象可以像函数一样直接调用；即obj()时会调用__call__()方法；
                    2：python中，一切接对象，因此，python中调用函数的过程等价于调用__call__方法:func()等价于func.__call__()
        
        4：除过上出魔术方法以外还有：比较运算符重载的魔术函数、算数运算符重载的魔术函数、赋值运算符重载的魔术函数；如果有针对对象的大量运算，可以通过定义这些运算类有关的魔术方法，以方便对象之间参与运算；
    