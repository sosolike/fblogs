1：关于迭代器：
    1：如果一个对象的值由多个有序的元素组成，并且该对象支持按照顺序依次获取组成该对象的下一个元素，那么该对象称之为迭代器；

    2：python中通过next()函数来获取迭代器的下一个元素，而next()函数实际上是执行该对象的__next__魔术方法(对于python3是 __next__ 魔术方法，对于python2是 next 实例方法)；

    3：对于__next__方法(python2中是next实例方法)，python中要求每调用一次都必须返回一个确定的值(即组成该迭代器的下一个元素)，并且要在无值返回时报 StopIteration 异常通知外部已返回完毕；如下示例：
        class TestIter():
            def __init__(self, end):
                self.start = 0
                self.end = end

            def next(self):
                if self.start < self.end:
                    ret = self.start
                    self.start += 1
                    return ret
                else:
                    raise StopIteration

    4：获取迭代器下一个元素的方式同时也是python对于迭代器的协议标准，即一个类中是否有符合要求的__next__方法作为该类的对象是否是迭代器的标准；反之，类的实例对象如果需要成为一个迭代器，那么必须按照python中对__next__的要求来实现__next__方法；

2：关于可迭代对象：
    1：如果一个对象的值由多个有序的元素组成，并且能够通过for循环遍历组成该对象的元素，那么该对象称之为一个可迭代对象；

    2：python中通过for循环遍历一个可迭代对象实际上也是不断调用该实例对象__next__方法获取组成该对象的下一个元素的过程；但是如果持续对一个对象不断调用__next__方法来获取下一个元素，等元素获取结束时将报StopIteration异常，之后将无法再从头对该实例对象进行遍历，不具有可重复遍历的能力；那么为了让该类的实例对象能够被重复遍历，就要求for循环每次在遍历时都是在遍历一个新创建的迭代器对象；
    
    3：python中通过iter()内置函数可以通过可迭代对象返回一个新的迭代器对象，而iter()函数则实际上是在调用该可迭代对象的__iter__方法，因此，在__iter__方法中必须返回一个新创建的迭代器对象，如果本类自己实现了__next__方法，那么也可以返回当前类的实例对象，特别注意：必须是新创建的对象：ClassName()；如下示例：
        class TestIter():
            def __init__(self, end):
                self.start = 0
                self.end = end

            def next(self):
                if self.start < self.end:
                    ret = self.start
                    self.start += 1
                    return ret
                else:
                    raise StopIteration

            def __iter__(self):
                # 注意此处，不是直接返回self，而是创建一个新的对象返回；否则将和next中的self相同，在当前进程中，该实例对象将只能遍历一次
                return TestIter(self.end)    

    4：根据上述对python中for循环的分析，实现一个可以返回一个迭代器对象的__iter__方法就是这个对象能够成为可迭代对象的协议标准；如果一个类中有正确的__iter__方法，那么该类的实例对象就可以通过for循环遍历，即该类的实例对象就是一个可迭代对象；

3：生成器：
    迭代器描述的是对一个由多个元素组成的对象进行遍历获取其组成元素的过程；而生成器则描述的是一个由多个元素组成的对象是如何根据元素创建该对象的过程；
    1：数据集合：一个有多个元素组成的对象，称之为一个数据集合。一个数据集合的产生有以下几种方式：
        1：列举法创建：即将该数据集合中的元素一一列出，形成一个数据集合；
        2：描述法创建：集合中的数据是由某个计算规则得出，该集合中数据的创建规则表示的就是该集合；
    
    2：生成器：
        1：根据列举法创建数据集合对象时，只需一一列出组成该数据集合对象的每一个元素即可；特点是：简单直观，但是对于程序而言存储时较为耗费内存；尤其在组成的元素较多时该问题更加突出；生成器描述的是如何产生一个由多个元素组成的数据集合对象，通过描述法创建一个数据集合的计算规则就称之为生成器；
        2：根据描述法创建数据集合对象时，只需创建生成该集合对象元素的计算规则即可，每执行一次该规则，即创建一个元素；特点是：集合不够直观，组成集合的元素需要执行完该计算规则才能知道，但是更加节省内存空间，能够做到按需生产；
        3：在python中将上述能够生产数据集合对象元素的计算规则称之为生成器；
    
    3：创建生成器：
        1：生成器要求：
            1：生成器调用一次即执行计算规则并返回一个元素值，而非调用一次得到所有的元素值，并能够按照调用顺序依次返回下一个元素值；

        2：生成器实现：
            根据生成器要求，生成器在上一次得到结果之后要暂停执行，等下次调用时从暂停处继续执行，并计算得到下一个结果之后返回；因此生成器最核心的要求就是能暂停当前执行的程序，并能够再次激活执行；python中提供了yield关键来实现程序的暂停和激活；

        3：程序的暂停和激活：
            1：python中提供了yield关键字来暂停函数的正常执行，并能够被激活从yield关键字暂停处继续向下执行，直至遇到下一个yield关键字之后继续暂停或者直接执行完毕；

            2：yield关键字特性：
                1：yield只能在函数中使用，能够暂停函数的正常执行，并能够从暂停处再一次激活继续向下执行；
                2：yield能够向函数外返回一个值，也能够接收函数外部传回的值(python2.5以后的版本)；
            
            3：yield和return的区别：
                1：相同点：
                    1：都是使用在函数中；
                    2：都可以向函数外部返回一个值；
                2：不同点：
                    1：yield只是暂停函数的执行，被暂停的函数能够记住当前执行状态，并在下次激活之后还能继续运行；
                       return则是结束函数的执行，return语句之后函数执行结束，下次调用将从头开始进行全新的一次执行；
                    2：yield不仅仅能够向函数外部返回一个值，yield语句还能够接收外部传给函数的值(python2.5以后的版本)；
                       return则只能向外部返回一个值；
                    3：使用了yield关键字的函数称之为生成器函数，调用生成器函数之后并不会直接执行生成器函数中的代码，而是返回一个生成器对象，并通过特定的方式来运行生成器中的代码；
                       使用return返回值的函数为普通的函数，调用之后将直接执行该函数中的代码；
                    4：生成器虽然并未实现__next__方法，但是生成器符合迭代器的定义，实际上在python中生成器确实是一个特殊的迭代器；
                       而普通函数则不是迭代器；即便为普通函数对象添加__next__魔术方法，该函数也不能成为迭代器；

        4：生成器执行方式：
            1：生成器函数调用之后得到的是一个生成器对象，并非直接执行生成器中的代码；
            2：生成器中的代码需要通过执行传入生成器对象的next()函数来执行，如果在执行生成器代码的同时需要向生成器传入数据则调用生成器对象的send()方法来执行；
            3：执行示例：
                如下一个生成器：
                    def gen(n):
                        print "start run gen"
                        inres = yield n
                        print "restart run gen"
                        yield inres
                        print "stop run gen"
                
                # 在执行该生成器代码时需要先创建生成器对象：
                gener = gen(5)

                #执行生成器中的代码：
                print(next(gener))    # 此时生成器将会运行到第一个yield处，暂停执行，并将参数n返回，因此该行代码打印5；
                说明：
                    1：此时激活生成器函数，将会从函数头部运行至yield处暂停，并将变量n的值返回；
                    2：等待下次激活时，需要向该生成器函数传入数据，所传入的数据将会被赋值给inres变量，并向下继续执行至下一个yield处，并将inres的值返回；
                    3：首次激活生成器函数时也可以使用生成器对象gener调用send()方法激活生成器函数，如：gener.send(None);
                    4：首次激活生成器函数时如果使用send方法，其参数必须是None；首次激活生成器函数的过程也称之为预激；
                
                #继续执行生成器中的代码：
                    print(gener.send("test data"))    # 再次激活生成器，并向生成器中传入参数 'test data' ;
                说明：
                    1：因为需要向生成器传入参数，此时只能使用生成器对象的send方法来再次激活生成器函数；如果不需要向生成器传入参数，那么此时也可使用next()函数激活生成器；
                    2：本次激活之后生成器将运行结束，如果再次激活生成器，那么将会报StopIteration异常；
                    3：使用send方法激活生成器时，生成器必须处理预激状态(即第一次运行至yield处的暂停状态)；为了避免出错，在创建生成器对象之后可以使用next()或者send()方法来预激生成器；
        
        5：生成器的串联：
            1：在python3.3之后，python提供了yield from语法可以用来实现生成器的串联；
            2：yield from语法特征：
                1：使用了yield from的函数本身就是一个生成器，称之为委托生成器；
                2：yield from后必须跟一个生成器对象，后面所跟的生成器称之为子生成器，yield from用来将当前程序的执行权转交给后面所跟的子生成器；实现生成器的串联；
                3：子生成器中也可以使用yield from来串联其他的子生成器；
                4：在委托生成器中，代码执行之yield from处时，将会把当前的执行权交给后面的子生成器，此时委托生成器将成为调用方和子生成器之间的管道：
                    1：调用者可以通过委托生成器的send()方法将数据发往子生成器；
                    2：子生成器yield出的值也会直接返回给调用者；
                    3：子生成器的return值将会作为StopInteration的第一个参数作为yield from的返回值返回，调用者则需要自行处理StopInteration异常；
                5：子生成器执行完毕之后，程序的执行权将重新交回给委托生成器，委托生成器将会继续执行yield from之后的代码；
