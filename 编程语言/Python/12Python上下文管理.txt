一：上下文管理器：
    1：上下文：
        在进行某个操作之前所做的操作称之为上文，在进行某个操作之后所做的操作称之为下文；

    2：上下文管理：
        所谓上下文管理，就是能够自动执行一些上下文处理的逻辑；比如：在执行某项操作之前的初始化工作，可以在上文处理中自动完成；在执行完某项操作之后的善后工作，可以在下文处理中自动完成；

    3：上下文管理的特征：
        1：上下文管理的设计意义在于对于一件事物，只需要关注主要的操作逻辑即可，无需过多关注为该操作所需要的资源创建和资源使用后的回收；
        2：上下文管理的实现本质上是某项操作的前置操作和后置操作；即在执行当前操作之前优先执行前置操作，当前操作执行完成之后，继续执行后置操作；
        3：上下文管理中，下文管理在主要逻辑执行失败、异常、成功都要能够执行，及时释放回收资源；

二：上下文管理具体实现：
    1：通过try...except实现上下文管理：
        1：实现原理：
            上下文管理本质上只是一个预置好的前置操作和后置操作而已，但重要的是后置操作在主要逻辑执行失败、异常、成功时都要能够执行，因此需要使用try...except来实现，只要将后置操作放在try...except中的finally语句块中，无论try块中的逻辑执行结果如何，finally块中的代码都会得到执行；
        2：实现代码：
            #执行某些初始化操作
            print("init")
            try:
                #执行具体的业务逻辑
                print("do something")
            except Exception as e:
                #处理某些异常
                print("salve exception")
            finally:
                #执行某些善后操作
                print("destory resource")
    
    2：通过实现上下文管理协议实现上下文管理：python中提供了上下文管理协议来实现上下文管理器，并提供with语句((with context_expr() as var:)来使用上下文管理器；
        1：上下文管理器：实现了上下文协议的对象即称之为上下文管理器；
            1：上下文协议：python中协议即接口；一个类只需要实现__enter__(self)方法和__exit__(self)方法即可成为上下文管理器；其中：
                __enter__方法会在执行其他实例方法之前先执行；
                __exit__方法会在执行其他实例方法之后执行，并且无论其他的实例方法出现错误、异常还是正常执行，__exit__方法都会被执行；

            2：__enter__(self)方法和__exit__(self)方法： 
                1：__enter__(self)方法，
                    功能：在进入上下文管理器时会被调用，即在实例对象通过with语句调用其他实例方法时会首先执行该魔术方法；通过该方法可以实现上文管理的功能；
                    参数：该方法接收一个参数：self；表示实例对象本身；
                    返回值：该方法的返回值将会赋值给with语句中as子句之后的变量，因此该方法必须返回self对象本身；；

                2：__exit__(self,e_t,e_v,t_b)方法：
                    功能：在离开上下文管理器时将会被调用，即在实例对象调用完其他实例方法之后会执行该方法，且无论其他实例方法是否执行成功、失败、异常都会调用该方法；通过该方法即可实现下文管理功能；
                    参数：接收四个参数：
                        self:代表实例对象本身，
                        e_t代表异常的类型，
                        e_v代表异常的实例对象，
                        t_b代表traceback异常栈；
                        如果with语句块中的逻辑成功执行，那么代表异常的三个参数均为None;
                    返回值：__exit__(self)参数无需返回值；
        
        2：with语句：
            1：with语句用来简化try...finally来实现对上下文的管理，必须和上下文管理器配合使用；

            2：with语句语法：with context_expression [as target(s)]；
                功能：创建上下文管理器对象其中context_expression必须返回一个上下文管理器对象；并且在with语句带有as子句时，会将上下文管理器对象赋值给target(s)；target(s)可以是单个变量，或者是元祖；

            3：with语句的执行过程：
                1：首先创建上下文管理器对象；
                2：执行上下文管理对象的__enter__方法；
                3：在try语句块中执行with语句块中的代码；
                4：检测with语句块中的代码是否抛出异常，如果抛出异常则继续向外层抛出；
                5：在finally语句块中调用上下文管理器对象的__exit__方法
            
            4：with语句只能作用于上下文管理器(否则调用__enter__方法和__exit__方法时将会报异常)，相同的，上下文管理器必须借助with语句才能实现上下文管理功能(否则，__enter__和__exit__方法无法被调用);

    3：通过contextlib模块实现上下文管理：
        实现上下文管理协议创建上下文管理器的方式在面向对象编码时可以方便的实现上下文管理；但是对于面向过程式的编码方式不够友好，python提供了contextlib模块，通过该模块可以将一个生成器函数修饰为上下文管理器；
        1：实现原理：
            contextlib模块的contextmanger装饰器可以将一个生成器函数修饰为上下文管理器；
            1：在使用with语句调用该生成器时，实际上是对该生成器函数预计的一个过程，生成器函数会执行到yield处，并将yield值将会赋值给as子句的target(s)，
            2：with语句块中的内容执行完毕或发生错误、异常等将会重新激活生成器函数，执行yield之后的逻辑；
            3：因此，可以将上文管理代码放在yield之前，下文管理代码放在yield之后；

        2：具体实现示例：
            from contextlib import contextmanager

            @contextmanager
            def func():
                #创建资源、初始化操作
                print("init resource")

                #返回资源
                yield resource

                #销毁资源、善后操作
                print("destory resource")

            with func() as resource:
                #处理具体逻辑
            或者
            with func():
                #处理具体逻辑
    
    4：多个上下文管理器的嵌套：nested()函数；
        1：多上下文管理器嵌套：
            with A() as X:
                with B() as Y:
                 with C() as Z:
                    #do something

        2：多上下文管理器嵌套：
            with A() as X,B() as Y,C() as Z:
                #do something
        
        3：使用nested()函数：
            from contextlib import nested

            with nested(A(),B(),C()) as X,Y,Z:
                #do something
    
    5：with语句和try...except区别:
        1：使用with语句发生异常时，仅仅是会保证__exit__函数一定得到执行，但是with语句并不会处理所发生的异常，所发生的错误异常仍然会向上抛出，直至被捕获或者打印至控制台；因此with语句代替不了try...except;在使用with语句来进行上下文管理时，如果对可能抛出的错误异常需要进行处理，仍然需要使用try...except进行捕获并处理；
        