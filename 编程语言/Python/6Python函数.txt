python函数：
    1：函数的定义方式：
        def 函数名称(形参列表):
            函数体
    
        函数定义中的规范：
            1：函数需要使用def关键字来定义；
            2：函数名称应该遵守python标识符命名规范；
            3：python中的函数体不使用 {} 来包裹，而是通过相同的缩进来作为同一个函数的函数体；
            4：除非函数本身功能、代码、结构简单以外，函数内部应当使用文档字符串进行描述；
            5：函数与函数之间尽量添加两个空行，提高代码的可阅读性；
    
    2：函数的形参列表：
        python中支持5中类型的参数：必选参数、默认参数、可变参数、关键字参数、命名关键字参数；
        1：必选参数：
            声明方式：函数中声明了形参，但是没有给定默认值，在调用函数时，就必须按照函数名称/顺序给出实参数据：func_name(arg1,arg2)

            传参方式：1：按照顺序传入实参：func_name(1,2)
                     2：按照参数名称传入实参：func_name(arg1=1,arg2=2)

            注意事项：函数调用时必须传入实参数据，实参数据将会按照顺序/名称赋值给形参；
        
        2：默认参数：
            声明方式：函数中声明了形参，且给定了默认值，在调用函数时，可以不用给定实参数据，函数将会使用默认值：func_name(arg1,arg2=2)

            传参方式：1：按照顺序传入实参：func_name(1,3)：arg1=1，arg2=3 或者 func_name(1)：arg1=1,arg2=2
                     2：按照名称传入实参：func_name(arg1=1,arg2=3)：arg1=1，arg2=3 或者 func_name(arg1=1)：arg1=1,arg2=2

            注意事项：1：默认参数之后不允许再有必选参数；
                     2：默认参数是在解释器读完函数内容之后就完成的初始化，并不是在每次调用时才初始化；
                     3：默认参数的值将会存储在函数对象的__defaults__属性中，该属性值是一个tuple，按默认参数的顺序，存储每一个默认参数的默认值；
                     4：在函数调用时未给定默认参数值，函数内部将会自动使用__defaults__的值，如果函数形参的默认值是一个可变对象，并且在函数内部修改了该形参的值，那么之后再调用该函数时，该默认形参的值将会是上次调用该函数对该值修改之后的值，而不再是声明时给定的默认值；
                     5：基于4，以及python中的可变对象和不可变对象的原因，应当避免使用可变对象作为函数形参默认值；
        
        3：可变参数：
            声明方式：函数中可以通过一个参数来接收超出必选参数和默认参数个数的参数，这种参数称之为可变参数：func_name(arg1,*arg2)

            传参方式：1：按照名称传参：func_name(arg1=1,2,3,4) :arg1=1，arg2=(2,3,4)
                     2：按照顺序传参：func_name(1,2,3,4) :arg1=1，arg2=(2,3,4)
                     3：对于可变参数本身，可以直接使用list或者tuple传入：func_name(1,*[2,3,4]) 或者func_name(1,*(2,3,4))
            
            注意事项：1：可变参数只能放置在必选参数和默认参数之后；
                     2：可变参数存在的目的在于使用一个参数接收多个实参，或者用来接收list/tuple类型的值，并且会将实参按传入顺序存放在tuple中；
                     3：可变参数用来接收多个实参时，实参只能以值的方式传入，不能以'名称=值'的方式传入；
                     4：使用可变参数接收list类型实参和直接使用必选/默认参数接收list类型的实参具有根本的不同：
                        1：使用可变参数接收list类型的实参值，可变参数的值仅为实参的副本，其内存地址不同，是实参的一份拷贝；在函数内部对关键字参数传入的值做出修改并不会影响外部实参的值；并且函数接收到的数据会保存在tuple中，可以防止函数中误改形参值；
                        2：使用必选参数或者默认参数接收list类型的实参值，此时向函数传递的是实参的引用，即必选/默认参数和实参指向同一个list;在函数内部对list的值做出修改将会影响外部实参的值；
                     5：基于第3条，建议使用可变参数的方式接收list类型的实参；而非直接使用必选参数或者默认参数接收list类型的形参；
        
        4：关键字参数：
            声明方式：关键字参数用来接收dict类型实参或者超出必选参数和默认参数个数的具名参数：func_name(arg1,**arg2)

            传参方式：1：接收dict参数：func_name(arg1=1,**{'key1':value})
                     2：接收具名参数：func_name(1,name='tom',age='23')

            注意事项：1：关键字参数只能放置在必选参数、默认参数、可变参数之后；
                     2：使用关键字参数接收dict类型实参和直接使用必选/默认参数接收dict类型的实参具有根本的不同：
                        1：使用关键字参数接收dict类型的实参，关键字参数的值仅为实参的副本，其内存地址不同，是实参的一份拷贝；对关键字参数做出修改并不会影响外部实参的值；
                        2：使用必选参数或者默认参数接收dict类型的实参，此时向函数传递的是实参的引用，即必选/默认参数和实参指向同一个dict;在函数内部对dict的值做出修改将会影响外部的实参；
                     3：基于第2条的原因，建议使用关键字参数接收dict类型的实参，而非直接使用必选参数或者默认参数接收dict类型的形参；
        
        5：命名关键字参数：
            声明方式：命名关键字参数用来明确表示调用函数时必须使用'名称=值'的方式向函数传入参数；func_name(arg1,*,arg2)

            传参方式：1：按照名称传参：func_name(arg1=1,arg2=2)
                     2：按顺序传参：func_name(1,arg2=2)
                     注意：无论是按顺序传参还是名称传参，命名关键字参数必须按照名称=值的方式传入；
            
            注意事项：1：命名关键字参数之前必须使用*隔开，且*之后的都将被认为是命名关键字参数；
    
    3：函数的返回值：
        函数中使用 return 来向函数外部返回值；可以允许存在多个return,但是仅第一个会执行；
        如果没有明确的返回一个值，函数执行完成之后将会返回None

    4：函数的调用：
        python中函数可以直接使用函数名调用；也可以将函数赋值给变量之后，通过变量来调用；如：
            直接调用：exfun()
            赋值给变量之后调用：varfun = exfun
                              varfun()
    5：高阶函数：
        1：在python中，函数属于顶级对象，函数可以作为参数传递给另外一个函数，也可以作为函数的返回值返回；那么接收一个函数作为参数时，该函数称之为高阶函数；
        2：python内置的几个高阶函数：
            1：map()和reduce():
                map()函数接收两个参数，第一个参数为函数名，该函数中指定要对序列中每一个元素所做的操作；第二个参数为一个可迭代对象；map()函数的作用在于将可迭代对象中的每一个元素都作用于传入的该函数，并返回一个新的值，所有返回的值组成一个新的序列；
                示例：
                    def map_fun(x):
                        return x*2
                    
                    map(map_fun,[1,2,3,4]) :[2,4,6,8]
                
                reduce()函数接收两个参数，第一个参数为函数名，该函数中指定对第一个和第二个参数的操作；第二个参数为一个可迭代对象；
                reduce()函数的作用在于，先向目标函数传入序列的第一个元素和第二个元素，将其操作结果作为第一个元素；然后将第三个元素作为目标函数的第二个参数，进行下一轮计算，直至序列元素结束；并返回最终计算的值；该函数在python2中是内置函数，在python3中则被放入到functools模块中；
                示例：
                    from functools import reduce
                    def reduce_fun(x,y):
                        return x+y
                    
                    reduce(reduce_fun,[1,2,3,4]) :10 
                
            2：filter()函数：
                filter()函数接收两个参数：第一个参数为函数，第二个参数为可迭代对象；该函数的作用在于将序列中的每一个元素作用于形参接收到的函数，并根据该函数返回的布尔值来决定是否保留该元素，实现对序列中元素的过滤；最终返回一个过滤后的元素组成的序列；
                def check(x):
                    if x%2==0:
                        return True
                    else:
                        return False
                filter(check,[1,2,3,4]) :[2,4]

            3：sort()方法：
                1：sort()只能在list上使用，并且是在原list上直接排序，排序结果直接替换原list；
                2：在python2中，sort()函数有三个参数，(均为可选参数)：
                        sort([key[,cmp[,reverse]]])：
                            #对于简单的升序或者逆序排序，无需指定参数，只需使用list_name.sort()
                            #如果list中的元素是dict，则可以通过key参数指定需要排序的key；key指定排序的元素，cmp：为自定义比较大小的函数，reverse：True正序，False：逆序；
                            
                3：在python3上，取消了cmp参数，只有key和reverse两个可选参数：
                        sort([key[,reverse]])：
                            #对于简单的升序或者逆序排序，无需指定参数，只需使用list_name.sort()
                            #如果list中的元素是dict，则可以通过key参数指定需要排序的key；key指定排序的元素，reverse：True正序，False：逆序；

                4：注意事项：
                    1：key参数用在list中的元素不是基本数据类型的数据，而是字典类型的数据，需要指定按照哪个元素进行排序;如：
                        a = [{'age':12,'name':'tom'},{'age':22,'name':'tom2'},{'age':14,'name':'tom4'}]

                        def sortbyage(x):
                            return x['age']
                        
                        def sortbyname(x):
                            return x['age']

                        a.sort(key=sortbyage)：[{'age': 12, 'name': 'tom'}, {'age': 14, 'name': 'tom4'}, {'age': 22, 'name': 'tom2'}]
                        a.sort(key=sortbyname)：[{'age': 12, 'name': 'tom'}, {'age': 22, 'name': 'tom2'}, {'age': 14, 'name': 'tom4'}]
                    2：sort函数是对list本身进行排序，排序结果直接替换原list，因此如果一个list有多个引用时，要注意，排序之后该list所有引用的值都将是排序后的结果；
                        a = [3,7,1,0,3,7,2,78,23,56]
                        b = a
                        b.sort(reverse=True)
                        print(a)    # [78, 56, 23, 7, 7, 3, 3, 2, 1, 0]

            4：sorted()函数：
                对于python2：
                    sorted(iterable,cmp,key,reverse)函数接收四个参数：
                    1：sorted()可以对所有可迭代对象进行排序操作；
                    2：sorted()不会改动原数据，而是返回排序后的新序列；
                    3：sorted接收四个参数：
                        第一个参数：iterable为待排序的序列，后面两个为命名关键字参数；
                        第二个参数：cmp：用来传入自定义排序函数
                        第三个参数：key:如果被排序可迭代对象的元素是若干个dict，那么key用来指定按照dict中哪一个key来排序,其用法和sort中的相同，
                        第四个参数：reverse:True：逆序排序；False：正序排序；
                对于python3：
                    sorted(iterable, *, key=None, reverse=False)方法：   
                    1：sorted()可以对所有可迭代对象进行排序操作；
                    2：sorted()不会改动原数据，而是返回排序后的新序列；
                    3：相比较python2，python3中的sorted只接收三个参数(不再支持传入自定义排序函数)：
                        第一个参数：iterable为待排序的序列，后面两个为命名关键字参数；
                        第二个参数：key:如果被排序可迭代对象的元素是若干个dict，那么key用来指定按照dict中哪一个key来排序,其用法和sort中的相同，
                        第三个参数：reverse:True：逆序排序；False：正序排序；
                    4：备注：
                        由于python3中取消了cmp自定义函数对序列进行排序，但是可以通过functools模块将自定义函数转为key：functools.cmp_to_key(cmp_fun);
                        
    6：返回函数(闭包)：
        1：python中可以将一个函数作为另一个函数的返回值返回；如：
            def outfunc():
                innerfunc():
                    print('inner')
                
                return innerfunc

        2：在一个函数中将另一个函数作为返回值返回的编码方式称之为闭包；调用外层函数之后返回的是内层函数本身，而不是内层函数的执行结果；在执行完外层函数的返回值(即内层函数)之后，才能得到内层函数的执行结果；

        3：闭包的特征：
            1：外层函数调用返回的是内层函数，而不会执行内层函数，只有真正调用内层函数之后才会执行内层函数；
            2：闭包中，内层函数如果持有外层函数的变量，那么在执行完外层函数之后，被内层函数所持有的变量并不会销毁；并且内层函数中所持有的外层函数中的变量的值是外层函数最终执行完成后最后一次对该变量赋的值；如：
                def outer():
                    i = 0
                    for x in range(5):
                        i = x
                        def inner():
                            print(i)
                
                inner_func = outer()
                inner_func()：4
            3：内层函数中如果持有外层函数的可变对象，那么外层函数一旦对该可变对象的值做出修改之后，内层函数所持有的的该可变对象的值也将改变，会引起一些数据上的错误，因此在内层函数慎重使用外层可变对象；
    
    7：匿名函数(lambda表达式)：
        python中支持使用匿名函数，即使用lambda定义函数；
        1：lambda表达式语法：lambda 形参列表:表达式

        2：语法说明：
            1：lambda表达式必须使用lambda标注；
            2：形参列表和lambda之间有一个空格，形参列表中多个参数使用','隔开；
            3：表达式即为函数的处理逻辑，并且只允许一个表达式，最多支持三目运算符，更复杂的表达式不支持；
            4：表达式中不用使用return,表达式的结果就是返回值；

        3：示例：lambda x,y:x*y    #计算x*y的积

        4：lambda可以直接作为函数的实参传入函数，也可以赋值给变量，通过变量调用；
    
python装饰器：
    1：装饰器的作用在于装饰函数；
        1：原理：不改变原函数的情况下，在原函数调用之前或者之后添加代码；并将对函数的调用代码和调用之前之后添加的代码封装成一个新的函数；在需要执行被装饰函数的时候，执行该新封装的函数即可；
        2：本质：装饰器的本质就是对目标函数的调用，仅仅只将调用函数的代码进行了一层封装，并且封装时又在函数执行之前或者之后增加了一部分代码；并不会改变函数本身的逻辑内容、形参以及返回值；但是装饰函数本身可以安装需要接收形参，添加逻辑代码，并改变最终的返回值；
    2：装饰器的实现：
        1：装饰器要求：
            1：仅用来装饰函数，不能改变原函数本身的逻辑内容、形参、返回值；
            2：对函数装饰后，需要将装饰代码和函数的调用代码封装为一个新的函数返回，而不是直接执行装饰代码和调用被装饰函数，并且该函数名称需要和被装饰函数相同；
            3：装饰之后的函数可以根据需要接收任意形参，增加代码，改变最终的返回值；
        2：装饰器实现方式：
            根据装饰器要求，需要将装饰之后的代码作为一个函数返回，因此在python中需要通过闭包的方式实现装饰器；示例如下：
                # 装饰器
                def out_dec(func):
                    inner_dec():
                        print("在执行之前添加逻辑")
                        func()
                        print("在执行之后添加逻辑")
                    return inner_dec

                # 被装饰函数
                def wait_decfunc():
                    print("原函数")

                # 实现对函数的装饰，并返回装饰之后的函数
                wait_decfunc = out_dec(wait_decfunc)

                #调用装饰之后的函数
                wait_decfunc()    

    3：装饰器的特征：
        1：外层函数作为装饰器接收被装饰函数的名称，内层函数则实现对被装饰函数的具体装饰；
        2：调用外层函数之后，即可得到被装饰之后的函数，即内层函数；由于装饰器需要保证装饰之后的函数和被装饰函数名称相同，因此外层函数返回的内层函数需要被赋值为与被装饰函数同名的变量；
        3：虽然调用装饰之后的函数名称和被装饰函数名称相同，但实际上该变量指向的是被装饰之后的函数，也就是内层函数；
        4：由于调用装饰之后的函数实际上是调用装饰器返回的内层函数，因此装饰之后的函数其各种属性就是内层函数的属性，如：__name__是inner_dec，而不是wait_decfunc；
        5：由于第4条，函数被装饰之后，其各项属性都变成装饰器中的内层函数的属性，为了保持装饰之后的函数其属性不变，可以借助functools模块的wraps(funname)来实现：如：
            def out_dec(func):
                @functools.wraps(func)
                inner_dec():
                    print("在执行之前添加逻辑")
                    func()
                    print("在执行之后添加逻辑")
                return inner_dec

    5：简化装饰器使用：
        python中提供了 '@' 来代替调用外部函数以返回被装饰函数的过程；如：
        @out_dec
        def wait_decfunc():
            print("原函数")
        
        wait_decfunc()    #通过@的方式来装饰函数，在调用时直接调用原函数即可；
    
    6：常用的几种装饰器：
        1：被装饰函数有参数：
            def out_dec(func):
                #函数被装饰完成之后返回的是内层函数，调用时也是调用内层函数，所以传递给原函数的参数需要借助内层函数传递至原函数；
                inner_dec(param,param2):        
                    print("在执行之前添加逻辑")
                    func(param,param2)
                    print("在执行之后添加逻辑")
        
        2：装饰器函数带有参数：
            #装饰器函数本身带有参数时，需要使用三级封装来实现；
            def decorateParam(param):   
                def decorate(funed):
                    def decorate_fun(param1,param2):
                        print("param")
                        print("装饰指定函数")
                        funed(param1,param2)
                        print("装饰指定函数")
                    return decorate_fun
                return decorate
    
    7：多个装饰器装饰函数：
        python中支持多个装饰器装饰一个函数，系统将会按照装饰器顺序依次装饰；@装饰器越靠近函数，就越先被用来装饰函数；如：
            @deca
            @decb
            def funca():
                print("func")

            系统会先使用decb装饰器装饰函数funca,然后再使用deca装饰器装饰decb装饰完之后的函数；