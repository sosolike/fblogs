变量：
    变量的声明：
        1：python中变量在使用之前必须先声明，后使用；如：
            vara += 1:将会报NameError异常，变量vara未定义；需要先通过vara = 0 vara += 1
        2：python具有松散的数据类型，因此变量声明时无需注明数据类型，在程序运行过程中，变量的数据类型会根据其指向的数据的数据类型而定；
        3：python中的变量在程序运行过程中可以引用不同数据类型的数据；
        
    变量的命名规范：
        1：以数字、字母、下划线组成；
        2：不能以数字作为开头；
        3：严格区分大小写；
        4：不能使用系统关键字作为变量名；
        5：要具备可读性，除过迭代器和计数器以外，避免使用单字符作为变量名；
        6：避免使用以"__"作为前缀且以"__"作为后缀的变量名；
        7：避免使用中英混合命名；

    变量的权限：
        1：在python模块中：
            以 '_' 作为变量/函数/类名的前缀时，表示当前变量在当前模块中是protected状态，无法通过 from module import * 直接导入使用，而是需要显示导入该变量；
        2：在Python类中：
            以 '__' 作为实例属性/实例方法名称前缀时，表示当前实例属性/实例方法在该类中是private状态，不能被实例对象直接调用；在Cpython解释器中，一般以__命名的实例属性和实例方法名称会被改写为：_类名__原名称;

    变量的作用域：
        作用域：作用域即某定义的作用范围,在Python中，只有模块、类、函数、方法才会产生作用域，其余语句块均不会产生作用域；变量在不同的区域定义将会有不同的作用域；
        作用域范围：根据变量所在的区域不同，分为以下几种作用域：局部作用域、嵌套(闭包)作用域、全局作用域、内置(built-in)作用域
        局部作用域：
            函数或者方法中形成的作用域称之为局部作用域，如果变量定义在函数/方法中，那么所定义的变量仅能够在当前函数/方法中使用，在函数/方法外部，无法访问到函数/方法内部所定义的变量；
        嵌套(闭包)作用域：
            如果函数/方法中有被嵌套函数，并且变量定义在被嵌套函数的外部，外层函数的内部，对于被嵌套函数而言，变量所处的作用域称之为嵌套作用域；所定义的变量仅能在外层函数内部和被嵌套函数内部访问到，外层函数外部则无法访问到该作用域的变量；
        全局作用域：
            模块中形成的作用域称之为全局作用域，如果变量/函数/类定义在模块中，那么该变量/函数/类仅能在当前模块直接使用，其他模块需要先引入之后才能使用；
        内置作用域：
            如果变量定义在python的built-in模块中，那么该作用域称之为内置作用域；无需导入，可以在任意模块中直接使用；

    关于global和nonlocal关键字：
        1：python中查找变量的定义会按照以下顺序查找：局部作用域-->嵌套作用域-->全局作用域-->内置作用域；如果未找到将会报NameError异常；在跨作用域查找变量定义时会有以下几个限制：
            1：在函数中或者被嵌套的内层函数中可以直接访问全局作用域中定义的变量，但是仅能够读取该变量的值，不能对该变量做修改；
            2：在被嵌套的内层函数中可以直接访问外层函数中定义的变量，但是同样仅能够读取该变量的值，不能对该变量做修改；
        2：如果需要在函数或者被嵌套的内层函数中访问并修改全局作用域中定义的变量，那么需要在对应区域使用 global 关键字来声明全局作用域下的同名变量；
            如果在内层函数中需要访问并修改外层函数中定义的变量，那么需要在内层函数中使用 nonlocal 关键字来声明外层函数中定义的同名变量；

        3：特别注意：Python2中只有global关键字，并无nonlocal关键字；

    变量存放方式：
        1：变量在python中是以dict的形式存放，可以通过globals()函数和locals()函数获取存放变量的dict；
        2：globals()函数和locals()函数区别：
            1:globals()函数获取的是存放全局变量的dict;
              locals()函数获取的是存放局部变量的dict;但是在模块中直接调用locals()函数，其返回值和globals()的函数返回值相同，获取的都是存放全局变量的dict；
            2:python中允许通过globals()函数返回的存放全局变量的dict来修改全局变量的值;
              不允许通过locals()函数返回的dict修改局部变量的值，但是在模块中直接调用locals()函数获取的是存放全局变量的dict,因此在模块中可以通过locals()函数返回的dict修改全局变量的值；
    
    创建变量：
        1：python中除过可以通过声明的方式创建变量以外，还可以动态创建变量；
        2：通过存放变量的dict创建变量：
            1：动态创建变量的原理：
                python中的变量是在dict中存储的，因此动态创建变量的本质就是向存储变量的字典中添加一个键值对即可，键名即为变量名，键值即为变量值；
                添加变量时需要先通过globals()函数和locals()函数获取存放变量的dict，然后通过新增键值的方式新增变量即可；
            2：动态创建变量：
                globals()['var_name'] = value  或者  locals()['var_names'] = value

        3：通过exec()函数动态创建变量：
            1：动态创建变量原理：
                exec()函数用来执行存储在字符串或者文件中的代码段，因此可以通过exec()函数来执行声明变量的代码字符串来动态创建变量：
            2：动态创建变量：
                exec("a = []")  # print(type(a)) : <class 'list'>
            3：exec()函数说明：
                原型：exec(str,globals=None,locals=None)
                功能：执行str对象中的代码块，并返回None；(想要正确执行该函数，str必须是符合Python语法要求的代码块组成的字符串)
                参数：str：由符合Python语法要求的代码块组成的字符串
                     globals：dict,全局变量作用域，默认使用globals()，如果指定该参数，那么该参数可以用来定义str中代码所需要的变量，并且str中的代码执行之后产生的新变量也将只存在于传入的dict中，将不再是globals()返回的dict中；
                     locals：dict,局部变量，默认使用locals()，如果指定该参数，那么该参数可以用来定义str中代码所需要的变量，如果locals和globals中同时存在，则locals中的变量值会覆盖globals中的变量值；并且str中的代码执行之后产生的新变量也将只存在于传入的locals参数的dict中，将不再是globals参数的dict中；
                说明：1：exec中可以直接执行一个代码块，但是并不会返回执行结果，而是单纯的执行代码块而已；
                     2：exec的globals参数和locals参数不仅仅可以为str中的代码提供需要的变量，同时也规定了str中的代码执行之后产生的新变量的作用域；保证str代码的执行安全；
                     3：由于exec执行str中的代码和实际执行代码相同，因此在调用exec执行str中代码时务必保证str中的代码无害；
            4：关于eval()函数和exec()函数的区别：
                原型：eval(expression,globals=None,locals=None)
                功能：执行str格式的表达式，并将执行结果返回；
                参数：str：由符合Python语法要求的代码块组成的字符串，只能是表达式(比如:算术运算、条件运算、逻辑运算、按位运算、函数调用等及其组合)，不能是任何语句；
                     globals：dict,全局变量作用域，默认使用globals()，如果指定该参数，那么该参数可以用来定义str中代码所需要的变量；
                     locals：dict,局部变量，默认使用locals()，如果指定该参数，那么该参数可以用来定义str中代码所需要的变量，如果locals和globals中同时存在，则locals中的变量值会覆盖globals中的变量值；
                说明：1：eval()相比exec()只是执行一个简答的表达式，并非执行代码块；
                      2：eval()会将执行结果返回，而exec()并不会返回任何对象，只返回None;
                      3：虽然eval()函数仅仅只是执行简单的表达式，并不会修改变量或者创建新的变量，因此相对exec更安全,但是并非绝对安全，eval支持函数调用的表达式，如果被调用函数中执行了有害代码，通过eval同样能够造成破坏；

    变量赋值：
        1：变量可以在声明的同时赋值，如：var_name = 12;
            注意：声明的同时赋值只能是单纯的赋值，不能在声明的同时进行运算赋值，如：a += 12，将会报NameError；因为运算赋值+=本质是a = a+12；此时右侧的a还未声明，因此报错；
        2：python中为变量赋值时，如果值后带有 ',' 那么解释器将会把值解释为一个tuple赋值给变量；如：a = 1,    #a的值为(1,)
    
    查看变量的内存地址：
        python中通过id()函数查看变量的内存地址，查看方式为:id(var_name);

    可变对象和不可变对象：
        python中一切皆是对象，可变对象和不可变对象讨论的是对一个对象作出修改的时候改变的是值还是引用；
        可变对象和不可变对象的定义：
            如果通过对象的引用去修改一个对象，其结果是修改了对象本身，而该引用指向的内存地址并未改变，那么称该对象为可变对象；
            如果通过对象的引用去修改一个对象，其结果是创建一个新的对象，并将该引用指向新的对象的内存地址，而该引用原本所指向的对象(包括值和地址)并未改变，那么称原来的对象为不可变对象；
            python中常见的不可变对象有:str、int、float、None、tuple、bool；可变对象有：list、set、dict
            
        对可变对象和不可变对象的引用重新赋值：
            无论对可变对象还是不可变对象的引用重新赋值，该引用都会重新指向新的对象；即通过id()函数在赋值前后可以查看发现该引用的内存地址已经发生改变；

        可变对象/不可变对象的复制：
            可变对象的复制：
                1：将一个指向可变对象的变量a赋值给另一个变量b,系统并不会为b复制a所指向的对象本身，而是将b也指向a所指向的对象；
                2：如果一个可变对象被多个变量引用，那么通过任意一个指向该可变对象的变量修改了该可变对象的内容，其余指向该可变对象的变量的值都将发生改变；如：
                a = ['list1']
                b = a
                a[0] = 'list2'
                print(b)   #打印内容：['list2'],而不再是['list1']
            
            不可变对象的复制：
                1：将一个指向不可变对象的变量a复制给另一个变量b，系统同样不会为变量b分配内存块来存储被复制的内容，而是将变量b指向该可变对象；
                2：但是和可变对象不同，修改任意一个指向该不可变对象的变量，都会为该变量重新分配内存，并存储新的内容；其他指向该不可变对象的变量不会受任何影响；

运算：
    算术运算：
        运算类型：+(加法) -(减法) *(乘法) /(除法) //(整除) %(求余)
        备注：
            1：python本身仅支持数字之间运算；
            2：python中不支持自增自减运算；
            3：对于 '/' 和 '//' 的区别在于：
                '/' 得到的一定是浮点数，无论是否能够整除，无论除数与被除数是否是浮点数，结果都会得到浮点数；
                '//'得到的一定是整数，无论是否能够整除，余数无论大小都将被舍去，结果得到的一定是整数；但是如果除数或者被除数之一是浮点数，那么运算结果一定是浮点数；
        对算数运算的扩展：内置函数、math模块、random模块、decimal模块以及round()函数：
            内置函数：
                abs(x)：获取x的绝对值(整数)
                divmod(a,b)：将a除以b的商和余数结合起来以tuple的格式返回
                pow(x,y)：返回x的y次方
                sum(iterable[, start])：对可迭代对象求和，start可以用来在求和之后继续和start执行加法运算；
            math模块：
                math模块支持了更多的科学运算,使用之前需要先导入math模块：import math
                math中的两个常量：
                    math.pi：表示圆周率
                    math.e：表示自然数
                math中的方法(常用)：
                    math.ceil(x)：对x向上取整
                    math.floor(x)：对x向下取整
                    math.fabs(x)：获取x的绝对值(浮点数)
                    math.fsum([])：对迭代器中的每一个元素求和

                    math.sin(x)：求x的正弦
                    math.cos(x)：求x的余弦
                    math.tan(x)：求x的正切
                    math.asin(x)：求x的反正弦
                    math.acos(x)：求x的反余弦
                    math.atan(x)：求x的反正切

                    math.exp(x)：求e的x次幂
                    math.pow(x,y)：求x的y次幂
                    math.log10(x)：求x的以10位底的对数
                    math.sqrt(x)：求x的平方根
            random模块：
                random模块可以创建随机数，使用之前需要先导入：import random
                #获取一个大于0小于1的随机小数
                random.random()

                #获取一个指定区间的随机小数
                random.uniform(0,9)   

                #获取一个指定区间的随机整数
                random.randint(0,9)  

                #从list中随机获取一项
                random.choice([1,2,3,4])

                #随机打乱list
                random.shuffle([1,2,3,4])

                #从序列中随机截取指定长度的片段，原序列不做修改
                random.sample([1,2,3,4],2)
            decimal模块：
                decimal模块的存在主要为了python中的浮点数运算；decimal模块在使用时需要先导入:from decimal import Decimal

                #使用decimal进行算术运算(使用decimal进行算术运算时，只能传入整数或者浮点数字符串)：
                decimal.Decimal(1)+decimal.Decimal("1.7") = "2.7"

                #使用decimal进行算术运算可以指定运算结果中的有效位数(如果结果是浮点数时)：
                getcontext().prec = 3
                Decimal(1)/Decimal(7)
                结果是0.143,相比float(1)/float(7)，得到的结果有效位数可以控制；

                #四舍五入，保留指定位数：
                Decimal('1.2363').quantize(Decimal('0.00'))
                结果是：'1.24'
            
            round()函数：可以指定浮点数的有效位数对浮点数进行四舍五入运算；如：
                round(1.234,1)  :1.2
                round(1.227,2)  :1.23

    比较运算：
       运算类型： == != > < >= <= is
       备注：
            1：is和==有本质的不同，==仅仅判断两个变量的值是否相同，is则判断两个变量是否指向同一个对象，即变量的值以及值所在的内存地址都必须完全一样才会返回True；
            2：条件运算的结果是个布尔值，即True或者False
    
    布尔运算：
        1：允许的运算类型：and、or、not、in、not in；
        2：布尔运算说明：
            1：and    表示与运算
            2：or     表示或运算
            3：not    表示非运算
            4：in     表示指定元素在目标中是否存在，如果存在返回True，否则返回False
            5：not in 表示指定元素是否不在目标中，如果不在则返回True，否则返回False
        3：特别注意：python中的逻辑运算符是单词，并非其他编程语言中的：&&、|、！这种运算符号；
        4：布尔运算的返回值是布尔值：True或者False；

    赋值运算：
        1：允许的计算类型：=、+=、-=、*=、/=、//=、%=
        2：对于赋值操作而言，除过=以外，其他的均是运算并赋值的简化操作；变量声明的同时赋值仅能够使用=；
        3：对于+=的特殊性：
            1：python中+=赋值运算和先+后=的运算不同：如：a += b 和a = a+b有一定的差异，原因在于:
                1：a+=b 会优先调用a对象的__iadd__方法，如果没有该方法才会调用__add__方法；
                2：a = a+b 则直接调用a的__add__方法
            2：对于__iadd__方法，在运算时会将运算结果赋值给第一个参数，因此要求第一个参数必须是可变对象，如list、set、dict；因此也只有可变对象才会实现__iadd__方法；对于可变对象，使用+=操作，其id值并不会改变，但是可变对象本身的值会改变；

            3：对于__add__方法而言，在运算时并不会改变参与运算的参数值，运算结果会作为一个新的对象返回；

            4：因为+=存在的特殊性，在对可变对象进行+=运算时，指向该可变对象的变量的值都将被改变，需要引起注意；避免对可变对象执行+=运算；如：
                a = [1,2]
                b = a
                a += [3]
                那么a和b的值都将是[1,2,3]，由于b的值被隐式修改容易引起难以发现的错误，因此尽量避免对可变对象使用+=操作；

        4：解包操作：
            在赋值运算中，对于容器类型的的数据在赋值时允许同时按顺序赋值给多个变量，或者对于多个数据可以同时赋值给多个变量：
                #将容器中的数据分别按顺序赋值给多个变量
                b,c,d = [1,2,3]     #b=1,c=2,d=3
                b,c,d = (1,2,3)     #b=1,c=2,d=3
                b,c,d = {"a":1,"b":2,"c":3}     #b="a",c="c",d="d"

                #将多个数据分别按顺序赋值给多个变量
                b,c,d = 1,2,3   #b=1,c=2,d=3

                #左侧变量少于右侧数据时python的处理方式：
                    在python中不允许左侧变量少于右侧数据,否则将会报告ValueError的异常:除非使用可变参数的形式接收右侧的值：
                    b,c = [1,2,3]    #将会报告ValueError
                    b,*c = [1,2,3]    #b=1,c=[2,3]
                    可变参数可以放在任意位置，系统会按照变量位置顺序和参数顺序进行赋值，剩下的值将会赋值给可变参数，如：
                    b,*c,d = [1,2,3,4,5]    #b=1,c=[2,3,4],d=5

                #左侧变量多于右侧数据时python的处理方式：
                    在python中均不允许出现左侧变量多于右侧数据，否则将会报告ValueError的异常；除非使用可变参数的形式接收右侧的值：
                    b,c,d = [1,2]    #将会报告ValueError
                    b,c,*d = [1,2]    #b=1,c=2,d=[]
                    可变参数可以放在任意位置，系统会按照变量位置顺序和参数顺序进行赋值，不够赋值的变量将直接赋值为[]，如：
                    b,*c,d = [1,2]    #b=1,c=[],d=5    

    位运算：
        &：按位求与运算
        |：按位求或运算
        ^：按位异或运算
        ~：按位取反运算
        <<：左移运算；
        >>：右移运算；
    
    序列类型的相关运算：
        1：检测子元素是否存在：
            in 检测子元素是否在指定的父级序列中，如果在返回True，如果不在返回False；
            not in 检测子元素是否不在指定的父级序列中，如果不在返回True，如果在返回False；
        
        2：序列的长度获取：
            len() :支持的数据类型包括：字符串，列表，元祖，字典，集合以及其他实现了__len__()魔术函数的对象
        
        3：序列截取：
            ser[n],ser[n:],ser[n:m],ser[:m],ser[n:m:i]
            支持的数据类型包括字符串，列表，元祖，字典以及其他序列类型；

流程控制：
    条件控制：
        条件控制-1：if
            if 表达式:
                code...
        
        条件控制-2：if-else
            if 表达式:
                code...
            else:
                code...
        
        条件控制-3：if-elif-else
            if 表达式:
                code...
            elif 表达式:
                code...
            else:
                code...
        
        条件控制-4：三目运算符
            x if True else y
            如：
                y=1
                x = 2 if y>3 else 1
                结果:x=1
    条件控制语句书写规范：
        1：在条件表达式中如果需要使用否定词 not ,那么应当使用内联的方式，而不是将not放置在整个条件表达式之前；如：推荐方式：if a is not b；不推荐的方式：if not a is b；
        2：如果一个变量是0、None以及空的集合类型时，在条件表达式中，该变量的值会被主动转换为布尔值False；同样，在条件表达式中，也会主动将值为非0、非None以及非空集合类型转换为布尔值True；
        3：根据第2条特征，不要通过检测长度是否为0的方式来检测某个集合类型的变量是否为空或者不为空；可以直接使用if not var_name或者if var_name即可；
        4：不要编写单行的条件判断语句，尽量将条件表达式和处理代码分在不同行书写，以提高可读性；

    循环控制：
        循环控制-1：while
            while 条件表达式:
                code...

        循环控制-2：while-else
            while 条件表达式:
                code...
            else:
                #在不符合while循环条件是进入else执行，仅执行一次；
                code...
        
        循环控制-3：for-in
            for item in sequence:
                code...

        循环控制-4：for-in-else
            for item in sequence:
                code...
            else:
                code...
        循环控制-5：for-in-range(整数)
            for i in range(5):
                code...

        循环控制-6：for-in-range(整数)-else
            for i in range(5):
                code...
            else:
                code...
        
        循环控制-7：for-in-enumerate
            for (index,item) in enumerate(sequence):
                code...

        循环控制-8：for-in-enumerate-else
            for (index,item) in enumerate(sequence):
                code...
            else:
                code...
        循环控制：
            break：结束并跳出当前循环，执行循环之后的逻辑
            continue：结束本次循环，并进行新的循环

无处理逻辑的代码块：
    对于无任何处理逻辑的代码块中需要使用 pass 来标识