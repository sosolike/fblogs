一：C语言简介：
    1：C语言属于静态类型编程语言，具有严格的数据类型约束；并且C源文件并非可执行文件，C程序执行时，需要先由编译器将C源文件编译链接为可执行文件，再由操作系统执行可执行文件；
    2：C语言属于高级编程语言，但是可以直接操作位，字节，内存地址；因此C语言可以更方便的编写底层应用程序；
    3：C语言在编程方式上仅支持面向过程编程，并不支持面向对象编程；
    4：C语言相比较动态类型语言：
        其优势在于：
            1：C程序在执行之前已经被编译链接为二进制可执行文件，在执行时仅执行二进制可执行文件即可；动态类型语言编写的程序执行时需要由解释器逐行读取解释执行，因此C语言执行效率较高；
            2：C语言可以直接操作位，字节，内存地址；因此C语言可以很方便的编写偏底层的应用程序；
            3：C语言代码错误可以在编译阶段发现，尽最大可能避免出现运行时报错；
        劣势在于：
            1：C语言虽然是高级语言，但是偏底层，其符合应用场景的库更少，编码效率较低；
二：C标准：
    1：C89和C90标准：
            C89来源：ANSI在1989年批准通过了C语言语法规范以及C语言标准库，因此称之为C89标准或者ANSI C；
            C90来源：ISO在1990年采用ANSI批准通过的C语言语法规范及C标准库，因此称之为C90标准或者ISO C；
            C89标准和C90标准指的是同一个标准；该标准也是编译器支持度最高的标准；
    2：C99标准：
            C89/C90标准发布之后，C语言标准委员会又不断的改进C语言；并最终在1999年开发布了新的C语言标准，并称之为C99标准；
            C99标准引入了许多新的特性：内联函数、可变长度数组、灵活的数组成员、复合字面量、支持不定参数个数的宏定义，在数据类型上还引入了long long int以及复数类型等新特性；
    3：C11标准：
            C语言标准委员会在2011年发布了新的C语言标准，称之为C11标准；C11在C99的基础上又引入了字节对齐说明符，泛型机制，对多线程的支持、静态断言、原子操作以及对Unicode的支持等特性；
    4：目前尽量使用C89/C90标准或者C99标准，因为编译器对C11标准的支持程度有限，尽量避免使用；

三：C程序执行流程：
    基本流程：
        由于C语言是静态类型编程语言，C源程序需要先被编译链接为可执行文件，然后在需要执行时由操作系统执行该可执行文件，由C源程序到可执行文件需要经过以下几个阶段：
            1：编写源程序；
            2：对源程序进行预处理操作，得到预处理文件；
            3：对预处理文件进行编译操作得到汇编文件；
            4：对汇编文件进行汇编操作得到二进制目标文件；
            5：对二进制目标文件链接操作得到二进制的可执行文件；
    
    详细流程：
        1：编写C源程序：
            1：通过C语言编写C程序文件，一个C源程序由一个或者多个C源文件组成，每一个C源文件都以.c作为后缀，每一个C源文件都由若干个函数和函数外的语句组成；
            2：一个C源程序必须要有且只能有一个主函数，如果C源程序由多个C源文件组成时，主函数可以放置在任意一个C源文件中；

        2：对源程序文件进行预处理，得到预处理文件：
            1：C源程序中一般会有#include包含头文件的代码，以及对宏的使用；将#include包含头文件的代码替换成头文件内容，将代码中的宏替换成宏的值，这个过程即为预处理；
            2：预处理完成之后得到的预处理文件中仍然是C代码，相比C源文件，仅仅只是将包含头文件的代码替换为头文件的内容，将宏替换为宏的值；并且仍然是文本文件；
            3：预处理文件以.i作为后缀；在linux中使用gcc编译器可以通过命令：gcc -E ./a.c -o ./a.i得到预处理文件；
        
        3：对预处理文件进行编译操作，得到汇编文件：
            1：将预处理之后得到的预处理文件编译之后即可得到特定汇编代码组成的文件；
            2：编译完成之后得到的汇编文件是由特定汇编代码组成的，仍然是文本文件；
            3：汇编文件以.s作为后缀，在linux中使用gcc编译器可以通过命令：gcc -S ./a.c -o ./a.s得到汇编文件；
        
        4：对汇编文件进行汇编操作，得到当前C源程序文件的二进制目标文件：
            1：将编译完成后的汇编文件转换成二进制的目标文件的过程称为汇编；
            2：汇编完成之后得到的目标文件是由二进制代码组成的，是二进制文件；
            3：汇编文件以.o作为后缀，在linux中使用gcc编译器可以通过命令：gcc -c ./a.s -o ./a.o得到目标文件；
        
        5：对二进制目标文件链接操作，得到二进制的可执行文件；
            1：一个可执行文件包括四个部分：
                1：启动代码
                2：使用到的库函数代码
                3：当前C源文件汇编得到的目标文件
                4：组成C源程序的其他C源文件汇编得到的目标文件；
                上一步汇编完成之后只是得到了一个C当前源文件的目标文件，还缺少启动代码、引用到的库函数代码以及组成C源程序的其他C源文件的目标文件，所以还不能作为可执行文件运行起来；
            2：链接的过程即为将当前C源文件汇编得到的目标文件，启动代码，库函数代码和组成C源程序的其他C源文件的目标文件合并成为一个完整的可执行文件的过程；
            3：可执行文件以.out作为后缀，在linux中使用gcc编译器可以通过命令：gcc -o ./aim.out ./a.o ./b.o得到可执行文件；
            4：链接完成之后即可得到最终的可执行文件，在linux平台上以.out作为后缀，在windows平台上，以.exe作为后缀！由于linux平台对于文件后缀并无要求，因此.out可以省略；
    
四：C语言编译器：
    Linux上的常用的编译器为：gcc（最终可执行文件的后缀名为.out，windows上的可执行文件后缀为.exe）

五：基本语法规范：
    1：C源程序的组成：
        1：一个C源程序可以由一个或者多个C源文件组成； 
        2：一个C源程序的每一个C源文件都以.c作为后缀；
        3：每一个C源文件都是由若干个函数以及函数外部的语句(头文件的包含、宏的定义、预处理语句、类型的定义、常量的定义，全局变量的声明、函数的声明)组成；
        4：每一个C源程序都必须要有且只能有一个主函数；主函数可以放在组成C源程序的任意一个C源文件中；
    
    2：C程序执行方式：
        1：源程序必须先编译链接为可执行文件，再由操作系统执行该可执行文件来执行程序；
        2：具体执行时，从程序的主函数处开始执行，并从主函数结尾处结束执行，并将执行状态以整数的形式返回给执行环境；
        3：C语言程序本质上就是函数间不断调用的过程；

    3：C主函数：
        1：一个C源程序必须要有，并且只能有一个主函数；
        2：如果一个C源程序由多个C源文件组成，那么主函数可以放在任意一个C源文件中；
        3：C程序执行时，从主函数开始执行，并从主函数结尾处结束执行；并将执行状态以整数的形式传递给执行环境；
        4：主函数的名称只能是main，不能自定义为其他名称；
        5：主函数的定义方式：
            标准定义方式：
                1：int main(void){/* ... */}
                2：int main(int argc,char *argv[]){/* ... */}
            非标准定义方式：
                3：int main(int argc,char *argv[],char *envp[]){/* ... */}
        6：主函数的形参说明：
            1：按照标准方式定义，可以选择以第一种方式声明，即不接受任何参数，直接声明为void；
            2：按照标准方式定义，也可以选择以第二种方式声明，接收两个参数；其中：
                int argc表示以命令行执行该程序的可执行文件时传入参数的个数；
                    如果没有传递任何参数时，其值为1，因为可执行文件本身的名称也算是一个参数；
                    如果有传入参数时，其值为参数个数+1；
                char *argv[]：一个字符串数组，每一项都指向使用命令行执行该程序时传入的字符串参数；
                    其中argv[0]表示可执行文件的名称；
                    其余传入的参数可以通过argv[1]~argv[argc-1]获取；
            3：按照非标准形式定义时，会在第二种定义的方式上多一个envp参数，表示执行该可执行文件时的环境信息，若干个字符串，每一个字符串都以键值对的形式表示环境信息；该参数表示的环境信息也可以在程序中通过getenv()标准函数获取；
        7：主函数的执行结果：
            C源程序从主函数开始执行，也从主函数结尾处结束执行；在主函数执行结束后，会将执行状态以整数的形式传递给操作系统；
            1：返回值是0或者EXIT_SUCCESS，表示程序执行一切顺利；成功结束执行！
            2：返回值是任何其他非0值，尤其是EXIT_FAILURE，则表示程序执行时出现问题；并未成功执行完该程序；
            3：mian函数并非必须调用return显式的返回一个整数值，如果程序运行到main()的右' } '处，将会自动向执行环境返回状态值0，如果执行发生异常则将会自动向执行环境返回非0状态值；
            4：main()函数的结束等效于在主线程中调用标准库函数exit(),exit()的参数将会作为main()的返回值；

    4：C代码语法要求：
        1：以;作为语句结束符号；
        2：以{}作为代码块符号；
        3：以//作为单行注释，以/* ... */作为多行注释；
        4：标识符命名规范：
            1：以数字，字母，下划线组成；
            2：不能以数字开头；
            3：不能和关键字冲突；
            4：严格区分大小写；
            5：避免使用_或者__开头；
            6：避免使用拼音和英语混合式命名！
        5：一个C源文件结构上由两部分组成：1：函数、2：函数外部的语句；函数外部的语句只能是以下几种：头文件包含语句，宏的定义，类型的定义，常量的定义，全局变量的声明，函数的声明语句，预处理语句；其余具备运算能力或者逻辑处理能力的语句都必须放在函数内部！

六：基本语法内容：
    1：输入输出：
        1：输出单个字符：
            putchar();      #如 putchar('c');
        2：输出字符串：
            puts();     #如 puts("string");
        3：打印任意数据类型的数据：
            printf()
            3.1：基本使用格式：
                printf("format string",data1,data2,data3...);
                说明：该函数功能在于将需要打印的变量和格式化字符串中的格式化字符一一按顺序对应，并对变量内容格式化之后填充至格式化字符串中，然后打印最终的字符串；
            3.2：format string的组成：
                format string由自定义字符和格式化字符组成；自定义字符将会原样打印，格式化字符将会按照顺序对后面的data1、data2等进行格式化，并替换为格式化之后的数据；
            3.3：格式化字符：%[flag][width][.precision][type]
                flag：
                    -：默认输出是右对齐，带上-之后则为左对齐；
                    +：正数带上+号，负数带上-号；
                    #：对于小数，强制输出小数点，对于八进制，十六进制，二进制，带上前缀；
                    空格：用于数字：正数加空格，负数加负号；
                width：
                    最小宽度限制；对于字符串，如果字符串字符个数不足将会使用空格补齐，如果字符个数超过最小宽度限制之后，该限制将会自动失效
                .precision：
                    对于int类型，表示最小输出宽度，不足时将会使用0补齐；
                    对于float、double类型，表示输出精度(小数部位的位数)；
                    对于str类型，表示最大输出宽度；如果字符串长度超过该限制将会截取字符串；
                type：
                    表述被格式化的数据需要被格式化为何种数据类型：
                    字符/字符串：
                        %c          //格式化成字符类型
                        %s          //格式化成字符串类型
                    浮点数：
                        %f          //格式化成单精度(float)类型的小数形式
                        %lf         //格式化成双精度(double)类型的小数形式
                        %e          //格式化成单精度(float)类型的指数形式
                        %le         //格式化成双精度(double)类型的指数形式
                        %E          //格式化成单精度(float)类型的指数形式(以大E表示)
                        %lE         //格式化成双精度(double)类型的指数形式(以小e表示)
                    十进制整数：
                        %d          //格式化成十进制、有符号、int类型整数
                        %hd         //格式化成十进制、有符号、short类型整数 
                        %ld         //格式化成十进制、有符号、long类型整数
                        %u          //格式化成十进制、无符号、int类型整数
                        %hu         //格式化成十进制、无符号、short类型整数 
                        %lu         //格式化成十进制、无符号、long类型整数
                    八进制整数：
                        %o          //格式化成八进制、无符号、int类型整数
                        %lo         //格式化成八进制、无符号、long类型整数
                        %ho         //格式化成八进制、无符号、short类型整数
                    十六进制整数：
                        %x          //格式化成十六进制、无符号、int类型整数
                        %lx         //格式化成十六进制、无符号、long类型整数
                        %hx         //格式化成十六进制、无符号、short类型整数
        4：打印单个宽字符：                
            putwchar()：只能输出单个宽字符，且要使用setlocale(LC_ALL,"zh_CN");来设置本地化
        5：打印宽字符串：
            wprintf()：用于输出宽字符串
                        宽字符标识：%ls;
                        用法：和printf完全一样

    2：C语言变量：
        1：C语言中变量使用基本要求：
            1：C语言中变量使用之前必须先声明，后使用；
            2：声明变量时，必须指明变量的数据类型，变量名称，如有必要可以赋上初始值；
            3：变量声明时，即确定该变量的数据类型；在程序运行过程中，变量只能指向和其数据类型相同的数据，不能指向其他数据类型的数据；

        2：C语言中变量命名规范：
            1：C语言变量名必须遵守C语言标识符命名规范；
            2：C语言变量推荐采用小写+ '_' 分割式命名；如：var_name
        
        3：C语言中使用变量：
            C语言中的变量由两种类型：全局变量和局部变量；
            1：全局变量：在函数外部声明的变量称之为全局变量；
                1：声明位置：在函数外部声明；
                2：初始值：
                        1：如果在声明全局变量的同时赋予该变量初始值，那么该变量的初始值即为设置的值；
                        2：如果声明的同时未赋值：
                            那么对于int类型的变量其初始值为0；
                            指针类型的初始值为null；
                            浮点数类型的初始值为：0.000000；
                            字符串类型的初始值为"";
                3：注意事项：
                    在函数外部只能进行全局变量的声明，不允许进行变量的运算，赋值，打印等其他操作；
                4：全局变量的类型：
                    全局变量按照声明方式的不同，分为普通全局变量和静态全局变量：
                5：普通全局变量：
                    1：声明方式：数据类型 变量名 = 初始值;
                    2：作用域：普通全局变量的作用域为组成该C源程序的所有源文件，即不允许在不同的源文件中出现同名的普通全局变量；
                    3：特性：普通全局变量可以在其他源文件中使用 extern引入；引用方式：extern 数据类型名 普通全局变量名
                
                6：静态全局变量：
                    1：声明方式：static 数据类型 变量名 = 初始值;
                    2：作用域：静态全局变量的作用域仅在当前源文件中；即允许在不同的源文件中出现同名静态全局变量；
                    3：特性：静态全局变量的作用域仅在当前源文件中，因此不允许在其他源文件中引入其他文件中的静态全局变量；
            
            2：局部变量：在函数内部声明的变量称之为局部变量：
                1：声明位置：
                    对于c89/c90规定，在任何执行语句之前，在块的开头声明所有局部变量；
                    对于c99和c++中则没有这个限制，局部变量声明可以放在首次调用之前的任意位置；
                2：初始值：
                    对于局部变量，其声明时如果没有给定初始值，那么其初始值是不确定的，无论是何种数据类型的局部变量，只要未给定初始值，其初始值就是不确定的；
                3：局部变量的类型：
                    局部变量根据声明的方式分为自动局部变量和静态局部变量；
                4：自动局部变量：
                    1：声明方式：数据类型 变量名 = 初始值;   或者  auto 数据类型 变量名 = 初始值;
                    2：作用域：仅限当前函数中，声明语句之后使用；
                    3：生命周期：自动局部变量的生命周期和其所在的函数一致，函数被调用时对该局部变量进行初始化，函数调用完成之后该局部变量即被销毁，下次调用该函数时重复上述流程；
                    4：自动局部变量如果不赋初值，其值是无意义的不确定的；
                5：静态局部变量：
                    1：声明方式：static 数据类型 变量名 = 初始值; 
                    2：作用域：仅限当前函数中，声明语句之后使用；
                    3：生命周期：静态局部变量的生命周期和应用程序一致，函数首次被调用时对该静态局部变量进行初始化，函数调用完成之后该静态局部变量并不会被销毁，下次调用该函数时该函数将不再重新声明和初始化，其值为上次函数调用完毕之后最后一次对该变量的修改；
                    4：静态局部变量如果不赋初值，其值是无意义的不确定的；
    3：C语言常量：
        常量即为值不能修改的量，C语言中通过const关键字创建一个常量或者将变量修饰为常量；
        1：常量使用方式：
            1：通过const关键字创建一个常量：const 数据类型 常量名 = 值；
            2：通过const关键字将变量修饰为一个常量：const 变量名；
            3：通过const关键字将函数参数修饰为一个常量：const 数据类型 形参名称；
        2：常量使用时的注意事项：
            1：通过const创建常量时，必须在创建的同时对常量进行初始化，否则将无法再对常量赋值；
            2：通过const修饰变量为常量时，在修饰完成之后，该变量将不能在重新赋值；
            3：对于函数形参，如果为了防止函数内部对形参做了修改，可以将形参修饰为常量；
        3：const在修饰不同数据类型时有不同的结果：
            1：对于基本类型数据(int float)：使用const修饰之后，该变量本身将不能再重新赋值；
            2：对于指针类型数据：使用const修饰时有以下三种情况：
                const char * uname;   
                此时const修饰的是指针所指向的内存空间，因此uname指向的内存地址中存储的数据不允许再被修改，但是指针本身可以指向其他内存地址；

                char * const uname;
                此时const修饰的是指针变量本身，因此uname指向的内存地址中不允许再被修改，即该指针不能再指向其他内存地址，但是指针指向的内存空间中存储的数据被修改；

                const char * const uname;
                此时const既修饰指针变量本身也修饰指针变量所指向的内存空间，因此uname指向的内存地址中不允许再被修改，即该指针不能再指向其他内存地址，并且指针指向的内存空间中存储的数据也不允许再被修改；
        4：关于常量的赋值：
            1：C语言不允许将const类型的变量赋值给一个非const类型的变量，但是允许将非const类型的变量赋值给const类型的变量；
            2：尤其对于指针变量而言，const char * uname 此种类型表示指针指向的内存空间中的内容不允许被修改，如果将uname的值赋值给非const类型的指针变量,该内存中的值就可以通过新的指针变量来修改；失去了常量的意义；因此这种行为在C语言中不被允许；

    4：C语言运算：
        1：符号运算：
            1：运算方式：
                1：()：
                        表示优先执行()中的语句；
                2：*：
                    在赋值语句中，表示获取一个指针变量所指向的内存空间中的数据；
                    在声明语句中，表示紧跟 * 后面的变量为指针变量；
                3：&：
                    在赋值语句中，一般表示获取一个变量的内存地址；
                    在算术运算场景下中，表示按位与运算；
                4：[]：
                    表示在紧跟在[]之前的变量表示的是一个数组；
            
            2：符号类型运算级别：
                ()运算优先级最高，任何情况下都先执行()中的语句；
                []作为后缀运算符，其优先级仅此于();
                *和&(表示取地址符时)作为前缀运算符，其优先则低于后缀运算符[]；
        2：数值类型运算：
            1：算术运算：+ - * / % ++ --
                使用范围：只能适用于数字
                运算方向：从左至右运算
                级别：仅次于逻辑运算中的' ! '，大于关系运算
                备注： 
                    对于除法：
                        如果除数和被除数都是整数，那么得到的结果也是整数；
                        如果除数和被除数有一个是小数，那么得到的结果也是小数；并且是double类型的小数；
                    对于取余运算：
                        C语言中的取余运算只能针对于整数进行，即%两边都必须是整数，否则编译器将会报错！
                    对于自增自减运算：自增/自减运算在和赋值运算一起进行的时候需要注意前后位置关系：
                        前自增在赋值时先运算后赋值；
                        后自增在赋值时先赋值后运算；
            
            2：比较运算：< > <= >= == !=
                运算方向：从左至右
                级别：整体级别大于逻辑运算符的&&和||，小于算术运算符，但是同级别内< > <= >=的级别高于==和!=；
            
            3：逻辑运算：&& || !
                运算方向：从左至右
                级别：&& 和 || 小于关系运算符，!小于()大于算术运算符
                运算结果：运算结果是一个布尔值

            4：赋值运算：= += -= *= /= %= 
                方向：将右侧的值赋给左侧
                级别：级别最低；
            
            5：6种位运算：& | ^ ~ << >>
                &：
                    按照二进制位求与运算，两个二进制位都为1才为1，只要有一个为0即为0；
                |：
                    按照二进制位求或运算，两个二进制位一个为1即为1，两个都为0时才为0；
                ^：
                    按照二进制位求异或运算，如果两个二进制位的值不同即为1，否则即为0；
                ~：
                    按照二进制位取反：获取某个数值的补码；
                <<:
                    按照二进制位全部左移，高位丢弃，低位补0；如x<<y：x数值向左移动y位；左移 y 位相当于乘以 2 的 y 次方;
                >>：
                    按照二进制位全部右移，如果左侧操作数是无符号类型或者是有符号类型，但是为非负值，则右移时左侧多出了的位直接补0，该情况下右移y位等效于除以2的y次方；如果左侧是负值，则由编译器确定左侧是补充0还是符号位，如果是补充符号位依然等效于除以2的y次方，但是如果是补0，则不等效；
                注意：
                    1：参与位运算的必须是整数；
                    2：参与移动位运算的两侧数值必须都是整数；右侧的数值不能为负值，并且不能超过左侧数据的位长；
        3：数值类运算级别：
            符号类型运算 > ! > 算术运算 > 关系运算 > &&和|| 
            移位运算符的优先级高于比较运算符和其他位运算符，但是低于算数运算符；
    
    5：C语言流程控制：
        1：条件控制：
            1：if..else条件语句：
                if(表达式)
                {

                }
                --------------------------
                if(表达式)
                {

                }else if(表达式)
                {

                }else{

                }
                --------------------------
                if(表达式)
                {

                }else{

                }
            2:switch条件语句：
                switch(var){
                    case 1:
                        code..
                        break;
                    case 2:
                        code..
                        break;
                    default:
                        code...
                }
                备注： 
                    1：switch中只能是整数，不能是浮点数或者其他数据类型；
                    2：case只能是整数，不能是浮点数或者其余数据类型；
                    3：多个分支有共同处理方式，则多个分支可以放在一起，只在最后一个分支结束时使用break语句；
                    4：default不是必须的；当所有的case都无法匹配时，将会走进default;
                    
            3：? :   三目运算符；int a= b>0 ? b : 0

        2：循环控制：
            1：循环控制流程：
                for(int i=0;i<n;i++)
                {

                }
                --------------------------
                while(表达式)
                {

                }
                --------------------------
                do
                {

                }while(表达式);(注意：;一定要有)

            2：跳出循环：
                1：break;结束当前循环；
                2：continue;结束当前循环，并开始新的循环！
    
    6：C语言基本数据类型：整数、浮点数、字符
        1：整数：
            1：整数：无小数部分的数字，包括负整数、0、正整数；
            2：按照占用字节个数的不同，整数分为以下类型：
                short int
                    可简写为：short                     
                    占用空间：2字节(16位)         
                    有符号类型    
                    取值范围：-32768到32767            
                unsigned short int                   
                    可简写为：unsigned short
                    占用空间：2字节(16位)  
                    无符号类型
                    取值范围：0~65535

                int                           
                    占用空间：2/4字节(16位/32位)   
                    有符号类型
                    取值范围：-32768到32767或者-2e32到2e32-1
                unsigned int  
                    可简写为：unsigned                
                    占用空间：2/4字节(16位/32位)   
                    无符号类型        
                    取值范围：0~65535或者0~2e33-1
                特别注意：int类型具体占用几个字节和编译器具体实现有关

                long int                             
                    可简写为：long
                    占用空间：8字节(64位)  
                    有符号类型
                    取值范围：-2e64到2e64-1
                unsigned long int                     
                    可简写为：unsigned long
                    占用空间：8字节(64位)  
                    无符号类型
                    取值范围：0~2e65-1

                在C99标准中又新增了long long int类型：
                long long int                        
                    可简写为：long long
                    占用空间：8字节(64位)
                    有符号类型
                    取值范围：-2e64到2e64-1
                unsigned long long int             
                    可简写为：unsigned long long
                    占用空间：8字节  
                    无符号类型
                    取值范围：0~2e65-1

            3：无符号类型和有符号类型：
                有符号类型：数字可以是正数或者负数
                    默认情况下均是有符号类型，也可以通过signed显式声明；
                    有符号类型包括：负整数、0、正整数；
                    取值范围在负数最小值和正数最大值之间；
                无符号类型：即数字只能为正数
                    无符号类型不是默认类型，使用时需要通过unsigned显式声明；
                    无符号类型包括：0、正整数；
                    取值范围在0和正数最大值之间；
            4：数据溢出：
                向上溢出
                    数据向上溢出时，将会从数据类型的最小值开始从新计数，不同的是：
                        有符号类型溢出之后，将直接从负值最小值开始从新计数(向上递增)；
                        无符号类型溢出之后，将直接从0开始从新计数(向上递增)；
                向下溢出：
                    无论有符号还是无符号，均是从正值最大值从新计数(向下递减)；不同的是有符号类型和无符号类型的正值最大值不同！

            5：对于正数类型占用字节个数的说明：
                所有的整数类型表示的数值范围都和具体的平台以及编译器实现有关，C语言规范并未明确要求某种类型占据多少字节；上述范围表示linux平台(64位)GCC编译器下的数值范围；    
            
        2：浮点数：带有小数部分的数字
            1：浮点数按照精度不同，可以分为以下几种类型：
                float       占用4个字节    单精度    有效位数6位  
                double      占用8个字节    双精度    有效位数15位
                long double 占用16个字节   双精度    有效位数19位

            2：浮点数精确度描述：
                1：浮点数在内存中存储时，整数部分和小数部分是分开转换成二进制存储的；十进制转二进制时采用的是除2取余逆序排列法；有些情况下，小数部分无法被2整除，将会造成无限小数，但是能够存储小数位数的空间有限，将会在精度位的后一位进行四舍五入，最终导致实际保存的小数和真实的小数存在差异；
                2：精度越高，存储的小数部分数字越接近真实小数，但是仍然和真实小数有区别；
                3：由于浮点数存在精度问题，因此禁止在程序中使用==来检测两个小数是否相等；
                
            3：浮点数的表达形式：
                1：浮点数可以使用小数的形式表达，如：1.222
                2：也可以使用指数的形式表达，如：1222e-3或者1222E-3

        3：字符：
            1：字符类型基本特征：
                1：C语言中使用char来表示一个字符类型，使用''来表示一个字符；
                2：字符类型描述符有：
                    char类型和unsigned char类型，其大小均为1个字节；
                    char表示范围在-128~127之间；
                    unsigned char的表示范围在0~255之间；
                2：宽窄字符：
                    1：在C89/C90中C语言使用ASCII字符集和字符编码作为语言的字符集和字符编码；ASCII中的字符称之为窄字符，由窄字符组成的字符串称之为窄字符串；
                    2：对于中文字符，在windows平台采用utf-16存储，使用2个字节存储一个中文字符；但是在unix平台采用utf-32存储，即使用4个字节存储一个中文字符；为此，C语言推出wchar_t类型来表示中文字符，wchar_t的类型的长度由编译器决定！wchar_t类型位于<wchar.h>头文件中！
                    3：使用wchar_t类型的字符称之为宽字符；由宽字符表示的字符串称之为宽字符串；使用wchar_t这种宽字符需要在字符前加L；如：wchar_t d = L'国';
                    4：宽字符的打印：
                        putwchar(): 只能输出单个宽字符，且要使用setlocale(LC_ALL,"zh_CN");来设置本地化
                        wprintf():  用于输出宽字符串
                                    宽字符标识：%ls;
                                    用法：和printf完全一样
                3：转义字符：
                    1：转义字符的初衷是用于表示ASCII编码中的一些非打印字符，转义字符以\或者\x开头，以\开头表示后跟八进制形式的编码值，以\x开头表示后跟十六进制编码值，对于转义字符来说，只能使用八进制或者十六进制；
                    2：因此取值范围有限：
                        八进制形式的转义字符最多后跟三个数字，即\ddd,最大取值\177;
                        十六进制形式的转义字符最多后跟两个数字，即\xdd，最大取值\x7f
                        超出范围的转义字符是未定义的，如果是用超出范围的转义字符，编译器要么报错，要么直接输出！
                    3：对于ASCII编码，0~31范围内的字符为控制字符，只能用转义字符来表示，常见的转义字符如下：
                        \a 	响铃(BEL)     
                        \b 	退格(BS)  
                        \f 	换页(FF)  
                        \n 	换行(LF)  
                        \r 	回车(CR)
                        \t 	水平制表(HT)     一般相当于四个空格，或者 tab 键的功能    
                        \v 	垂直制表(VT)    
                        \' 	单引号 
                        \" 	双引号 
                        \\ 	反斜杠
        

        4：C语言基本数据类型转换：
            1：自动类型转换：自动类型转换是由编译器根据计算需求，自动将数据类型进行转换的一种方式；
                自动类型转换发生在两种情况下：
                    1：赋值时：
                        如果类型转换合法，将会把右侧的变量转换为左侧变量的数据类型，然后赋值给左侧变量，右侧的数据类型不会被改变！但是将高精度值赋给低精度值时将会发生精度损失
                    2：运算中：
                        在运算时，编译器会将所有的数据的类型转换为同一种数据类型，然后再进行计算！
                        1：转换方向：
                            char/short->int->long
                                             ->float->double
                              转换方向为数据长度增加方向(高精度方向)进行;
                        2：所有的浮点运算都是以双精度进行的，即使运算中只有float类型，也将全部转换为double进行运算；
                        3：需要注意的是存储运算结果时由于运算结果类型的变化导致数值的溢出！

            2：手动类型转换：
                强制类型转换方式：(目标数据类型)待转换变量  
            
            3：无论是强制还是自动类型转换，类型转换时都需要注意以下事项：
                1：转换改变的仅仅是结果，源数据的类型并不会改变！
                2：高精度往低精度转换都会发生精度损失！
                3：数据类型转换要合适，只能在基本数据类型之间转换，否则编译器将会报错！
                4：都要注意类型转换之后溢出的问题，尤其在自动类型转换中；
            4：常见数字和字符串之间转换：

        7：NULL：空指针
            1：NULL的本质：NULL本质上是一个宏，该宏的值是一个指针；
            2：NULL的原型：#define NULL ((void *)0)，即NULL是一个指针，指向地址为0的存储单元；
            3：关于NULL的指向：C语言规范中并未规定NULL的指向，只是大多数编译器默认将NULL指向地址为0的存储单元；
        
        8：void类型：
            1：void类型：void类型表示没有可用的值；
            2：void类型使用场景：
                1：函数返回值：如果函数没有返回值需要使用void表示；
                2：函数的参数：如果函数不接受任何参数，可以使用void来表示；
                3：指针指向void：指向void的指针可以指向任何数据类型；
    7：复杂数据类型：
        指针：
            1：存储单元和内存地址：
                1：CPU处理数据时，数据必需先加载至内存中，才能够被CPU访问；所以程序运行时，程序本身以及程序当前处理的数据都将被加载至内存中；
                2：内存在操作系统中逻辑上会被分割为若干个1字节大小的存储单元，每一个存储单元都会有一个编号，这个编号称之为存储单元的地址或者内存地址；通过这个地址即可向存储单元中存取数据；
                3：由于一个存储单元只有1个字节大小，因此在声明变量时，系统将会按照变量的数据类型在当前系统所占用的字节个数，来分配若干个连续的存储单元作为一个内存块给该变量使用；
                4：存储单元的地址从0开始编号，并以16进制表示；数据类型为unsigned int;
            2：对于指针的理解：
                从概念上来看：指针类似一个箭头，指向某个存储单元，这个箭头是虚拟的，并不真实存在；
                从编程上来看：指针表示的就是某个存储单元，在程序中的具体体现就是指针变量，指针变量的值即为某个存储单元的地址；通过指针变量的值即可确定某个存储单元的地址，进而通过该地址访问存储单元中的内容；
            3：指针和数据的理解：
                1：数据是指存储在存储单元中的内容；可以为任何数据类型；
                2：指针表示的是某个存储单元，在程序中的具体表现形式是指针变量，指针变量的值是某个存储单元的地址，通过指针即可访问某个存储单元中的内容；指针变量的值即存储单元的地址数据类型固定为unsigned int类型；
            4：指针变量和普通变量的区别：
                1：意义不同：
                    1：指针变量是指针在程序中的具体体现，其值表示的是存储单元的地址，类型固定为unsigned int；以十六进制表示；
                    2：普通变量代表的是具体的数据，其值是存储单元中的内容；类型在声明变量时确定；
                2：数据类型不同：
                    1：指针变量的数据类型固定位unsigned int 类型；
                    2：普通变量的数据类型则在声明时确定；
                3：运算方式不同：
                    1：指针变量在运算时本质上是改变指针对存储单元的指向；
                    2：普通变量在运算时本质是存储单元中内容的修改；
                注意：
                    1：本质上指针变量和普通变量并没有任何区别，都代表的是数据，只是指针变量代表的数据表示的是某个存储单元的地址，而普通变量表示的数据是某个存储单元的内容；
                    2：虽然指针变量的数据类型为unsigned int，但是不允许将指针变量和数据类型为unsigned int的普通变量进行运算；因为两个变量表示的意义不同，系统在处理时的方式也不同；
                    3：指针变量的值本身也是需要存储在存储单元组成的内存快中，因此存储指针变量值的存储单元同样也是可以被其他指针指向的；
            5：指针变量的声明：
                1：声明方式：
                    数据类型 * 变量名 = 初始值; 
                        或者  
                    数据类型 *变量名 = 初始值;
                2：指针变量声明说明：
                    1：数据类型：表示的是指针指向的存储单元组成的内存块中要存储的数据的数据类型；系统将会按照数据类型分配若干个连续的存储单元；一旦声明完成之后，该指针指向的若干个存储单元将只能存储指定数据类型的数据；
                    2：*可以和变量间隔一个空格也可以紧挨着变量，在声明场景下，*表示紧跟其后的变量是一个指针变量；
                    3：指针变量的命名和普通变量的命名规范一致；
            6：指针的运算：
                1：&：该运算是取地址符；该运算符可以使用在普通变量和指针变量之前，用来获取变量的内容在内存中的地址，即变量的内容所占用的内存块首个存储单元的地址；
                2：*：该运算符是取值符，可以通过*获取指针指向的存储单元中所存储的值；
                3：通过指针变量向内存中设置值：*指针变量 = 值；
                4：指针变量允许和同类型的指针变量之间互相赋值：赋值完成之后，两个指针变量指向同一个存储单元；(参与赋值的两个指针变量必须数据类型相同)；
                5：指针变量可以参与算术运算：指针变量允许加上或者减去一个整数或者对指针变量进行自增自减运算，来改变指针对存储单元的指向；
                6：对于指针变量加减整数或者自增自减运算说明：
                    1：普通变量加减某一个整数是指给存储单元中存储的数据本身加/减去n，不会引起数据在内存中存储地址的改变；
                    2：指针变量加减某个整数m或者自增自减运算:
                        微观上看：指针变量加/减某个整数m，是指将指针变量的指向跳过n*m个存储单元，n是指当前指针变量数据类型在当前平台所占字节个数；
                        宏观上看：指针变量的加减运算改变的是当前指针对存储单元的指向；
                    3：不允许对指针变量做除过加减一个整数/自增自减以外的任何其他算术运算；
                    4：普通的指针变量做自增自减或者加减运算并无任何实际意义；指针的指向会改变，但是指向新的存储单元中的数据则是不确定的；
                    5：对于数组或者字符串,由于其占用的是一段连续的存储单元，因此指针变量的加减/自增自减改变的是指针指向的元素位置，其值是可以预料的，通过对指针位置的改变可以获取到相邻的元素值，是有意义的；
            7：空指针：
                1：在函数中声明一个指针变量但是并不初始化，那么该指针变量的值是不确定的，因此该指针的指向也是不确定的，一般情况下都是指向一个无读写权限的地址，将会造成程序的隐患；
                2：建议在函数中声明指针变量时对其初始化，如果不知道指针变量的初始值，可以将指针变量的值设置为NULL；即把该指针设置为一个空指针；C语言并未规定空指针的指向，但是大多数编译器将空指针指向地址为0的存储单元，并且其类型未知；
                3：对于指针而言，在除过赋值类型的操作以外，要先检测，后操作；严禁对空指针进行赋值以外的操作；

            8：二级指针：
                1：如果指针指向的内存存储的是普通数据，那么该指针称为一级指针，指向存储一级指针变量值的内存的指针称之为二级指针，以此类推三级指针等；
                2：二级指针以上，无论是几级指针，都是普通的指针，都是指向一个存储单元，仅仅只是其指向的内存中存储的内容是另一个指针变量的值而已；
                3：无论是几级指针变量，都表示一个普通的变量，其值都是一个unsigned int 类型的数据，其值都表示一个存储单元的地址；
                4：一级指针变量需要使用*来声明，需要使用*来取值；二级指针变量需要使用**来声明，需要使用**来取值；三级四级依次类推；对于二级指针使用*来取值得到的是以及指针的地址，需要对该地址再次取值运算才能得到最终的值。多级指针原理相同；
        