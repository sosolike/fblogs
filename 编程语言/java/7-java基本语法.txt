1.注释：
    1.java中的注释：
        1.注释类型：单行注释、多行注释、文档注释;
        2.注释功能：单行注释和多行注释用来对代码解释说明;
                   文档注释用来对当前文件中的类、接口、方法、属性等进行解释说明;

    2：单行注释：
        语法：// 注释内容
        位置：语句之前
        例如：int a = 0;    // a的注释

    3：多行注释：
        语法：
            /*
            * 注释内容
            * 注释内容
            */
        位置：语句之前
        例如：
           /*
            * 学生姓名
            * 默认为空
            */
            String studentName = "";

    3：文档注释：
        1：文档注释语法：
            /**
            * 文档注释，对类、接口、方法进行说明
            */
        2：文档注释位置：
            文档注释必须在类、接口、方法、属性、构造方法前面，表示对类、接口、方法、属性、构造方法的说明，不能出现在其他位置，否则视为无效；
        3：文档注释的作用：
            1.文档注释时是对类、接口、方法、属性、构造方法的描述；
            2.文档注释可以通过javadoc工具将文档注释生成为html网页文件，可以通过文档注释文件来了解一个类；
        4：文档注释的组成：
            1.接口、类的文档注释：通常由三部分组成：
                第一部分：
                    1.大概描述接口或者类的作用；
                    2.通常是一句或者多句话组成，以英文符号 . 结束；
                第二部分：
                    1.接口或者类的详细描述；
                    2.通常是一段或者多段话组成；
                    3.描述可以使用<p></p>、<pre></pre>等html标签包裹；
                    4.描述本身由描述内容和文档标记组成，常用的文档标记如下：
                        1.{@link package.class#member label}：表示链接到其他相关的代码；并且label会以代码字体的形式显示，只能使用在文档的描述部分，以{}包裹；
                             使用方式：
                                当前类中未导入包名以及类名；
                                    1.{@link 包名.类名#方法名(参数类型)} 
                                当前类中已经导入了包名或者类名；
                                    1.{@link 类名#方法名(参数类型)} 
                                    2.{@link 类名} 
                                    3.{@link #方法名(参数类型)}
                            文档注释文件显示效果：该标签最终会被作为一个a链接显示；
                        2.{@linkplain  package.class#member label}：表示链接到其他相关的代码；但是label不会以代码字体的形式显示，而是普通的文本形式，只能使用在文档的描述部分，以{}包裹；
                             使用方式：
                                当前类中未导入包名以及类名；
                                    1.{@linkplain  包名.类名#方法名(参数类型)} 
                                当前类中已经导入了包名或者类名；
                                    1.{@linkplain  类名#方法名(参数类型)} 
                                    2.{@linkplain  类名} 
                                    3.{@linkplain  #方法名(参数类型)}
                            文档注释文件显示效果：该标签最终会被作为一个a链接显示；
                        3.{@code text}：表示以代码字体显示text，不会将文本解释为html标记或者javadoc标记；只能使用在描述部分，使用时需要以{}包裹；
                             使用方式：{@code string} 或者 {@code <string>}
                        4.{@literal text}：表示以文本显示text，不会将文本解释为html标记或者javadoc标记；只能使用在描述部分，使用时需要以{}包裹；
                             使用方式：{@literal text}
                第三部分：
                    1.描述类的创建信息，包括作者，版本号，参考类等；
                    2.该部分必须使用文档标记完成，常用的文档标记如下：
                        @author 作者
                        @version 版本号
                        @since 指定版本之后新增的
                        @see 参考其他信息，常见使用方式：
                            @see 文本信息
                            @see #field  参阅当前类的其他字段
                            @see #method（类型，类型，...）  参阅当前类的其他方法
                            @see Class＃field   参阅指定class的其他字段
                            @see Class＃method（Type，Type，...）   参阅指定class的其他方法
                            @see package.Class＃field    参阅指定包中的类的属性
                            @see package.Class＃method（Type，Type，...）参阅指定包中的类的方法
                            @see package.Class    参阅指定包中的类
                            @see package   参阅指定包

           2.写在方法前面的文档注释：同样由三部分组成，
                1.第一部分是对方法的概述，通常是一句或者多句话组成，以英文符号 . 结束；
                2.第二部分是对方法的详细描述，和类、接口的第二部分类似，由html标记包裹，内容则由描述信息和一些文档标记组成；
                3.第三部分是对方法的参数、返回值、异常的描述，必须有文档标记组成，常用有以下标记：
                    @author 作者
                       语法形式：@author 作者
                    @version 版本号
                       语法形式：@version 版本号
                    @param 方法形参
                       语法形式：@param 参数名 参数描述
                    @return 方法返回值
                       语法形式：@return 返回值描述
                    @throws/@exception 将要抛出的异常
                       语法形式：@throws 异常类型 异常描述
                                @exception 异常类型 异常描述
                    @deprecated：过期的方法(注解)表示该方法已经过期，不再推荐使用该方法；
                       语法形式：@deprecated 过期原因；
                    @since 该方法从指定版本之后添加的
                       语法形式：@since 当前项目版本号或者当前时间
                    @see 另请参阅
                        语法形式和类的文档注释中@see标记完全相同；

        5：生成文档注释文件：
            1：使用javadoc命令生成文档注释：javadoc [options] [packagenames]  [sourcefiles] @files
                其中：options：表示javadoc命令的选项
                        -public	    仅显示 public 类和成员
                        -protected	显示 protected/public 类和成员（默认值）
                        -package	显示 package/protected/public 类和成员 (对应default权限)
                        -private	显示所有类和成员
                        -d <directory>  指定javadoc保存生成的HTML文件的目录
                        -version	包含 @version 标记
                        -author	    包含 @author 标记
                        -windowtitle <text>	文档的浏览器窗口标题
                        -header header 指定输出的HTML文档的页眉文本。
                        -footer footer 指定输出的HTML文档的脚注文本。
                        -bottom text 指定输出的HTML文档底部的文本。
                     packagenames：
                        1.表示包列表，即要生成注释文档的包;
                        2.javadoc命令不支持通配符，因此如果有多个包需要一一列出每一个包；
                     sourcefiles：
                        1.表示源文件名，即要生成注释文件的java源文件名称，多个文件可以使用空格隔开;
                        2.javadoc允许四种源文件：类源代码文件、包描述文件、总体概述文件、其他杂文件
                     @files：如果使用packagenames和sourcefiles参数指定相关选项时太过麻烦也可以将选项配置在一个文件中，然后使用@files指定配置文件的路径即可；
            2.使用idea生成文档注释：
                 Tools --> Generate JavaDoc

2.标识符、分隔符以及关键字：
    标识符：
        1：java中给包、类、接口、变量、方法等命名的字符串称之为标识符；
        2：标识符命名规则：
            1：标识符只能以数字(0-9)、字母(A-Za-z)、下划线(_)、美元符号($)组成；
            2：标识符不能以数字开头、不能和关键字以及保留字冲突、严格区分大小写；
            3：标识符在不同的场景下有不同的要求，具体如下：
                1：对于包名：推荐采用完整单词、全小写的方式命名，多个单词之间使用.分隔；
                2：对于类名、接口名：推荐采用完整单词且首字母大写的驼峰式命名法命名；
                3：对于变量、方法名：推荐采用完整单词的首字母小写的驼峰式命名法命名；
            4：标识符名称应该简洁明确，避免中英混合，避免不合理的缩写；
    分隔符：
        语句：
            1：java中一条语句以';'结尾；
            2：语句可以换行书写，但是尽量保持一行只写一条语句，语句中的标识符名称本身不能换行书写；
            3.一条语句应该尽量简短，避免过于长，尽量不要超过79个字符；

        空行：
            1.空行不是必须要求的；可以根据需要添加，来增加文件的可读性；

        代码块：
            1：java中代码块通过'{}'来表示；
        
        空格：
            1.不同的标识符、关键字之间必须要有空格；
            2.()内的参数建议使用空格隔开，运算符两侧建议使用空格隔开，增加可读性；
            3.但是语句中的变量赋值不建议使用空格对齐，如:
                String name = "a";
                int    age  = 12;
    关键字：
        1：java中因为语法需要已经使用的标识符称之为关键字，比如class、interface、int等；自定义的标识符不能和关键字同名；
        2：与关键字类似的还有保留字，即java中暂时没有使用，但是将来可能使用的单词称之为保留字；自定义的标识符同样不能和保留字同名；

流程控制：
    1：条件：
        第一种形式：if
            if(条件){
                /* do something... */
            }

        第二种形式：if...else
            if(条件){
                /* do something... */
            }else{
                /* do something... */
            }

        第三种形式：if...else if...else
            if(条件){
                /* do something... */
            }else if(条件){
                /* do something... */
            }else{
                /* do something... */
            }
        注意：java中if、else if、else语句块会产生作用域，在语句块中声明的变量外部无法访问；

        第四种形式：三目运算：
            流程规则：如果b>c这个条件成立，将b赋值给a，否则将c赋值给a；
            a = b>c ? b : c; 

        第五种形式：switch
            switch(data)
            {
                case a:
                    /* do something */
                    break;
                case b:
                    /* do something */
                    break;
                default:
                    /* do something */
            }
            注意：
                1：swith中的条件值可以是char、byte、short、int等基本数据类型数据，也可以是Character、Byte、Short、Integer等引用类型数据，也可以是String和enum类型的数据；除此之外不允许传入其他类型的数据；
                2：多个条件的处理方式相同时可以共用处理逻辑，在最后处理完成之后再break即可，如
                    switvh(data){
                        case 1:
                        case 2:
                            //do something
                            break;
                        default:
                            //do something
                    }
                3：default分支不是必须要有的，根据实际情况选择是否需要default分支，如果所有的case都未走入时将会进入default中执行；

    2：循环：
        循环方式1：while
            while(条件){
                /* do something... */
            }

        循环方式2：do...while
            do{
                /* do something... */
            }while(条件);

        循环方式3：for：
            for(循环遍量初始值;继续循环条件;循环遍量修改表达式){/* do something... */}
        
        循环方式4：forEach
            for(元素类型 元素变量 : 被遍历对象(数组或者集合))

        循环控制：
            1：break：立即结束当前循环，并跳出循环开始执行循环之后的代码；
            2：continue：终止本次循环，不再执行本次循环剩余的语句，并开始下一次循环；
        注意：
            1.循环语句块会产生作用域，在循环语句块中声明的变量无法再外部访问；
            2.不要再循环语句块中执行资源消耗类的操作或者其他延时操作；
            
4.基本数据类型：
    1：java中的数据类型分类：
        |--引用类型(class类型)
            |--引用类型均直接或者间接继承自Object类
        |--基本类型：
            |--整数类型：
                |--byte：1字节，8位，十进制范围在-128~127；
                |--short：2字节，16位，十进制范围在-32768~32767；
                |--int：4字节，32位，十进制范围在-2147483648~2147483647(-2^32~2^32-1)；
                |--long：8字节，64位，十进制范围在-2^64~2^64-1；
            |--浮点数类型：
                |--float：4字节，32位，6~7个有效位，单精度类型；
                |--double：8字节，64位，15个有效位，双精度类型；
            |--字符类型：
                |--char：2字节，16位，使用unicode字符集，支持65536个字符；
            |--布尔类型：
                |--boolean：1字节，值只有true/false；

    2：基本数据类型说明：
        1：整数类型：
            1.java中的整数按照所占字节数多少分为byte、short、int、long，包括正整数、0、负整数；
            2.java中的整数支持以二进制、八进制、十进制、十六进制表示；
            3.不同进制的整数：
                1：不同进制数字组成：
                    1：二进制以0b或者0B作为前缀，由0和1组成；
                    2：八进制以0作为前缀，由0~7组成；
                    3：十进制无任何前缀，由0~9组成；
                    4：十六进制以0x或者0X作为前缀，由0~9和a~f(A~F)组成；
                2：不同进制之间类型转换：
                    java中进制转换必须以十进制为中间进制，可以将其他进制转换为十进制，然后再由十进制转换为其他进制；
                    1：十进制转其他进制：借助int类型的包装类Integer提供的方法进行转换：
                        十进制转二进制字符串：Integer.toBinaryString(num)
                        十进制转八进制字符串：Integer.toOctalString(num)
                        十进制转十六进制字符串：Integer.toHexString(num)
                        十进制转r进制字符串：Integer.toString(进制数,num)
                        注意：1：待转换值num必须是byte、short、int类型的十进制数字，不能是long型整数，也不能是整数字符串；
                              2：转换结果都是对应进制的字符串；
                    2：其他进制转10进制：
                        Integer.parseInt(String num,int radix)
                        注意：1：待转换值num必须是其他进制的字符串；
                             2：原始进制radix必须以int类型表示；
                             3：转换结果是int类型的整数；
            4.整数字面量：
                1：直接给出的数值，称之为字面量，整数数值称之为整数字面量，系统默认整数字面量都是int类型的；
                2：对于除过int类型以外的的变量赋值时有所不同：
                    1.将一个大小在short、byte类型范围内的整数赋值给short、byte类型的变量，系统只会为该整数分配short、byte对应的内存空间来存储该整数，即系统会将该整数字面量作为short、byte来对待；
                    2：将一个大小在long型范围的整数，赋值给long型的变量，系统并不会将该整数作为long型来对待,而是作为int类型来对待，此时赋值行为将会报错：int类型的数字过大；为了能将大小在long范围内的数字作为long型来使用，必须在数字后面加上l或者L作为后缀；
            5.整数类型转换：
                1：整数类型内部之间转换：在参与运算或者赋值时系统会自动进行整数间类型转换，转换方向如下：
                    byte->short(char)->int->long;
                    注意：转换方向从低精度至高精度转换，只能按照上述方向转换，不允许从高精度向低精度转换，否则将会报错；

                2：整数与其他数据类型间的转换：
                    1：将整数转换为String类型：
                        方式1：String s = "" + 整数；
                            注意：整数可以为任意类型的整数，
                            示例如下:
                                String s = "" + 23;

                        方式3：String s = String.valueOf(num)；
                            注意：待转换值num可以为任意整数类型；
                            示例如下：
                                long num = 999999999;
                                String s = String.valueOf(num);

                        方式2：String s = Integer.toString(int num)；
                              String s = Short.toString(short num)；
                              String s = Byte.toString(byte num)；
                            注意：Integer.toString()中的num只能为int、short、byte类型的整数,
                            示例如下：
                                int num = 233;
                                String s = Integer.toString(num)；

                    2：将整数转换为boolean值：java中boolean仅占一个字节，不允许在整形和布尔值之间互相转换；

                    3：整数转浮点数：由于浮点数精度比整数高，可以直接将整数转为浮点数；在运算表达式中，整数类型可以自动转为浮点类型,转换方向如下：
                        byte->short(char)->int->long->float->double;

                3：使用整数类型时需要特别注意整数取值范围，尤其存储运算结果时要特别注意防止溢出；

        2：浮点数类型：
            1：浮点数类型用来存储小数字面量，包括低精度的folat类型和高精度的double类型；
            2：浮点数精度：
                1.由于小数在内存中以2进制存储，而十进制转2进制时采用除2取余法，如果遇到无法整除的情况，将会产生无限小数，而存储小数的内存有限，将会在有效限制位进行四舍五入，最终导致无法精确存储小数；
                2.对于float类型，最多可以存储6~7位有效数字，对于double可以存储15位有效数字；
                3：如果需要精确处理小数问题，则可以选择使用BigDecimal类；
            3：浮点数字面量：
                1：字面量表示形式：
                    1：十进制形式：如：12.3；
                    2：科学计数法形式：0.123E2；
                2：java中浮点数的字面量默认为double类型；如果强制使用float类型，可以在直接量后面带上f或者F后缀；
            4：java中的其他浮点数：
                1：java中提供了三个特殊的浮点数：正无穷大、负无穷大、非数；用于表示溢出或者出错；
                2：正浮点数除以0得到正无穷大(POSITIVED_INFINITY)，负浮点数除以0得到负无穷大(NEGATIVE_INFINITY)，0.0除以0.0、对负数开方或者该直接量不是数字将得到非数(NAN)；
                3：所有的正无穷都是相等的，所有的负无穷都是相等的，NAN和任何数都不相等，包括和自己都不相等；
                4：特别注意：只有正负浮点数除以0才会得到无穷大的数；整数除以0将会报除数非0异常；
            5：浮点数类型转换：
                1：浮点数类型之间进行转换：
                    folat->double；
                    注意：只允许将float类型的数据转换为double类型的数据，不允许将double类型的数据转换为float类型的数据；
                2：浮点数与其他类型进行转换：
                    1：浮点数转换为字符串：
                        方式1：String s = "" + 浮点数；
                            示例如下:
                                String s = "" + 23.233;

                        方式3：String s = String.valueOf(floatNum)；
                            示例如下：
                                long num = 9999.99999;
                                String s = String.valueOf(num);

                        方式2：String s = Float.toString(float num)；
                               String s = Double.toString(float num)；
                            示例如下：
                                String s = Float.toString(12.33)；
                                String s = Double.toString(12.33)；
                    2：浮点数转整数：浮点数不能直接转为整数，但是可以借助Math类来对浮点数取整；
                    
                    3：浮点数转布尔值：浮点数不能和布尔值互转；
       
        3：布尔型：
            1：布尔型用boolean表示，其值只有true和false，表示真和假,boolean只占用1个字节(但是实际上单个boolean变量在jvm中的具体实现是使用int类型来存储的)；
            2：特别注意：布尔值，只能是true或者false，不能使用0、空值、NAN代表false，不能使用非0值或者非空值代表true，java条件表达式中不会将其他类型的数据自动转换为布尔值;
            3：关于类型转换：不能在boolean和其他基本数据类型间进行转换；

        4：字符型：
            1：java中使用char类型表示一个字符，char占用2个字节，使用Unicode字符集，使用16位的存储空间来存放字符在Unicode字符集中的编码；
            2：字符字面量：
                1：普通字符：'a'、'+'等，由''包裹的单个可打印字符称之为普通字符；
                2：转义字符：'\r','\n','\t','\v','\\','\'','\"','\b'等，称之为转义字符，表示特殊含义；
                3：unicode字符：'\u0000'、'\u00ff'等，直接由Unicode值来表示某个字符；前256个字符('\u0000'~'\u00FF')和ASCII码完全相同；
            3：字符本质：
                1：程序保存字符时，实际上是存储字符在字符集中的码点在编码之后的编码值，java使Unicode字符集，因此码点都是unicode字符集中字符对应的码点，其值范围是0~65535；通常情况下使用utf-8编码格式对码点编码;
                2：因此在创建字符类型数据时，即可以直接赋值一个字符直接量，也可以赋值一个大小在0~65535之间的整数，系统会自动将该整数作为字符集中的码点；
                3：java中没有字符串类型的基本数据类型，而是由Sring、StringBuffer、StringBuilder类来间接的实现，因此特别注意单字符的字符串和字符不同，如："a"和'a'并不相同；
    3.包装类型：
        1：基本数据类型是独立的数据类型，不能像引用类型一样有继承关系，在面向对象中不能支持多态；为了基本类型的数据能够适配面向对象体系，java为每一种基本类型都提供了对应的包装类，可以将基本类型转换为引用类型；
        2：java中针对8中基本数据类型分别提供了8中包装类，用来将基本类型转换为引用类型，分别如下：
            基本类型名称        包装类型名称
            byte         ->    Byte
            short        ->    Short
            int          ->    Integer
            long         ->    Long
            char         ->    Character
            float        ->    Float
            double       ->    Double
            boolean      ->    Boolean
            
        3：关于装箱和拆箱：
            1：将基本数据类型转换为引用类型数据，称之为装箱，装箱的本质在于创建一个包装类的对象，并将基本类型数据值赋值给包装类对象的属性；
            2：将引用类型数据转换为基本类型数据，称之为拆箱，拆箱的本质在于将包装类型对象的属性值赋值给当前基本类型的变量；
            3：手动装箱和拆箱：
                对于JDK1.5之前，必须手动进行装箱和拆箱，其方式如下：
                    装箱：new 包装类(基本数据类型数据)
                        说明：
                            1：包装类即为上述包装类型；
                            2：装箱之后将得到引用类型的数据；
                    拆箱：包装类型数据.xxxValue()
                        说明：
                            1：xxxValue，指不同数据类型，如：intValue()、floatValue()
                            2：拆箱之后将得到基本类型的数据；

                对于JDK1.5及其之后的版本，无需手动装箱和拆箱，系统自动进行装箱拆箱操作：
                    1：装箱：可以将基本类型数据 直接赋值 给对应的包装类型变量；
                    2：拆箱：可以将包装类型数据 直接赋值 给对应的基本类型变量；
                    3：包装类型的数据可以直接和基本类型的数据一起参与运算；

        4：关于包装类型的继承结构：
            Object:
                |--Boolean
                |--Character
                |--Number:
                    |--Byte
                    |--Short
                    |--Integer
                    |--Long
                    |--Float
                    |--Double

        5：关于装箱和拆箱的细节问题：
            1：对于自动装箱和自动拆箱类型必须相想对应，不能在不同的类型之间装箱和拆箱；

            2：装箱本质上是创建对象并将基本类型值赋值给对象属性的过程，为了能够提高装箱效率，jvm在启动时会提前创建一部分基本类型数据对应的包装类对象，并将数据值赋值给对应的包装类对象，在装箱时如果发现该数据对应的包装类对象已经存在，将不会再执行创建对象的过程，而是直接返回对应的包装类对象引用；具体情况如下：
                1：对于Short、Interger、Long：
                    系统会提前创建好[-128,127]之间的包装类对象；
                2：对于Character：
                    系统会提前创建好[0,128]之间的包装类对象；
                3：对于Boolean：
                    系统会提前创建好true和false对应的包装类对象；
                4：对于Float、Double：
                    由于float和double代表小数，两个整数之间有无数个小数，因此无法提前创建Float和Double类型的引用变量，对于float和double类型的数据装箱时，都是执行一次完整的创建包装类对象的过程；

            3：由于jvm对于装箱的优化机制，实际装箱时如果数据在缓存数据的范围内，将会直接返回对应包装类的引用，同一个数据无论装箱多少次，都返回的是同一个包装类对象；但是不在缓存数据范围内的数据装箱时，会每次都执行装箱操作,同一个数据也将返回不同的对象；如：
                //23在缓存数据范围内，因此多次装箱返回的依旧是同一个对象；
                Interger a = 23;
                Interger b = 23;
                a==b;    //true;
                //999并不在缓存数据范围内，因此每次装箱都会创建新的对象
                Integer c = 999;
                Integer d = 999;
                c==d;  //false;

            4：对于包装类型和基本类型的数字同时参与+、-、*、/运算时，会自动先将包装类型进行拆箱，转换为基本类型数据，然后进行+、-、*、/运算；

            5：对于包装类型的数据拆箱时，会调用包装类的xxxValue()方法返回该包装类对象的value属性；因此无论是自动拆箱还是手动拆箱，都要注意当前包装类型的变量是否为null；否则将会报空指针异常；        
        
运算：基本运算+Math+BigDecimal:
    基本运算：
        1：算数运算：
            运算类型：
                +、-、*、/、%、++、--
            运算符说明：
                +：可用于数字之间的加法运算以及连接字符串；
                -：只能用于数字之间的减法运算；
                *：只能用于数字之间的乘法运算；
                /：只能用于数字之间的除法运算；
                    且两数都是整数时，运算结果也将是整数；
                    如果两数有一个是小数，那么运算结果也是小数；
                    如果被除数是整数，除数不可以为0，否则将报除0异常；
                    如果被除数是浮点数，除数是0，将得到正负无穷大；
                %：只能对数字进行求余运算;
                    如果两数都是整数，则余数为整数;
                    如果有一数为浮点数，余数都将为浮点数；
                    如果被除数是整数，除数不可以为0，否则将报除0异常；
                    如果被除数是浮点数，除数是0，将得到正负无穷大；
                ++：自增运算；
                    只能对char、byte、short、int、long、float、double进行自增；
                    自增与赋值运算同时使用时需要注意优先级；
                --：自减运算；
                    只能对char、byte、short、int、long、float、double进行自减；
                    自减运算与赋值运算同时使用时需要注意优先级；
        2：比较运算：
            运算类型：
                >、>=、<、<=、==、!=
            运算符说明：
                >、>=、<、<=仅支持比较双方均是数值类型，比较结果返回boolean值；
                ==：1：适用于基本数据类型以及引用数据类型；
                    2：如果比较双方是基本数据类型，不管其类型如何，只要数值相等，即认为相等；如：5.0==5：true
                    3：如果比较双方是引用类型，要求双方必须是同一个类或具有相同父类的类的实例对象才能比较，且两个引用指向同一个对象时才认为相等；
                    4：基本数据类型不能和引用数据类型比较；
                    5：boolean类型不能和其他类型的数据比较；
                !=：1：适用于基本数据类型以及引用数据类型；
                    2：如果比较双方是基本数据类型，不管其类型如何，只要数值不相等，即认为不相等；如：5.1!=5：true
                    3：如果比较双方是引用类型，要求双方必须是同一个类或具有相同父类的类的实例对象才能比较，两个引用指向的不是同一个对像才认为不相等；
                    4：基本数据类型不能和引用数据类型比较；
                    5：boolean类型不能和其他类型的数据比较；
        3：逻辑运算：
            运算类型：
                &&、&、||、|、!、^
            运算符说明：
                &&：两个操作数都必须是true时才返回true，并且&&会先判断左边操作数是否为false，如果左边已经是false，则不会计算右边是否为false，直接返回false；&&两侧操作数必须是boolean类型；
                &：两个操作数都必须是true时才返回true，&会分别判断两边的操作数是否为false，即便左边操作数已经是false，仍然会判断右边是否是true；&两侧操作数必须是boolean类型
                ||：只要两个操作数其中之一是true就返回true，||优先判断左侧是否为true，只要左侧为true立即返回true,不会再去判断右侧如何；||两侧必须是boolean类型；
                |：只要两个操作数其中之一是true就返回true，|会依次完整的检测两侧数据是否为true；|两侧必须是boolean类型；
                !：非运算，!运算数必须是boolean类型；
                ^：异或运算，两个操作数不同返回true，相同则返回false；
        4：赋值运算：
            运算类型：=、+=、-=、*=、/=、%=、&=、|=、^=、<<=、>>=
            运算符说明：
                =：将右侧的值赋值给左侧变量；
                +=、-=、*=、/=、%=、&=、|=、^=、<<=、>>=：先将左侧变量和由此数据进行算数运算，然后将运算结果赋值给左侧变量；
        5：位运算：
            运算类型：
                &、|、~、^、<<、>>、>>>
            运算符说明：
                &：按位与运算，只能操作整数类型的变量或值；
                |：按位或运算，只能操作整数类型的变量或值；
                ~：按位非运算，单目运算符，将操作数的每一个二进制位进行取反；
                ^：按位异或运算，只能操作整数类型的变量或值；
                <<：左移运算，只能操作整数类型的变量或值，正数左移一位相当于*2；二进制位左移，右侧补0；
                >>：右移运算，只能操作整数类型的变量或值，正数右移一位相当于/2；二进制位右移，左侧按照符号补位，负数补1，正数补0；
                >>>：无符号右移，将操作数的二进制位右移之后，左边空出来的位置总是补0；
                关于移位运算的说明：
                    1：对低于int的类型总是先转换成int类型然后进行移位运算；
                    2：如果a>>b，b>32时，系统会先用b对32求余；，得到的余数才是真正移位的位数；因此：a>>33和a>>1相同；
                    3：移位运算不会修改操作数本身，而是的到一个新的结果并返回；
        6：符号运算符：
            运算类型：.、()、[]、{}     
            运算符说明：
                .：表示对象或者类调用成员属性或者成员方法
                ()：表示有限运算()中的表达式
                []：表示数组的声明，或者数组中指定位置的值
                {}：表示语句块；
                特别注意：符号的运算优先级高于数值运算
    Math类的使用：除了基本运算符以外，java还提供了Math类来辅助运算；
        1：Math类说明：
            1：Math类在java.lang包下，无需引入，可以直接使用；
            2：Math类本身由final修饰，不允许被继承，保证其中的处理方法完整安全；
            3：Math类中的方法均是静态方法，通过Math类来调用；
        2：Math类中的属性及方法：
            1：属性：
                1：圆周率：Math.PI
                2：e：Math.E
            2：方法：
                1：绝对值：
                    Math.abs() /* 支持整数、浮点数*/
                2：取整：
                    1：向上取整：Math.ceil(double num)
                    2：向下取整：Math.floor(double num)
                    3：返回离浮点数最近的整数，如果两边相同则返回偶数：Math.rint(double num)
                    4：四舍五入：Math.round(double num)
                3：最值：
                    1：返回最大值：Math.max(double a, double b) /*支持整数、浮点数*/
                    2：返回最小值：Math.min(double a,double b)  /*支持整数、浮点数*/
                4：开跟：
                    1：开平方：Math.sqrt(int x)
                    2：开立方：Math.cbrt(int x)
                    3：求sqrt(x*x+y*y)：Math.hypot(int x, int y)
                5：幂：
                    1：求e^x的值：exp(int x)
                    2：求x^y的值：pow(int x, int y)
                6：角度弧度互转：
                    1：角度转弧度：Math.toRadians()
                    2：弧度转角度：Math.toDegress()
                7：创建随机数：java.long.Math.Random
                    方式1：通过java.util.Random类来创建随机数：
                        1：引入Random类：
                            import util.Random
                        2：指定随机数种子：
                            Random r = new Random()   //使用默认的随机数种子
                            Random.r = new Random(long seed)   //使用指定的long型值作为本次生成随机数的种子；
                        3：生成随机数：
                                /*生成一个随机boolean值*/
                                    boolean nextBoolean()；
                                /*生成一个随机double值*/
                                    double nextDouble()；
                                /*生成一个随机float值*/
                                    float nextFloat()：
                                /*生成一个随机int值*/
                                    int nextInt()；
                                /*生成一个[0,bound）范围内的int随机值*/
                                    int nextInt(int bound)；
                                /*生成一个随机long值*/
                                    long nextLong()；
                                /*设置随机数种子*/
                                    setSeed(long seed)
                        4：随机数特征：
                            1：该类生成的伪随机数，即有规则的进行随机，随机数在区间内均匀分布,且其默认种子是当前时间：System.currentTimeMillis()；
                            2：两个种子数相同的Random对象在相同的次数下生成的随机数都是相同的；
                            3：Random类中生成随机数的方法是线程安全的，但其创建新种子时会使用compareAndSet，在多线程竞争下，可能发生自旋，最终导致其性能不佳；如果必须使用Random在多线程中创建随机数，推荐在每个线程中私有化一个Random对象；
                    方式2：Math.random()
                        1：Math.Random实质上也是通过java.util.Random类来生成随机数的，其默认是生成在[0.0~1.0)之间的随机数；
                        2：如需生成指定范围内的随机数,可按照以下公式进行：Math.floor(Math.random()*(max-min+1)+min);
                        3：同样，该方法线程安全，且生成的是伪随机数；
                    方式3：ThreadLocalRandom：
                        1：JDK1.7之后，提供了ThreadLocalRandom类用来在并发场景下生成随机数；
                        2：该类获取随机数的方法和java.util.Random类相同；但是该类在不同的线程中维护了各自的种子，无需CAS，性能较高；
                        3：该类创建对象的方式：ThreadLocalRandom.current();特别注意，不要将ThreadLocalRandom实例对象作为共享变量使用，否则将导致多个线程使用相同的种子；
                        
                
            


            

            
                


                






    

    


    
