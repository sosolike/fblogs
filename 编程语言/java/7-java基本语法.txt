注释：
    1：java中的注释：
        1：注释类型：单行注释、多行注释、文档注释；
        2：注释功能：单行注释和多行注释用来对代码解释说明，
                   文档注释用来对当前文件中的类、接口、方法等进行解释说明；
    2：单行注释：// 代码说明
        例如：int a = 0;    // a的注释

    3：多行注释：
        /*
         * 代码说明
         * 代码说明
         */
        例如：
           /*
            * 学生姓名
            */
            String studentName = "";

    3：文档注释：
        1：文档注释语法：
            /**
            * 文档注释，对类、接口、方法进行说明
            */
        2：文档注释位置：
            文档注释必须在类、接口、方法前面，表示对类、接口、方法的说明，不能出现在其他位置，否则视为无效；
        3：文档注释的作用：
            文档注释时是对类、接口、方法的说明，可以通过javadoc工具将文档注释生成为html网页文件，可以通过文档注释文件来了解一个类；
        4：文档注释的组成：
            1：文档注释一般由两部分组成：
                第一部分：描述，对类、接口、方法的简要描述；
                第二部分：文档标记，以@作为前缀，对类、接口、方法的基本属性进行说明；
            2：文档标记：
                1：文档标记通常有两种：@tag类型的和{@tag}类型的，区别如下：
                    1：@tag类型的称之为块标记，一般放在文档注释的描述后面，作为标签独立描述某个特征；
                    2：{@tag}类型的称之为内联标签，一般放在主要描述中，在生成文档注释文件时会标记出该标签，也可以放在块标签的注释中；
                2：文档标记以@作为前缀，常用的由以下几种：
                    @author    ：作者
                        1：表示创建该类、接口、方法的作者，一般用在类、接口的文档注释中；
                        2：语法形式：@author 作者名称
                    @version   ：版本号
                        1：表示类、接口、方法的版本，一般用在类、接口的文档注释中；
                        2：语法形式：@version 版本号；
                    @param     ：方法形参
                        1：表示方法的形参，一般用在方法的文档注释中；
                        2：语法形式：@param 参数名 参数描述
                    @return    ：方法返回值
                        1：表示方法的返回值，一般用在方法的文档注释中；
                        2：语法形式：@return 返回值描述
                    @throws/@exception    ：可能抛出的异常
                        1：表示该方法有可能抛出的异常；
                        2：语法形式：@throws 异常类型 异常描述|@exception 异常类型 异常描述
                    @deprecated：过期的方法(注解)
                        1：表示该方法已经过期，，不再推荐使用该方法；
                        2：语法形式：直接在方法前面使用@deprecated 过期原因 即可；
                    @since     ：从当前版本以后
                        1：表示从当前项目版本之后才有的方法：
                        2：语法形式：@since 当前项目版本或者当前时间
                    @see       ：另请参阅
                        1：多用在类上，标记与该类相关联的类；也可以用在方法上；
                        2：语法形式：@see  其他类、方法
                    @code      当前类或者当前方法
                        1：使用{@code 类名/方法名}可以在文档中标记该类名、方法名；
                        2：使用语法形式：{@code 类名/方法名}
                    {@inheritDoc} ：继承父类中的文档注释
                        1：表示当前陈继承的类、重写的方法继续使用父类的文档注释；
                        2：使用语法形式：直接在类、方法前使用@inheritDoc注解即可；
                3：关于文档注释标记使用的注意事项：
                    1：javadoc标记必须从一行的头开始，不能续在另一行的尾部；
                    2：javadoc标记严格区分大小写，使用时需要保证javadoc标记的正确性，否则将不能识别；
                    3：推荐将同种类型的标记放在一起；
                    4：不同场景下常用的标记：
                        类、接口常用的标记：@author、@version
                        方法常用的标记：@param、@return、@exception/@throws、@since

        5：生成文档注释：
            1：使用javadoc命令生成文档注释：javadoc [options] [packagenames] [sourcefiles]
                其中：options：表示javadoc命令的选项
                     packagenames：表示包名
                     sourcefiles：表示源文件名
            2：参数如下：
                -public	    仅显示 public 类和成员
                -protected	显示 protected/public 类和成员（默认值）
                -package	显示 package/protected/public 类和成员
                -private	显示所有类和成员
                -d <directory>	输出文件的目标目录
                -version	包含 @version 段
                -author	包含 @author 段
                -splitindex	将索引分为每个字母对应一个文件
                -windowtitle <text>	文档的浏览器窗口标题

标识符、分隔符以及关键字：
    标识符：
        1：java中给包、类、接口、变量、方法等命名的字符串称之为标识符；
        2：标识符命名规则：
            1：标识符只能以数字(0-9)、字母(A-Za-z)、下划线(_)、美元符号($)组成；
            2：标识符不能以数字开头、不能和关键字以及保留字冲突、严格区分大小写；
            3：标识符在不同的场景下有不同的要求，具体如下：
                1：对于包名：推荐采用完整单词、全小写的方式命名，多个单词之间使用.分隔；
                2：对于类名、接口名：推荐采用完整单词且首字母大写的驼峰式命名法命名；
                3：对于变量、方法名：推荐采用完整单词的驼峰式命名法命名；
            4：标识符名称应该简洁明确，避免中英混合，避免不合理的缩写；
    分隔符：
        语句：
            1：java中一条语句以';'结尾；
            2：语句可以换行书写，但是尽量保持一行只写一条语句；标识符名称本身不能换行书写；
        代码块：
            1：java中代码块通过'{}'来表示；
    关键字：
        1：java中因为语法需要已经使用的标识符称之为关键字，比如class、interface、int等；自定义的标识符不能和关键字同名；
        2：与关键字类似的还有保留字，即java中暂时没有使用，但是将来可能使用的单词称之为保留字；自定义的标识符同样不能喝保留字同名；

基本数据类型：
    1：java中的数据类型分类：
        数据类型:
            |--引用类型
            |--基本类型：
                |--整数类型：
                    |--byte：1字节，8位，十进制范围在-128~127；
                    |--short：2字节，16位，十进制范围在-32768~32767；
                    |--int：4字节，32位，十进制范围在-2147483648~2147483647(2的-32次方~2的31次方)；
                    |--long：8字节，64位，十进制范围在2的-64次方~2的63次方；
                |--浮点数类型：
                    |--float：4字节，32位，6~7个有效位，单精度类型；
                    |--double：8字节，64位，15个有效位，双精度类型；
                |--字符类型：
                    |--char：2字节，16位，支持65536个字符；
                |--布尔类型：
                    |--boolean：1字节，值只有true/false；
    2：基本数据类型说明：
        1：整数类型：
            1：java中的整数按照所占字节数多少分为byte、short、int、long，整数可以为正整数、0、负整数；
            2：java中的整数支持以二进制、八进制、十进制、十六进制表示；其中：
                1：不同进制数字组成：
                    1：二进制以0b或者0B作为前缀，由0和1组成；
                    2：八进制以0作为前缀，由0~7组成；
                    3：十进制无任何前缀，由0~9组成；
                    4：十六进制以0x或者0X作为前缀，由0~9和a~f(A~F)组成；
                2：不同进制之间类型转换：
                    java中进制转换必须以十进制为中间进制，可以将其他进制转换为十进制，然后再由十进制转换为其他进制；
                    1：十进制转其他进制：借助int类型的包装类Integer提供的方法进行转换：
                        十进制转二进制：Integer.toBinaryString(num)
                        十进制转八进制：Integer.toOctalString(num)
                        十进制转十六进制：Integer.toHexString(num)
                        十进制转r进制：Integer.toString(进制数,num)
                        注意：1：待转换值num必须是byte、short、int类型的十进制数字；long型不能通过上述方式进行转换；
                             2：转换的结果均是对应进制的字符串形式；
                    2：其他进制转10进制：
                        Integer.parseInt(String num,int radix)
                        注意：1：待转换值num必须是其他进制的字符串形式；
                             2：原始进制radix必须以int类型表示；
                             3：转换结果是int类型的整数；
            3：整数直接量：
                1：对于直接给出的数值，称之为直接量，整数数值称之为整数直接量，系统默认整数直接量都是int类型的；
                2：对于byte、short类型的变量赋值时有所不同：将一个大小在short、byte类型范围内的整数赋值给short、byte、类型的变量，系统只会为该整数分配short、byte对应的内存空间来存储该整数，即系统会将该整数直接量作为short、byte来对待；
                3：对于long型变量则又有不同：将一个大小在long型范围的整数，赋值给long型的变量，系统并不会将该整数作为long型来对待,而是作为int类型来对待，此时将会报错：int类型的数字过大；为了能将大小在long范围内的数字作为long型来使用，必须在数字后面加上l或者L作为后缀；
            4：整数类型转换：
                1：整数类型内部之间转换：在参与运算或者赋值时系统会自动进行整数间类型转换，转换方向如下：
                    byte->short(char)->int->long->float->double;
                    注意：转换只能按照上述方向从低精度至高精度转换，不允许从高精度向低精度转换，否则将会报错；
                2：整数与其他数据类型间的转换：
                    1：将整数转换为String类型：
                        方式1：String s = "" + 整数；
                            注意：整数可以为任意类型的整数，
                            示例如下:
                                String s = "" + 23;

                        方式3：String s = String.valueOf(num)；
                            注意：待转换值num可以为任意整数类型；
                            示例如下：
                                long num = 999999999;
                                String s = String.valueOf(num);

                        方式2：String s = Integer.toString(int num)；
                            注意：整数只能为int、short、byte类型的整数,
                            示例如下：
                                String s = Integer.toString(int num)；
                    2：将整数转换为boolean值：java中boolean仅占一个字节，不允许在整形和布尔值之间互相转换；
                    3：整数转浮点数：由于浮点数精度比整数高，因此可以直接将整数转为浮点数；
                3：使用整数类型时需要特别注意整数取值范围，尤其存储运算结果时；
        2：浮点数类型：
            1：浮点数类型用来存储小数，包括低精度的folat类型和高精度的double类型；float类型精度只有6~7位，double类型精度有15位；精度越高，小数部位越精确；
            2：浮点数精度：
                1：java中的浮点数同样存在无法精确存储小数的问题，由于小数在内存中以2进制存储，而十进制转2进制时如果遇到无法整除的情况，将会产生无限小数，而存储小数的内存有限，将会在限制位进行四舍五入，最终导致无法精确存储小数的问题；
                2：对于float类型，最多可以存储6~7位有效数字，对于double可以存储15位有效数字；
                3：如果需要精确处理小数问题，则可以选择使用BigDecimal类；
            3：浮点数直接量：
                1：直接量种表示形式：
                    1：十进制形式：如：12.3；
                    2：科学计数法形式：0.123E2；
                2：java中浮点数的直接量默认为double类型；如果强制使用float类型，可以在直接量后面带上f或者F后缀；
            4：java中的其他浮点数：
                1：java中提供了三个特殊的浮点数：正无穷大、负无穷大、非数；用于表示溢出或者出错；
                2：正浮点数除以0得到正无穷大(POSITIVED_INFINITY)，负浮点数除以0得到负无穷大(NEGATIVE_INFINITY)，0.0除以0.0或者对负数开放或者该直接量不是数字将得到非数(NAN)；
                3：所有的正无穷都是相等的，所有的负无穷都是相等的，NAN和任何数都不相等；
                4：特别注意：只有正负浮点数除以0才会得到无穷大的数；否则将会抛出异常；
            5：浮点数类型转换：
                1：浮点数类型之间进行转换：
                    folat->double；
                    注意：只允许将float类型的数据转换为double类型的数据，不允许将double类型的数据转换为float类型的数据；
                2：浮点数与其他类型进行转换：
                    1：浮点数转换为字符串：
                        方式1：String s = "" + 浮点数；
                            示例如下:
                                String s = "" + 23.233;

                        方式3：String s = String.valueOf(floatNum)；
                            示例如下：
                                long num = 9999.99999;
                                String s = String.valueOf(num);

                        方式2：String s = Integer.toString(float num)；
                            示例如下：
                                String s = Integer.toString(12.33)；
                    2：浮点数转整数：浮点数不能直接转为整数，但是可以借助Math类来对浮点数取整；
                    3：浮点数转布尔值：浮点数不能和布尔值互转；
       
        3：布尔型：
            1：布尔型用boolean表示，其值只有true和false，表示真和假；
            2：特别注意：布尔值，只能是true或者false，不能使用0或者空值代表false。不能使用非0值或者非空值代表true;
            3：关于类型转换：不能在boolean和其他基本数据类型间进行转换；

        4：字符型：
            1：java中使用字符型(char)表示一个字符符号，char占用2个字节，使用Unicode字符集，并使用16位的存储空间来存放字符在Unicode字符集中的编码；
            2：字符直接量：
                1：普通字符：'a'、'+'等，由''包裹的单个可打印字符称之为普通字符；
                2：转义字符：'\r','\n','\t','\v','\\','\'','\"','\b'等，称之为转义字符，表示特殊含义；
                3：unicode字符：'\u0000'、'\u00ff'等，直接由Unicode值来表示某个字符；前256个字符('\u0000'~'\u00FF')和ASCII码完全相同；
            3：字符本质：
                1：程序保存字符时，实际上是存储字符在字符集中的编码值，java使Unicode字符集，因此保存的都是字符在Unicode字符集中的编码值，其值范围是0~65535;
                2：因此在创建字符类型数据时，即可以直接赋值一个字符直接量，也可以赋值一个大小在0~65535之间的整数，系统会自动将该整数作为字符集中的字符编码；
                3：java中没有字符串类型的基本数据类型，而是由Sring类来间接的实现，因此特别注意单字符的字符串和字符不同，如："a"和'a'并不相同；
        5：字符串： 
            1：java基本数据类型中没有字符串类型，但是使用""包裹的字符序列表示一个字符串直接量；而使用以下三个类来创建字符串类型：分别是：String、StringBuffer、StringBuilder，三个创建字符串的类中都是通过字符数组来间接实现字符串的；
            2：字符串直接量：
                1：使用""包裹的字符序列 称之为字符串直接量，如："abcd"这种形式；
                2：注意：字符串直接量必须使用""包裹，字符直接量必须使用''包裹；
                3：为了能够操作字符串，字符串直接量必须先创建
            3：通过String创建字符串类型：
                1：String类特点：
                    1：String类继承自CharSequence接口，通过一个字符数组来实现字符串，并实现了对字符串操作的各个方法；
                    2：String类的实现上有以下特征：
                        1：String类本身由final修饰符修饰，不可被继承；
                        2：String类中的所有成员属性权限均是private，不可直接被外部访问；并且除过表示字符串hash值以外的属性均由final修饰，一旦赋值将不允许再修改；
                        3：String类仅提供了成员属性的getter方法，并未提供任何setter方法；
                        综上：String类是一个不可变类；
                2：String类实例对象特征：
                    1：因为String类是一个不可变类，其实例对象是一个不可变对象，String对象一旦创建将不能再修改，即String类型的字符串一旦创建，字符串中的字符将不允许再修改、增删；
                    2：存储字符串值的字符数组被final修饰，是常量，其引用不能变，因此String类型的字符串进行修改、增删，本质上都是重新复制了原字符串的值，并在复制的新值上进行修改，并返回一个新的String实例对象，而原String实例对象因为失去引用，将会被GC回收；
                3：创建String类型的实例对象：
                    java中提供了多个不同的构造方法，允许通过多种不同的方式创建String类型的实例对象；
                    1：构造方法：public String()：
                        说明：1：创建一个空的String对象；
                       创建实例对象：
                        String emptyString = new String();
                            
                    2：构造方法：public String(@NotNull() String original)
                        说明：1：通过字符串直接量创建String实例对象；
                       创建实例对象：通过字符串直接量创建String实例对象有两种方式，示例如下：
                        String a = "abc";   //直接将字符串直接量赋值给String类型变量；
                        String b = new String("abc");   //通过字符串直接量创建实例对象；
                        两种方式的异同点：
                            1：两种方式都将创建一个值为"abc"的String引用，但JVM处理方式并不相同;
                            2：将字符串直接量赋值给String类型的变量：
                                JVM会首先会根据字符串hash值在字符串常量池中查找是否有hash值相等的字符串常量，如果有，会将该字符串常量的引用返回，如果没有，JVM将会在堆区创建一个新的String对象，并将该引用添加至字符串常量池中，同时将该字符串引用返回；
                            3：通过构造方法创建String类型对象：
                                JVM并不会在字符串常量池中检查是否有相同的字符串(hash值相等)，而是立即在堆区创建String对象，并将该对象的引用返回，并且不会将该字符串引用添加至字符串常量池中(除非使用该String对象显式调用intern()方法)；
                            4：特别注意：字符串常量池时java为了提高字符串创建性能而提供的缓存字符串常量的机制，位置在JVM的方法区；而通过String类构造方法创建的对象则在JVM的堆区；一般情况下推荐使用直接将字符串常量赋值给String类型变量的方式；
                    3：构造方法：public String(@NotNull char value[])
                        说明：1：通过一个字符数组来创建String对象；
                             2：为了保证创建的字符串对象不被修改，此种方式并不会直接将字符数组的引用赋值给String的value属性，而是将字符数组通过Arrays.copyOf()复制了一份给value;
                      创建实例对象：String s = new String(['a','b','c'])
                      与此类似的构造方法还有以下几个：
                        public String(char value[],int offset,int count)
                            说明：通过一个字符数组的一部分来创建String对象；
                        public String(int[] codePoints,int offset,int count)
                            说明：通过int数组的一部分作为Unicode字符编码值来创建String对象；
                    4：构造方法：public String(StringBuilder builder)
                        说明：1：通过StringBuilder创建String对象；
                             2：由于StringBuilder是可变字符串对象，为了保证String对象不可变，并未将builder的value的引用直接赋值给String对象的value；而是复制builder的value值给String实例对象的value；
                    5：构造方法：public String(StringBuffer buffer)
                        说明：1：通过StringBuffer创建String对象；
                             2：由于StringBuffer是可变字符串对象，为了保证String对象不可变，并未将buffer的value的引用直接赋值给String对象的value；而是复制buffer的value值给String实例对象的value；
                    6：构造方法：public String(byte bytes[])
                        说明：通过字节数组创建字符串，字节数组中的数值将作为当前平台默认字符编码的码值来创建实例对象；
                        与此类似的构造方法还有以下几个(不常用)：
                        /*按照平台默认字符集，将bytes数组指定区间的数据解码成字符串*/
                        public String(byte bytes[], int offset, int length)
                        /*按照指定字符集，将bytes数组解码成字符串*/
                        public String(byte bytes[], Charset charset)
                        /*按照指定字符集，将bytes数组解码成字符串*/
                        public String(byte bytes[], String charsetName)
                        /*按照指定字符集，将bytes数组指定区间数据解码成字符串*/
                        public String(byte bytes[], int offset, int length, String charsetName)
                    上述构造方法中应特别留意前5种常用功能的构造方法；
                4：String提供的操作String类型字符串的方法：String string = "testString";
                    1：获取长度：
                        string.length();
                    2：检测是否为空：
                        string.isEmpty();
                    3：获取指定位置的字符：
                        string.charAt(int index);
                    4：返回指定字符首次出现的位置：
                        string.indexOf(int ch);
                        string.indexOf(int ch,int fromIndex)
                    5：返回子串首次出现的位置：
                        string.indexOf(String str);
                        string.indexOf(String str,int fromIndex)
                    6：反向查找字符首次出现的位置：
                        string.lastIndexOf(int ch);
                        string.lastIndexOf(int ch, fromIndex);
                    7：反向查找字符首次出现的位置：
                        string.lastIndexOf(String str);
                        string.lastIndexOf(String str, fromIndex);
                    8：截取字符串：
                        string.substring(int beginIndex);  /*从起始位置beginIndex截取至字符串结尾*/
                        string.substring(int beginIndex, int endIndex); /*从beginIndex截取至endIndex*/
                    9：连接两个字符串：
                        方式1：string.concat(String str)：
                            实现原理：系统会先拷贝string的value，至新的字符数组中，然后将str的value追加至字符数组中；
                        方式2：string+str：
                            实现原理：先将string和str转换为StringBuilder，然后调用StringBuilder的append方法将str追加至string中，将追加完成的字符串作为参数，重新创建一个String对象返回，性能较差，不推荐使用；
                        方式3：将string和str手动转换为StringBuilder，调用StringBuilder的append方法将str追加至string结尾，最后手动调用StringBuilder的toString()方法转换为string类型；从操作方式上来看方式3和方式2并无区别，但是对同一个字符串进行大批量的追加操作时，需要来回进行类型转换，并且导致大量的String对象失效，此时推荐使用方式3来连接两个字符串；
                    10：替换字符串中的字符：
                        string.replace(char oldChar,char newChar)；实现上效率较差，如果有需要推荐使用StringBuilder实现；
                    11：转换大小写：
                        string.toUpperCase()
                        string.toLowerCase()
                    12：获取字符数组：
                        string.toCharArray()
                    13：清理字符串两侧空格：
                        string.trim()
                    14：将其他基本数据类型转换为字符串：
                        String.valueOf();
                    15：合并String、StringBuufer、StringBuilder为字符串：
                        String.join(CharSequence delimiter,Iterable<? extends CharSequence> elements)
                        String.join(CharSequence delimiter, CharSequence... elements)
                    16：分隔字符串为子字符串：
                        string.split(String regex)
                        string.split(String regex,int limit)
                    17：检测两个字符串对象是否相等：
                        string.equals(Object anObject);     
                        说明：1：anObject必须是String类型的对象；
                             2：在比较两个字符串是否想等时，只比较两个字符串序列是否相同，相同即返回true，否则返回false,等价于运算符号：=;
                             3：如果在String和StringBuffer、StringBuilder检测是否相等时使用：
                                string.contentEquals(charSequence cs)
                             4：此种确定是否相等时会严格区分大小写，避免区分大小写可以使用：
                                string.equalsIgnoreCase(String anotherString)
                    18：比较两个字符串大小(字符序列在字符集中的码值大小)：
                        string.compareTo(String anotherString)
                        说明：1：如果当前字符串较大，返回大于0的数，相等返回0，小于返回负数；
                             2：此种比较方式会严格区分大小写比较，如果需要忽略大小写比较可以使用：
                                string.compareToIgnoreCase()
                    19：检测字符串是否以指定子串开头：
                        string.startsWith(String prefix)
                        string.startsWith(String prefix, int offset)
                    20：检测字符串是否以指定子串结尾：
                        string.endsWith(String suffix)
                        string.endsWith(String suffix, int offset)
                    21：返回字符串的hash值：
                        string.hashCode()
                    22：获取组成字符串的字符组成数组：
                        string.getCharts(char dst[], int dstBegin);
                    23：获取字符串区间组成的字符数组：
                        strin.getchars(int srcBegin,int srcEnd,char dst[],int dstBegin);
                    24：获取指定位置的字符在Unicode字符集中的码值：
                        string.codePointAt(int index);
                    
            4：通过StringBuffer创建字符串：
                1：StringBuffe特点：
                    1：继承关系：
                        1：StringBuffer继承自AbstractStringBuilder、Serializeable接口、CharSequence接口；
                        2：而bstractStringBuilder则继承自CharSequence，Appendable接口；AbstractStringBuilder中定义了存放字符串字符的字符数组value，以及操作字符串的方法，StringBuffer中的众多方法也是直接调用AbstractStringBuilder中的方法；
                    2：StringBuffer实现上的特点：
                        1：为了保证对字符串操作的安全性，不允许对字符串操作的方法进行修改，StringBuffer类本身被final修饰，不可被继承；
                        2：StringBuffer中存放字符串的字符数组并未被final修饰，不是常量，其长度可以根据实际需要修改；
                        3：StringBuffer中对字符串操作的方法都是对字符串本身进行修改、增删，并返回当前实例对象本身；
                        4：StringBuffer中的方法都使用了Synchronized修饰，均是同步方法；可以保证字符串的线程安全；
                        5：StringBuffer是一个可变类，其对象是一个可变对象，该类设计的目的就在于方便对字符串进行编辑修改，并且该类中的方法都是线程安全的方法，可以安全的使用于多线程中；
                        6：StringBuffer是一个字符串缓存容器，和String类中字符数组的长度即为字符串字符数不同，StringBuffer中字符数组的长度会大于实际存储的字符串字符数，默认情况下StringBuffer中创建一个初始长度为当前字符串直接量长度+16的字符数组，也可以按照需要设置初始长度；
                        7：StringBuffer中可以通过length()方法获取字符串实际长度，通过capacity()获取当前字符数组的容量；当前字符串进行增加字符操作时会检测字符串长度是否超过当前字符数组容量，如果超过，将会进行扩容；扩容算法如下：
                            1：会先将容量增大至当前容量的两倍+2：即：newCapacity = 2*value.length +2;
                            2：检测扩容之后是否满足当前需要的容量(minCapacity)：即：newCapacity ?> minCapacity;
                            3：如果newCapacity<minCapacity，则将minCapacity赋值给newCapacity；
                            4：检测库容后的值是否合理，如果newCapacity<0 || newCapacity>MAX_ARRAY_SIZE，则重新设置扩容值：否则直接返回扩容后的值；
                            5：重新设置时会先检查minCapacity是否大于Integer.max_value，如果大于则直接报异常；否则继续：
                            6：检查minCapacity是否大于MAX_ARRAY_SIZE，如果大于直接返回minCapacity,否则返回MAX_ARRAY_SIZE；
                3：StringBuffer实例对象的特点：
                    1：由于StringBuffer并非不可变类，其对象则是可变对象，可以对StringBuffer类型的字符串本身进行修改；
                4：创建StringBuffer实例对象：
                    1：构造方法：public StringBuffer()
                        说明：创建一个容量为16，字符串为空的StringBuffer对象；
                        示例：StringBuffer strbuff = new StringBuffer();
                    2：构造方法：public StringBuffer(int capacity)
                        说明：创建一个容量为capacity大小，字符串为空的StringBuffer对象；
                        示例：StringBuffer strbuff = new StringBuffer(20);
                    3：构造方法：public StringBuffer(String str)
                        说明：使用字符串直接量创建一个容量为字符串直接量长度+16的StringBuffer对象；
                        示例：StringBuffer strbuff = new StringBuffer("testString")
                    4：构造方法：public StringBuffer(charSequence seq)
                        说明：使用其他CharSequence对象创建一个StringBuffer对象，容量为CharSequence长度+16；
                        示例：String testStr = new String("testString");
                                StringBuffer struff = new StringBuffer(testStr);
                5：StringBuffer对字符串操作的方法：
                    1：获取字符串长度：StringBuffer string = new StringBuffer("testString");
                        string.length()
                    2：获取字符串容量：
                        string.capacity()
                    3：获取指定位置的字符：
                        string.charAt(int index)
                    4：从字符串中截取指定区间的字符转为字符数组：
                        string.getCharts(int srcBegin, int srcEnd, char[] dst, int dstBegin)
                    5：修改指定位置的字符：
                        string.setCharAt(int index, char ch)
                    6：追加字符串：
                        string.append(Object obj)
                        string.append(String str)
                        string.append(StringBuffer sb)
                        string.append(AbstractStringBuilder asb)
                        string.append(CharSequence s)
                        append(CharSequence s, int start, int end)
                        string.append(char[] str)
                        string.append(char[] str, int offset, int len)
                        string.append(基本数据类型)
                    7：删除指定区间子串：
                        string.delete(int start, int end)
                    8：删除指定位置字符：
                        string.deleteCharAt(int index)
                    9：替换指定区间子串：
                        string.replace(int start, int end, String str)
                    10：截取子串：  
                        string.substring(int start)
                        string.substring(int start,int end)
                    11：向字符串中插入子串：
                        string.insert(int offset,String str)
                        string.insert(int offset,char[] str)
                        string.insert(int offset, 基本数据类型数据)
                    12：查找字符串首次出现的位置：
                        string.indexOf(String str)
                        string.indexOf(String str,int fromIndex)
                    13：反向查找字符串首次出现的未知：
                        string.lastIndexOf(String str)
                        string.lastIndexof(String str,int fromIndex)
                    14：反向字符串：
                        string.reverse();
                    15：转换为String类型的对象：
                        string.toString()
                        说明：StringBuffer对toString()方法做了优化，引入了成员属性toStringCache来存储首次调用toString()方法时所转换的String对象的字符数组，并且会在每此对字符串修改之后将该值清空；
                    16：序列化StringBuffer对象：
                        string.writeObject(java.io.ObjectOutputStream s)
                        string.ReadObject(java.io.ObjectOutputStream s)
                    
            5：通过StringBuilder创建字符串：
                StringBuilder和StringBuffer基本相同，唯一不同的在于StringBuilder中的方法不是线程安全的，而StringBuffer中的方法时线程安全的，除此之外，两个类的性质、用途、创建对象的方式、对字符串的操作方法均完全相同

流程控制：
    1：条件：
        第一种形式：if
            if(条件){
                /* do something... */
            }
        第二种形式：if...else
            if(条件){
                /* do something... */
            }else{
                /* do something... */
            }
        第三种形式：if...else if...else
            if(条件){
                /* do something... */
            }else if(条件){
                /* do something... */
            }else{
                /* do something... */
            }
        第四种形式：三目运算：
            流程规则：如果b>c这个条件成立，将b赋值给a，否则将c赋值给a；
            a = b>c ? b : c; 
        第五种形式：switch
            switch()
            {
                case a:
                    /* do something */
                    break;
                case b:
                    /* do something */
                    break;
                default:
                    /* do something */
            }
            注意：
                1：swith中的条件值可以是String类型的变量或者表达式、byte、short、int、char，不能是浮点数；
                2：多个条件的处理方式相同时可以共用处理逻辑，在最后处理完成之后再break即可；
                3：default分支不是必须要有的，根据实际情况选择是否需要default分支；
    2：循环：
        循环方式1：while
            while(条件){
                /* do something... */
            }
        循环方式2：do...while
            do{
                /* do something... */
            }while(条件);
        循环方式3：for：
            for(循环遍量初始值;继续循环条件;循环遍量修改表达式){/* do something... */}
        循环控制：
            1：break：立即结束当前循环，并跳出循环开始执行循环之后的代码；
            2：continue：终止本次循环，不再执行本次循环剩余的语句，并开始下一次循环；
运算：基本运算+Math+BigDecimal:
    基本运算：
        1：算数运算：
            运算类型：
                +、-、*、/、%、++、--
            运算符说明：
                +：
                    1.适用范围：用于数字之间的加法运算和字符串之间的连接；
                    2.注意事项：用于数字之间的加法运算时需要注意溢出；

                -：
                    1.适用范围：只能用于数字之间的减法运算；

                *：
                    1.适用范围：只能用于数字之间的乘法运算；

                /：
                    1.适用范围：只能用于数字之间的除法运算；
                    2.注意事项：
                        1.两数都是整数时，运算结果无论是否有小数，都会返回整数；
                        2.如果两数有一个是小数，那么运算结果也是小数；
                        3.如果被除数是整数，除数不可以为0，否则将报除0异常；
                        4.如果被除数是浮点数，除数是0，将得到正负无穷大；

                %：
                    1.适用范围：只能对数字进行求余运算;
                    2.注意事项：
                        1.如果两数都是整数，则取余结果一定是整数;
                        2.如果有一数为浮点数，则取余结果一定是浮点数；
                        3.如果被除数是整数，除数不可以为0，否则将报除0异常；
                        4.如果被除数是浮点数，除数是0，将得到正负无穷大；

                ++：
                    1.功能：自增运算；
                    2.注意事项：
                        1.只能对char、byte、short、int、long、float、double进行自增；
                        2.自增与赋值运算同时使用时需要注意优先级；
                        3.++自增运算不是原子类操作；

                --：
                    1.功能：自减运算；
                    2.注意事项：
                        只能对char、byte、short、int、long、float、double进行自减；
                        2.自减运算与赋值运算同时使用时需要注意优先级；
                        3.--自减运算不是原子类操作；
        2：比较运算：
            运算类型：
                >、>=、<、<=、==、!=、equals()

            运算符说明：
                1.>、>=、<、<=：仅支持比较双方均是数值类型，比较结果返回boolean值；

                2.==：
                    1.功能：适用于基本数据类型以及引用数据类型之间是否相等的比较；
                    2.注意事项：
                        1.如果比较双方是基本数据类型，不管其类型如何，只要数值相等，即认为相等；如：5.0==5：true
                        2.如果比较双方是引用类型，要求双方必须是同一个类的实例对象或具有相同父类的类的实例对象才能比较，且两个引用指向同一个对象时才认为相等；
                        3.如果参与比较的双方是引用类型，即便重写双方的equals方法，==比较仍然是按照第2条来进行的，不受equals影响；
                        4.基本数据类型不能和引用数据类型比较；
                        5.boolean类型不能和其他类型的数据比较；

                !=：1.适用于基本数据类型以及引用数据类型；
                    2.注意事项：
                        1.如果比较双方是基本数据类型，不管其类型如何，只要数值不相等，即认为不相等；如：5.1==5：false
                        2.如果比较双方是引用类型，要求双方必须是同一个类的实例对象或具有相同父类的类的实例对象才能比较，且两个引用指向的不是同一个对象时就认为不相等；
                        3.如果参与比较的双方是引用类型，即便重写双方的equals方法，==比较仍然是按照第2条来进行的，不受equals影响；
                        4.基本数据类型不能和引用数据类型比较；
                        5.boolean类型不能和其他类型的数据比较；
                equals():
                    1.equals是Object类的方法，用来实现当前对象和另一个对象的比较操作；
                    2.equals()默认是比较两个对象的引用地址是否相同，如果相同返回true；如果不同返回false；
                    3.每一个类中都可以重写equals()，实现自定义的比较方式，如果返回true表示当前对象和待比较对象相同，否则不同；
                    4.通常情况下，重写equals方法之后也要重写hashcode方法，保持equals和hashcode方法的协同；

        3：逻辑运算：
            运算类型：
                &&、&、||、|、!、^

            运算符说明：
                &&：
                    1.与操作，&&两侧操作数必须是boolean类型；
                    2.参与&&的两个操作数都必须是true时才返回true；
                    3.&&会先判断左边操作数是否为false，如果左边已经是false，则不会计算右边是否为false，直接返回false；
                &：
                    1.与操作，&两侧操作数必须是boolean类型；
                    2.两个操作数都必须是true时才返回true；
                    3.与&&不同的是，&会分别判断两边的操作数是否为truen，即便左边操作数已经是false，仍然会判断右边是否是true；

                ||：1.或操作，||两边操作数必须是boolean类型；
                    2.只要两个操作数其中之一是true就返回true；
                    3.||优先判断左侧是否为true，只要左侧为true立即返回true,不会再去判断右侧如何；

                |：
                    1.或操作，|两侧必须是boolean类型；
                    2.只要两个操作数其中之一是true就返回true；
                    3，与||不同的是，|会依次完整的检测两侧数据是否为true；

                !：
                    1.非运算，!运算数必须是boolean类型；
                    2.非运算时单目运算符；

                ^：
                    1.异或运算，^两边必须是boolean值；
                    2.两个操作数不同返回true，相同则返回false；

        4：赋值运算：
            运算类型：=、+=、-=、*=、/=、%=、&=、|=、^=、<<=、>>=
            运算符说明：
                =：
                    1.将右侧的值赋值给左侧变量；
                    2.直接使用=赋值的操做是一个原子操作；

                +=、-=、*=、/=、%=、&=、|=、^=、<<=、>>=：
                    1.先将左侧变量和此数据进行算数运算，然后将运算结果赋值给左侧变量；
                    2.运算赋值操作并非原子操作；

        5：位运算：
            运算类型：
                &、|、~、^、<<、>>、>>>

            运算符说明：
                &：将整数转换成二进制，并按位与运算；
                |：将整数转换为二进制，并按位或运算；
                ~：将整数转换为二进制，并按位非运算，该操作是单目运算符，本质上将操作数的每一个二进制位进行取反；
                ^：将整数转换为二进制，并按位异或运算；
                <<n：左移运算，将整数转换为二进制，并向左移动n位，符号位不变，右侧被移动位补0；正数左移一位相当于*2；
                >>n：右移运算，将整数转换为二进制，并向右移动n位，左侧被移动位按照正负不同有不同的补位方式：
                    1.正数移位一直补0；
                    2.负数移位一直补1；
                其中，正数右移一位相当于/2；
                >>>n：无符号右移，将整数转换为二进制位并向右移之n位，无论该整数的正负，左边空出来的位置总是补0；
                关于移位运算的说明：
                    1：对低于int的类型总是先转换成int类型然后进行移位运算；
                    2：如果a>>b，b>32时，系统会先用b对32求余；，得到的余数才是真正移位的位数；因此：a>>33和a>>1相同；
                    3：移位运算不会修改操作数本身，而是的到一个新的结果并返回；

        6：符号运算符：
            运算类型：.、()、[]、{}     
            运算符说明：
                .：表示对象或者类调用成员属性或者成员方法
                ()：表示有限运算()中的表达式
                []：表示数组的声明，或者数组中指定位置的值
                {}：表示语句块；
                特别注意：符号的运算优先级高于数值运算

    Math类的使用：除了基本运算符以外，java还提供了Math类来辅助运算；
        1：Math类说明：
            1：Math类在java.lang包下，无需引入，可以直接使用；
            2：Math类本身由final修饰，不允许被继承，保证其中的处理方法不会被修改；
            3：Math类中的方法均是静态方法，通过Math类来调用；
        2：Math类中的属性及方法：
            1：属性：
                1：圆周率：Math.PI
                2：指数：Math.E

            2：方法：
                1：绝对值：
                    Math.abs() /* 支持整数、浮点数*/

                2：取整：
                    1：向上取整：
                        Math.ceil(double num)
                    2：向下取整：
                        Math.floor(double num)
                    3：返回离浮点数最近的整数，如果两边相同则返回偶数：
                        Math.rint(double num)
                    4：四舍五入：
                        Math.round(double num)

                3：最值：
                    1：返回最大值：Math.max(double a, double b) /*支持整数、浮点数*/
                    2：返回最小值：Math.min(double a,double b)  /*支持整数、浮点数*/

                4：开跟：
                    1：开平方：Math.sqrt(int x)
                    2：开立方：Math.cbrt(int x)
                    3：求sqrt(x*x+y*y)：Math.hypot(int x, int y)

                5：幂：
                    1：求e^x的值：exp(int x)
                    2：求x^y的值：pow(int x, int y)

                6：角度弧度互转：
                    1：角度转弧度：Math.toRadians()
                    2：弧度转角度：Math.toDegress()

                7：创建随机数：java.long.Math.Random
                    方式1：通过java.util.Random类来创建随机数：
                        1：指定随机数种子：
                            Random r = new Random()   //使用默认的随机数种子
                            Random r = new Random(long seed)   //使用指定的long型值作为本次生成随机数的种子；
                        2：生成随机数：
                                /*生成一个随机boolean值*/
                                    boolean nextBoolean()；
                                /*生成一个随机double值*/
                                    double nextDouble()；
                                /*生成一个随机float值*/
                                    float nextFloat()：
                                /*生成一个随机int值*/
                                    int nextInt()；
                                /*生成一个[0,bound）范围内的int随机值*/
                                    int nextInt(int bound)；
                                /*生成一个随机long值*/
                                    long nextLong()；
                                /*设置随机数种子*/
                                    setSeed(long seed)
                        3：随机数特征：
                            1.通过java.util.Random类创建的随机数并非真正的随机数，而是伪随机数；
                            2.两个种子数相同的Random对象在相同的次数下，产生的随机数时完全一样的；相同种子的Random对象在不同的运行次数下才可能产生不同的随机数；
                            3.该类计算随机数时需要通过旧的种子计算新的种子，然后通过新的种子计算新的随机数，为了保证新种子计算的线程安全，会使用CAS+自旋的方式创建并设置新的种子；
                            3.该类由于使用CAS+自旋的方式创建新种子，因此在多线程竞争激烈的情况下，会不断发生自旋，导致性能较差，如果一定要做多线程中使用Random类创建随机数，推荐每个线程创建一个Random对象；
                            
                    方式2：Math.random()获取随机数：
                        1：Math.Random实质上也是通过java.util.Random类来生成随机数的，其默认是生成在[0.0~1.0)之间的随机数；
                        2：如需生成指定范围内的随机数,可按照以下公式进行：Math.floor(Math.random()*(max-min+1)+min);
                        3：由于该方法调用的是java.util.Random类，因此同样使用CAS+自旋的方式保证线程安全生成伪随机数；

                    方式3：ThreadLocalRandom：
                        1：JDK1.7之后，提供了ThreadLocalRandom类用来在并发场景下生成随机数；该类全路径为java.util.ThreadLocalRandom;
                        
                        2：该类获取随机数的方法和java.util.Random类相同，生成的同样是伪随机数；但是该类在不同的线程中维护了各自线程的种子，因此在计算新种子时可以直接计算，不会产生多线程间的竞争，无需CAS，性能较高；

                        3：该类创建对象的方式：ThreadLocalRandom.current();该类是一个单利类，不能通过构造函数创建实例对象，只能通过current获取实例对象，获取到的实例对象会根据获取当前线程的旧种子来计算新种子并计算随机数；

                        4.特别注意，由于ThreadLocalRandom创建的仍然是伪随机数，并且调用current()时会获取当前线程的种子作为当前实例对象计算新种子的旧种子，因此不要将ThreadLocalRandom.current()获取到的实例对象作为共享变量使用，否则将导致多个线程使用了创建该实例对象的线程(通常情况下是主线程)的种子,最终导致所有线程中的随机数种子都相同，运行相同次数得到相同的随机数；而应该在每个线程中单独创建ThreadLocalRandom实例对象；

                        5.ThreadLocalRandom获取随机数的方式和Random相同：
                            nextInt()/nextInt(bound)/nextInt(origin,bound)
                            nextLong()/nextLong(bound)/nextLong(origin,bound)
                            nextDouble()/nextDouble(bound)/nextDouble(origin,bound)
                            nextBoolean()
                            nextFloat()
                        
                        6。虽然Random类也可以通过在各自线程中创建各自线程的实例对象来避免自旋导致的性能下降，但是线程较多的情况下需要创建较多的Random实例对象，造成较大的性能开销和内存开销；而ThreadLocalRandom是一个单利类，在线程中调用current()并不会创建新的对象，只是获取了已经创建好的实例对象并获取了当前线程的旧种子而已；所以在多线程情况下推荐使用ThreadLocalRandom来创建随机数；


    DecimalFormat：浮点数格式化
        1.该类在java.text包下，全路径为：java.text.DecimalFormat
        2.该类用来对浮点数进行格式化；
        3.使用流程：
            1.创建DecimalFormat对象，并设置格式化格式：
                DecimalFormat decimalFormat = new DecimalFormat("$##,###.##");
            2.格式化数据，得到String类型的结果
                String formatResult = decimalFormat.format(num)
        4.格式：$###,###.###
            1.格式必须以$符合作为开头；
            2.整数部分可以使用,作为分隔符；
            3.小数部分和整数部分使用.作为分隔符；
            4.数字使用#活着0表示：
                使用#表示：
                    1.整数部分#的个数和具体的数字个数没有映射关系，#可以多与整数位数，也可以少于整数位数，仅仅只是表示整数位而已；
                    2.#多于浮点数的整数范围时也不会补齐，且会忽略数字前面的0；#少于整数位时也不会截断；
                    3.小数部位的#个数表示浮点数精度；
                使用0表示：
                    1.整数部分的0表示整数部分；
                    2.如果整数部分0的个数少于整数部分的位数不会截取整数，如果整数部分0的个数多余整数部分的位数，将会使用0来补齐；
                    3.浮点数部分的0表示浮点数的精度；
            5:前后缀符号：
                后缀符号：
                    1.常用的有%,\u2030(千分号),\u00a4(本地货币符号)三种特殊后缀，其余的后缀将会原样显式；
                    2.百分号和千分号会自动乘以100和1000，然后按照小数位的精度进行格式化；
                    3.\u00a4出现两次，会用使用货币符号的国际代号；
                前后缀符号：    
                    1.前缀可以使用任意前缀，但是前缀需要使用''包裹；
            6：关于科学计数法：0.#E00
                1.整数部分同样使用0或者#表示：
                    使用#，#个数少于整数的个数时，格式化之后整数部分只有1位；#个数多于整数位时才会显式原数据全部的整数位；
                    使用0，0的个数表示整数位的个数；
                2.E前面至少要有一个#或者0，否则E会被当做字符串的一部分，0的个数表示格式化之后小数部分的位数；
                3.E之后的00表示指数的个数，如果不够将会使用0补齐；
                
            


                        
                
            


            

            
                


                






    

    


    
