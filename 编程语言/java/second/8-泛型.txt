为何引入泛型：
    1：由于java是强数据类型语言，对于任意一个变量都必须有明确的数据类型，但实际上在一些处理通用性问题的类、接口以及方法中无法预知需要的是何种类型的数据；这种处理通用性问题的类、接口、方法中并不关心自己处理的是何种类型的数据，只关心数据处理的过程，如果必须明确当前需要处理的数据的数据类型时，这些类、接口、方法也将不再具备通用性，例如：
        1：在集合中，无法预知当前集合将用来存储何种类型的数据，不能限制特定的数据类型，否则集合将只能存储特定数据类型的数据，不再具备集合的通用性；为此只能预置为Object类型来满足集合的使用需求，并且实际在使用时，需要使用者自己维护集中元素的数据类型；
        2：在某些方法中有着通用的处理数据的逻辑，通样不能对接收到的即将处理的数据限制其数据类型，例如以下方法：
            public void printData(Int data)
            {
                System.out.println(data);
            }
        在上述方法中用来打印传入的数据，但是并不关心数据是何种类型，此时data的数据类型就不能有明确的限制，否则该方法将需要为每一种类型添加一个打印方法；
泛型机制：
    1：泛型机制：
        在类、接口、方法声明时可以声明一个未知的类型T（字母任意，只是类型变量，表示某种数据类型），该类型T对于类、接口、方法就是一个明确的可以直接使用的数据类型，只是该数据类型到底是什么类型需要在使用类创建对象、子类继承接口、调用方法时才会明确给出；
    2：泛型机制的实质：
        1：泛型机制的实质是引入类似于方法中形参的参数：类型形参，而方法中的形参称则之为数据形参；
        2：类型形参和数据形参本质相同，都是一个变量，用来接收外部实参的值；
        3：类型形参表示一个未知的数据类型，数据形参表示一个未知的数据，其值都由外部实参给定；对于方法内部，数据形参表示的是一个具体的数据；相同的，对于类、接口、方法内部类型形参表示的是一个具体的数据类型；
    3：泛型的特征：
        1：泛型本质上是类型形参，因此也需要先声明才能使用，声明方式如下：
            1：对于类：
                权限 修饰符 calss 类名<T>{/*类成员*/}
                注意：声明完成之后，在类的内部，T就是一种数据类型，可以直接用来声明变量；
            2：对于接口：
                权限 interface 接口名<T>{/*接口成员*/}
                注意：声明完成之后，在接口内部，T就是一种数据类型，可以直接声明变量；
            3：对于方法：
                权限 修饰符 <T> 返回值类型 方法名(形参列表){/*方法体*/}
                注意：声明完成之后，在方法内部(包括形参列表)，T就是一种数据类型，可以直接声明变量；
        2：泛型上限：泛型表示一个具体但又未知的数据类型，为了能进一步约束泛型的类型范围，可以为泛型设置上限；
            1：对于类：
                权限 修饰符 class 类名<T extends ParentClass>{/*类成员*/}
                注意：1：泛型上限是指当前传入类型形参的值(就是某个数据类型)必须是该上限的子类；
                     2：泛型上限设置完成之后，传入的数据类型必须是该上限的子类；
            2：对于接口：
                权限 interface 接口名<T extends ParentClass>{/*接口成员*/}
                注意：1：泛型上限是指当前传入类型形参的值(就是某个数据类型)必须是该上限的子类；
                     2：泛型上限设置完成之后，传入的数据类型必须是该上限的子类；
            3：对于方法：
                权限 修饰符 <T extends ParentClass> 返回值类型 方法名(形参列表){/*类成员*/}
                注意：1：泛型上限是指当前传入类型形参的值(就是某个数据类型)必须是该上限的子类；
                     2：泛型上限设置完成之后，传入的数据类型必须是该上限的子类；
        3：泛型的使用：
            1：对于类：
                在使用类创建实例对象时，必须按照类型参数的数量、顺序指定该类的类型实参：
                TestClass<String> ts = new TestClass<>();
                或者
                TestClass<String> ts = new TestClass<String>();
            2：对于接口：
                接口并不能直接创建实例对象，而是用来被其他类继承的，因此其他类继承接口时就必须指定接口的类型实参：
                public class TestClass extends TestInterface<String>{/*类成员*/}
            3：对于方法：
                方法中的类型形参在调用方法时会根据传入的参数自动推断当前数据形参对应的类型形参的数据类型；
                public <T,E> void test(T a,E b){};
                test(1,"test")：T的类型将会是int,E的类型将会是String；
                特别注意：同一个类型形参声明的多个不同的数据形参，在调用方法时必须给定相同数据类型的数据实参；
通配符和泛型类：
    关于通配符：
        1：在方法中使用具有泛型机制的类来声明数据形参时，必须指定该类的泛型值，但是某些情况下，该方法时一个通用方法，当前方法也不能限定形参的类型，就需要用到通配符：<?>
        2：通配符特征：
            1：在使用具有泛型机制的类来声明形参时必须指定该泛型类的泛型值，如果此时无法确定泛型值，那么可以使用通配符，表示当前泛型值未定，由调用该方法时实际给出；
            2：通使用通配符即可以保证该形参被限制为当前类的类型，又可以保证该类的泛型灵活任意；例如：
                public void test(List<?> a){}
                表示，形参a一定是一个list。但是list中的数据类型未知，可以是一个int类型的list，也可以是一个String类型的list；
            3：通配符同样支持设置泛型上限，设置方式和类型形参上限设置相同：
                public void test(TestClass<T extends TypeClass>
            4：通配符是用来解决方法数据形参类型未知的问题，对于该问题同样可以使用方法泛型来解决；两者比较如下：
                1：通配符要求参数类型一定是某个类，只是该类的类型形参值未定而已，而方法泛型则对形参的数据类型完全不做限制，因此方法泛型相比较通配符更加宽松；
                2：如果方法中某个形参a的类型或者返回值类型依赖于形参b的类型，那么形参b的类型必须是确定状态的，如果是此种情况，必须使用方法泛型；
    关于泛型类：
        1：为具有泛型机制的类指定了具体明确的类型实参后称该类为泛型类；但实质上并不存在泛型类，泛型只是一种使用了类型型参的机制，引入泛型类仅仅只是为了方便区别具有不同类型实参的类，无论类型实参之间是何种关系，对于使用该泛型机制的类都是一种类，只是类中的类型形参值不同，仅此而已，不会因为类型实参之间的关系或者不同而影响到类本身；
        2：使用了通配符的泛型类称为其他泛型类的父类，但使用通配符的泛型类只是一个概念，表示当前类型形参值未定而已，并不是一个具体的类型，只能在方法声明形参时使用，不能使用通配符的泛型类来创建实例对象，也不能向使用了通配符的集合中添加数据；
        3：如果同一个类中使用了父子类型作为该类的类型实参，那么得到的两个泛型类并不具备父子关系，原理相同，类型实参只是决定了类型形参的值而已，并不会影响到类本身，无论类型实参的值是否是父子关系，对于类本身而言都是同一种类，并没有产生新的类，也不可能有任何父子关系；如：
            TestClass<ParentA> a = new TestClass<>();
            TestClass<ChildrenA> b = new TestClass<>();
            a和b不存在任何父子关系，TestClass<ParentA>和Testclass<ChildrenA>也不存在任何父子关系；TestClass<ParentA>和TestClass<ChildrenA>都是TestClass类，仅仅只是类型实参值不同；
构造方法使用泛型：
    1：构造方法使用泛型机制和泛型方法相同；需要先声明类型形参，然后再使用；只是在创建对象时略有不同：
        class Test{
            public <T> Test(T a)
            {
                /*构造方法实体*/
            }
        }
        创建对象时，必须通过以下语法来创建：
            Test t = new <String> Test("string")
    2：不允许同时使用java7新增的泛型'菱形'语法和泛型构造方法；

泛型下限：
    1：泛型上限是指，当前传入类型形参的数据类型必须是指定类型的子类：<T extends ParentType>
    2：泛型下限是指，当前传入类型形参的数据类型可以是指定类型的子类或者和指定类型一致：<T super ParentType>
    3：泛型上限和下限不能同时用在同一个方法上来实现方法的重载，如：
        public <T> void test(T extends ParentType){}
        public <T> void test(T super ParentType){}
        编译时并不会报错，但是在执行时将会出错；

泛型与数组：
    1：java中不支持创建带有泛型机制的数组，
    

