1：类
    1：类的特征：
        1.**从面向对象的概念来看**，类是实例对象的模板，抽象了实例对象共有的特征，通过同一个类可以创建出的独立且具有相同特征的实例对象；

​		 2.**从数据处理的角度看**，我们所处理和面对的一切都是数据，实例对象本身也是一种数据，而创建实例对象的类就是该实例对象的数据类型，因此类可以认为是一种自定义的数据类型，可以通过类来声明变量，由类声明的变量将可以持有该类实例对象的引用，类这种类型也称为引用类型；
     2：定义类：
        1：定义语法：
                权限 修饰符 class 类名
                {
                        /*类成员*/
                }
        2：权限：1.public 或 默认权限(无权限修饰符)
                2.public 权限指该类在包内和包外都可被访问，默认权限只能在包内访问；
                3.一个java源文件中只能有一个public权限的类，此时源文件名称必须和public类名相同；

        3：修饰符：
                1：默认无修饰符
                2：禁止继承：final
                3：抽象类：abstract;

        4：class：表示该代码块是一个类，不能省略

        5：类名：1.要符合java标识符命名规范；
                2.风格上推荐使用首字母大写的驼峰式命名方式命名；

        6：类成员：1.可有：构造方法、成员属性、成员方法、初始化块、内部类；
                  2.成员声明无顺序要求；

    3：类成员
        1：构造方法：
            1：功能：初始化对象；
                    说明：1.仅初始化实例对象，而非创建实例对象

            2：声明：权限 构造方法名(形参列表){
                        /*构造方法实体*/
                    }
                说明：1.必须要有构造方法，否则无法对实例对象进行初始化，导致无法创建对象；
                      2.构造方法可以根据需要显式声明，并且可以重载；
                      3.构造方法无显式声明时会优先查找所有父类构造方法，若无父类，默认创建无惨构造方法；
            
            3：权限：1.权限取值：public(公共权限)、protected(受保护权限)、private(私有权限)，default(默认权限)；
                    2.构造方法权限影响外部类创建实例对象时是否能够进行对象的初始化；权限不足将无法初始化，导致对象创建失败；不同权限会影响不同范围下的类是否能够调用该类的构造函数创建实例对象；
                    3.通常情况下，构造方法必须是public权限，如若不希望外部类通过构造方法创建对象，可以使用private权限；
                    
            4：构造方法名：构造方法名称必须当前类名保持一致；

            5：形参：1.构造方法可以根据初始化实例对象的需要设置形参，形参由(参数类型 参数名称）组成，多个形参之间使用 , 隔开；
                    2.构造函数的形参通常情况下是为了初始化实例属性；
                    3.对于实例属性的初始化除过使用构造函数参数以外，还可通过属性的setter方法初始化；

            6：返回值：
                1.构造方法有返回值，返回值为初始化之后的实例对象；
                2.不允许在构造方法的声明中指定返回值类型，也不允许使用void关键字；也不允许使用return关键字返回一个值或者返回实例对象本身this；否则将被当做普通方法；

            7：构造方法的重载：
                1：Java中允许构造方法重载；
                2：在构造方法中可以通过this关键字调用另一个构造方法，来实现构造方法的代码重用；
            
        2：成员属性：(实例属性和静态属性)     
            实例属性：
                1：实例属性特征：
                    1.实例属性是指该属性属于实例对象各自本身，且各自实例对象私有；
                    2.每个实例对象中都有一个类型、名称完全相同的属性，属性值则根据对象的不同有所不同；
                    3.实例属性只能通过实例对象访问，由于实例属性各自对象私有，因此访问时获取/修改的是实例对象自己的该实例属性；

                1：定义方式：权限 修饰符 数据类型 变量名 [= 值]

                2：权限：1.可以是public、protected、default、private权限；
                        2.不同权限影响在实例对象在不同范围下对该实例属性的访问能力；

                3：修饰符：1.默认情况下实例变量无特殊修饰符；
                          2.如果该实例变量需要设置为常量，则需要使用final修饰符；

                5：数据类型：可以是java允许的任何数据类型，包括基本类型和引用类型；

                6：属性名：1.实例属性名要符合java标识符命名规范；
                          2.推荐使用驼峰式命名风格命名；
                          3.同一个类中不允许定义多个同名成员变量(哪怕权限、修饰符、类型都不同也不可以)

                7：默认值：1.实例属性在声明时可以指定一个默认值,
                          2.如果没有给定默认值，系统将会设置默认值：
                            引用类型，默认值为null;
                            int类型，默认值为0;
                            float和double类型，默认值为0.0;
                            boolean类型，默认值为false;
                5：访问方式：
                    类内部访问：this.实例变量名 或者 实例变量名
                    类外部访问：实例对象.实例变量名
                    说明：
                        1.在类内部访问实例变量时this关键字可以省略，但是如果方法中有同名局部变量，此时访问实例变量必须使用this关键字，否则同名局部变量将会覆盖实例变量；
                
                6：生命周期：创建对象时才会为该实例对象的实例属性分配内存空间并初始化，对象销毁时也会回收该实例属性占用的内存空间，因此实例属性的生命周期和实例对象的生命周期相同；

                7：存储位置：实例属性属于实例对象本身的数据，各自对象的实例属性存储在系统为各自实例对象分配的堆内存中；

                
            静态属性：
                1.静态属性特征：
                    1.静态属性属于类，不属于对象，和对象的创建无关；
                    2.静态属性可以通过实例对象或者类访问，通过实例对象放问时，所有的实例对象访问的都是同一个静态属性；

                2：定义方式：权限 修饰符 static 数据类型 变量名 [= 值]；

                3：权限：可以是public、protected、default、private权限；

                4：修饰符：1.必须显式使用static修饰符修饰；
                          2.如果该静态属性要设置为常量，需要再添加 final 修饰符；

                5：数据类型：可以是java允许的任何数据类型，包括基本类型和引用类型；

                6：属性名：1.属性名要符合java标识符命名规范；
                          2.推荐使用驼峰式命名风格命名；
                          3.同一个类中不允许定义多个同名属性(哪怕权限、修饰符、类型都不同也不可以)

                7：访问方式：
                    类内部访问：类名.静态属性名 或者 this.静态属性名 或者 静态属性名
                    类外部访问：类名.静态属性名 或者 实例对象.静态属性名
                    注意：
                        1：静态属性既可以通过类名访问也可以通过类实例对象访问，但是并不推荐使用实例对象访问类变量；并且在类外部通过实例对象访问的时候，会优先查找实例变量，如果没有实例变量时才会访问类变量；
                        2：在类内部访问直接使用静态属性名称本身访问时查找优先级是：同名局部变量、同名实例属性、同名静态属性；
                        3：静态方法的加载先于实例对象的创建，因此使用静态方法时可能并无当前类的实例对象，所以不允许在静态方法中直接使用 this.实例变量名 访问实例变量，如果必须访问则需要先创建该类的实例对象：new 类名().实例变量名；

                8：生命周期：类变量和实例对象无关，在类加载时即为该类变量分配内存空间，并初始化，程序结束类被销毁时，类变量才会被销毁，类变量占用的内存才会被回收；因此类变量的生命周期和类本身相同；

                9：存储位置：静态属性存储在方法区；(待定)

            成员变量和局部变量：
                1：定义位置不同：
                    成员变量指类中定义的变量，成员变量包括：实例属性和静态属性；
                    局部变量指成员方法中定义的变量，局部变量包括：形参，方法内定义的变量、代码块中定义的变量；
                2：定义方式不同：
                    成员变量：权限 修饰符 数据类型 变量名 [= 值]
                    局部变量：数据类型 变量名 [= 值]
                3：作用域不同：
                    成员变量是全局状态，可以在类中的任意一个方法内通过对应的访问方式访问；
                    局部变量是局部状态，只能在定义的方法体内和代码块内访问；
                        1：形参的作用域是当前整个方法体；
                        2：方法体内定义的局部变量的作用域是当前方法体内，变量定义之后的区域；
                        3：代码块中的局部变量作用域是变量所在的代码块内部，变量定义之后的区域(比如if、for等产生的代码块)；
                4：访问方式不同：
                    成员变量可以直接通过变量名称访问，也可以按照对应的访问语法访问，但是有同名局部变量时，必须通过特定的语法方式来访问；
                    局部变量必须通过变量名称访问；
                5：生命周期不同：
                    成员变量：静态属性的生命周期和类的生命周期相同；实例属性的生命周期和实例对象相同；
                    局部变量：局部变量的生命周期和方法体的生命周期相同：
                        1：形参会在方法调用时分配内存空间并自动初始化，并且存储在方法的栈内存中，方法执行完毕形参将会销毁；
                        2：方法体和代码块内的局部变量会在方法执行到定义变量的语句时才会分配空间并初始化，并且存储在方法的栈内存中，方法执行完毕局部变量也将销毁；
                6：初始化方式不同：
                    成员变量系统会自动进行初始化操作，也可以显式的初始化；
                    局部变量系统不会自动进行初始化操作，必须手动赋值进行初始化；
                        对于形参：只能接收来自实参的值，不允许设置默认值；
                        方法体以及代码块中的局部变量必须手动设置初始值，否则直接访问将会报错；
                7：关于同名问题：
                    成员变量：不允许在同一个类中出现同名成员变量；
                    局部变量：1.形参不允许同名，不允许和成员变量同名，不允许和方法中的局部变量同名；
                             2.方法体内和代码块内的变量不能同名，不能和形参同名，可以和成员变量同名；
                    推荐命名方式：同一个类中尽量保持变量名称唯一，不要出现重名，便于查看和维护；
                8：关于访问顺序：
                    代码块中直接通过变量名称访问变量时查找顺序：
                        1：先查找当前代码块中是否局部变量的定义；
                        2：如果没有则查找方法体内部是否有局部变量的定义；
                        3：如果没有则查找是否有对应名称的形参；
                        4：如果没有则查找是否有同名实例变量；
                        5：如果没有则查找是否有同名静态变量；
                    方法体内中访问变量顺序：
                        1：先查找方法体内部是否有变量的定义；
                        2：如果没有则查找是否有对应名称的形参；
                        3：如果没有则查找是否有同名实例变量；
                        4：如果没有则查找是否有同名静态变量；
                    对于成员变量的访问：推荐以特定的语法形式调用，避免和局部变量同样的调用方式，便于查看维护，避免歧义；
                9：成员变量和局部变量的选择：
                    1：如果存放和类本身的有关数据，不和实例对象相关联，尽量使用类变量；
                    2：如果存放每个实例对象特有的数据，尽量使用实例变量；
                    3：如果只是为了数据的作用范围更大，能够在不同方法之间共享，则推荐使用类变量；
                    4：如果只是存放程序执行的中间数据，尽量使用局部变量；

        实例方法：
            1.实例方法特征：
                1.实例方法属于实例对象，只能通过实例对象访问；
                2.实例方法存储在方法区，所有实例对象共用实例方法；

            2：定义方式：权限 修饰符 返回值类型 方法名(形参列表){/*方法体*/}     

            3.访问方式：
                类内部访问：this.实例方法
                类外部访问：实例对象.实例方法

            4：权限：public(公共权限)、protected(受保护权限)、default(默认权限)、private(私有权限)

            5：修饰符：1：默认无修饰符，表示普通的实例方法；实例方法的修饰符不能是static；
                      2：abstract(表示抽象方法，只有方法声明，没有方法体)；
                      3：final(表示最终方法，方法不可以被子类重写)；
                      4：实例方法不能使用static修饰符；
            6：返回值类型：1.表示该方法调用之后返回值的数据类型，可以是java允许的任意数据类型；
                          2.如果有返回值返回必须在声明方法时注明返回值数据类型；如果该方法没有返回值，则使用void来表示；

            7：方法名：方法名称，要符合java标识符命名规范，推荐使用驼峰式命名法命名；

            8：形参：表示调用该方法时需要传入的参数。
                1：每一个形参由参数的数据类型和参数名称组成(参数类型 参数名)，多个参数使用 , 隔开；
                2：如果方法声明了参数，调用该方法时必须按照参数的数量、顺序、数据类型给予实参；
                3：形参只能接收来自实参的值，不允许设置默认值；
                4：形参和实参的传递只有值传递，如果是基本类型的形参，则传递的是具体的数值；如果是引用类型的形参，则传递的是实例对象的地址，总之传递给形参的是实参的值本身；
                5：不同类型形参对数据产生的影响不同：
                     1：如果参数是基本类型的数据，实参对形参的赋值等同于将一个变量值赋值给另一个变量；因为复制的就是数据本身，因此在方法内部修改了形参值也不会影响实参的值；
                      2：如果参数是引用类型的数据，那么实参的值和形参的值相同，表示同一个地址，因此指向同一个对象，在方法内部通过形参改变该地址的数据之后，凡是指向该地址的引用变量获取到的数据都将是被修改之后的数据；要特别注意；
                6：java在JDK1.5之后允许使方法接收不定个数的参数，即以 (数据类型 … 形参名) 声明的形参可以接收多个参数，多出的参数会以数组的方式按顺序存放；
            9：方法体：1.方法的具体实现，由多条语句组成；
                      2.如果该方法没有方法体，那么该方法称之为抽象方法，必须要使用abstract修饰；此时类也必须使用abstract修饰；

            10：方法重载：1.java中允许一个类中定义多个参数列表不同，但是方法名相同的方法，这种定义方法的方式称之为方法的重载；
                        2.方法重载只关注同名方法的形参是否不同(类型、数量)，与方法的权限以及修饰符、是否有返回值以及返回值的数据类型等无关；

        静态方法：
            1.静态方法特征：静态方法属于类，只能通过类名访问；

            2：定义方式：权限 static 修饰符 返回值类型 方法名(形参列表){/*方法体*/}     

            3.访问方式：
                类内部访问：类名.类方法或者this.静态方法
                类外部访问：类名.类方法或者实例对象.静态方法
                不推荐使用this或者实例对象访问静态方法

            4：权限：public(公共权限)、protected(受保护权限)、default(默认权限)、private(私有权限)

            5：修饰符：1：静态方法必须使用static修饰符；
                      2：abstract(表示抽象方法，只有方法声明，没有方法体)；
                      3：final(表示最终方法，方法不可以被子类重写)；
      
            6：返回值类型：1.表示该方法调用之后返回值的数据类型，可以是java允许的任意数据类型；
                          2.如果有返回值返回必须在声明方法时注明返回值数据类型；如果该方法没有返回值，则使用void来表示；

            7：方法名：方法名称，要符合java标识符命名规范，推荐使用驼峰式命名法命名；

            8：形参：表示调用该方法时需要传入的参数。
                1：每一个形参由参数的数据类型和参数名称组成(参数类型 参数名)，多个参数使用 , 隔开；
                2：如果方法声明了参数，调用该方法时必须按照参数的数量、顺序、数据类型给予实参；
                3：形参只能接收来自实参的值，不允许设置默认值；
                4：形参和实参的传递只有值传递，如果是基本类型的形参，则传递的是具体的数值；如果是引用类型的形参，则传递的是实例对象的地址，总之传递给形参的是实参的值本身；
                5：不同类型形参对数据产生的影响不同：
                     1：如果参数是基本类型的数据，实参对形参的赋值等同于将一个变量值赋值给另一个变量；因为复制的就是数据本身，因此在方法内部修改了形参值也不会影响实参的值；
                      2：如果参数是引用类型的数据，那么实参的值和形参的值相同，表示同一个地址，因此指向同一个对象，在方法内部通过形参改变该地址的数据之后，凡是指向该地址的引用变量获取到的数据都将是被修改之后的数据；要特别注意；
                6：java在JDK1.5之后允许使方法接收不定个数的参数，即以 (数据类型 … 形参名) 声明的形参可以接收多个参数，多出的参数会以数组的方式按顺序存放；

            9：方法体：1.方法的具体实现，由多条语句组成；
                      2.静态方法中不允许直接访问实例方法和实例变量；如果必须访问需要先通过new 类名()的方式创建当前类的对象，然后通过当前类的对象来访问实例方法和实例属性；
                      3.如果该方法没有方法体，那么该方法称之为抽象方法，必须要使用abstract修饰；此时类也必须使用abstract修饰；

            10：方法重载：1.java中允许一个类中定义多个参数列表不同，但是方法名相同的方法，这种定义方法的方式称之为方法的重载；
                        2.方法重载只关注同名方法的形参是否不同(类型、数量)，与方法的权限以及修饰符、是否有返回值以及返回值的数据类型等无关；
         
        初始化块：
            1：初始化块特征：
                1.没有名称的代码块；
                2.包括静态初始化块和普通初始化块；
                3.静态初始化块在类加载时执行，用来对类进行初始化；普通初始化块在创建实例对象时执行，用来对实例对象初始化；
         
            2：初始化块语法：[修饰符]{/*任意的可执行语句*/}：
                1：修饰符：1.没有任何修饰符：普通初始化块；
                            2.static修饰符，静态初始化块；
                            3.除过static以外不能使用其他任何修饰符修饰初始化块；
                2：初始化块就是一个代码块，其中可以是任意可执行语句；比如对实例变量的初始化，局部变量的定义，分支以及循环语句，调用其他对象的方法等；
                3：一个类中可以声明多个初始化块，具体执行时会按照初始化块的声明顺序执行，推荐将多个初始化块合并为一个初始化块；
                4：初始化块没有名称，不能被调用；静态初始化块会在类初始化时调用，普通初始化块会在创建对象时调用；

            3：普通初始化块和构造方法的异同点：
                相同点：
                    1：普通初始化块和构造方法功能相同，都是在创建对象时进行对象的初始化操作；
                    2：初始化块中的内容和构造方法中的内容组成相同，可以是任意的可执行语句；
                不同点：
                    1：普通初始化块会先于构造方法执行，执行完当前类以及所有父类中所有的普通初始化块之后才会执行构造方法；
                    2：初始化块没有名称，不可以被调用，不接受任何参数，只能固定的执行某些语句；构造方法有名称，可以被调用，可以接受参数；

                注意：实质上普通初始化块只是一个假象，初始化块中的内容在将java源文件编译为class文件时，会将初始化块中的内容添加至构造方法中的原有代码前面；本质上仍然是构造方法；普通初始化块的意义就在于可以执行初始化对象的公共操作，其余个性化的初始化操作可以交给构造函数执行；

            4：静态初始化块和普通初始化块的区别：
                1：普通初始化块用来在创建对象时隐式执行；静态初始化块在类初始化时隐式执行；
                2：静态初始化块由于在类加载时即执行，因此静态初始化块始终先于普通初始化块执行；
                3：静态初始化块属于静态成员，同样不能在静态初始化块内调用实例属性和实例方法；

            5：关于继承中的初始化块执行顺序：
                1：无论是普通初始化块还是静态初始化块，无论当前类中是否有初始化块，在执行时都会上溯当前类的父类直到java.lang.Object类，然后从上至下开始执行每一个类的初始化块，直至当前类；

        内部类：
            1：内部类：
                定义在一个类内部的类称之为内部类，相对的内部类所属的类称为外部类，内部类是外部类的成员；
    
            2：内部类特征：
                1：内部类既是一个class，同时又是外部类的一个成员，所以内部类既具备一个类该有的特征，也具备类成员的特征；
                2：内部类可以帮助外部类实现数据封装、多继承等功能；
                3：内部类作为外部类的成员，同样有非静态内部类和静态内部类；

            3：非静态内部类：
                1.非静态内部类属于实例对象的成员；
                2.声明方式：权限 class 类名{/*内部类成员*/}
                3.关于权限：内部类作为外部类的成员，和其他类成员一样可以有四种访问权限：public、protected、default、private；
                4.非静态内部类成员：
                    1.由实例属性、实例方法、构造方法、非静态初始化块组成；
                    2.不能有静态属性、静态初始化块、静态方法；
                5.非静态内部类与外部类之间的互相访问
                    1.外部类内访问内部类成员：
                        1.外部类不能通过非静态内部类名直接访问非静态内部类成员，必须通过非静态内部类实例对象访问：
                            InnerClass ic = new InnerClass()
                            访问内部类实例属性：ic.实例属性
                            访问内部类实例方法：ic.实例方法
                        注意：不能在外部类中的静态方法中创建非静态内部类实例对象和访问非静态内部类成员；
                    2.外部类外部访问内部类成员：
                        1：由于非静态内部类属于外部类的实例对象，因此必须先创建外部类的实例对象，然后创建非静态内部类实例对象：
                            OutClass oc = new OutClass;
                            OutClass.InnerClass ic = oc.new InnerClass();
                            访问内部类实例属性：ic.实例属性
                            访问内部类实例方法：ic.实例方法
                    3.内部类访问外部类成员：
                        1.内部类可以直接访问外部类成员：
                            外部类实例属性、实例方法：
                                1.直接通过名称访问：实例属性  或者 实例方法()
                                2.通过this关键字访问：this.实例属性 或者 this.实例方法()
                                3.通过外部类名访问：OutClass.this.实例属性 或者 OutClass.this.实例方法()
                                说明：1.直接通过名称访问时按照以下顺序查找：
                                        1.内部类局部变量(代码块局部变量、方法局部变量、形参)
                                        2.内部类实例属性
                                        3.外部类成员属性(外部类实例属性、外部类静态属性)；
                                    2.通过this关键字访问时按照以下顺序查找：
                                        1.内部类实例属性
                                        2.外部类成员属性(外部类实例属性、外部类静态属性)； 
                            外部类静态属性、静态方法：
                                1.直接通过名称访问：静态属性  或者 静态方法()
                                2.通过this关键字访问：this.静态属性 或者 this.静态方法()
                                3.通过外部类名访问：OutClass.静态属性 或者 OutClass.静态方法()
                                说明：1.直接通过名称访问时按照以下顺序查找：
                                        1.内部类局部变量(代码块局部变量->方法局部变量->形参)
                                        2.内部类实例属性
                                        3.外部类成员属性(外部类实例属性->外部类静态属性)；
                                    2.通过this关键字访问时按照以下顺序查找：
                                        1.内部类实例属性
                                        2.外部类成员属性(外部类实例属性->外部类静态属性)； 

            4：静态内部类：
                1：静态内部类：被static修饰的内部类称之为静态内部类，属于类成员；
                2：声明方式：权限 static class 类名{/*类成员*/}
                3：关于权限：内部类作为外部类的成员，和其他类成员一样可以有四种访问权限：public、protected、default、private；
                4.静态内部类成员：
                    1.由实例属性、静态属性、实例方法、静态方法、构造方法、非静态初始化块、静态初始化块组成；
                5.静态内部类与外部类之间的互相访问：
                    1.外部类内访问内部类成员：
                        1.外部类可以通过静态内部类名直接访问静态内部类静态成员；
                        2.静态内部类的非静态成员只能通过静态内部类的实例对象访问：
                            InnerClass ic = new InnerClass()
                            访问内部类实例属性：ic.实例属性
                            访问内部类实例方法：ic.实例方法
                        注意：不能在外部类中的静态方法中创建静态内部类实例对象和访问静态内部类实例成员；
                    2.外部类外部访问内部类成员：
                        1.外部类可以通过静态内部类名直接访问静态内部类静态成员：
                            OutClass.InnerClass.静态属性
                            OutClass.InnerClass.静态方法
                        2：外部类必须通过静态内部类实例对象访问静态内部类的实例属性和实例方法；
                            OutClass oc = new OutClass;
                            OutClass.InnerClass ic = new OutClass.InnerClass();
                            访问内部类实例属性：ic.实例属性
                            访问内部类实例方法：ic.实例方法
                    3.内部类访问外部类成员：
                        1.静态内部类中不允许访问任何外部类非静态成员，包括静态内部类中的实例方法和静态方法都不允许访问外部类实例成员；
                        2.静态内部中的静态方法不允许访问任何非静态成员；对于内部类本身的非静态成员必须创建内部类实例对象访问；
                        3.内部类静态方法中访问外部类静态属性、静态方法：
                            1.直接通过名称访问：静态属性  或者 静态方法()
                            2.通过this关键字访问：this.静态属性 或者 this.静态方法()
                            3.通过外部类名访问：OutClass.静态属性 或者 OutClass.静态方法()
                            说明：1.直接通过名称访问时按照以下顺序查找：
                                    1.内部类局部变量(代码块局部变量->方法局部变量->形参)
                                    2.内部类静态属性
                                    3.外部类静态属性
                                2.通过this关键字访问时按照以下顺序查找：
                                    1.内部类静态属性
                                    2.外部类静态属性 

            5：匿名内部类：
                1：没有名称的内部类称之为匿名内部类；
                2：匿名内部类在声明时即创建对象，且必须继承自一个父类或者接口，如下方式：
                    new 实现接口() | 父类构造器(参数列表){/*匿名内部类成员*/}
                3：关于匿名内部类的说明：
                    1：匿名内部类必须实现某个接口或者继承某个父类；不能单独声明；
                    2：匿名内部类在声明时即创建对象；
                    3：匿名内部类没有名称，因此匿名内部类没有构造方法；
                    4：匿名内部类没有名称，无从被其他类来继承，因此匿名内部类不能是抽象类；


2：面向对象特征：
    1.权限：
        1：权限：隐藏类的具体实现，只保留部分接口对外调用，在一定程度上保证类中代码的安全性；也符合面向对象意义上的封装特征；
        2：权限的组成：
            对于成员变量和成员方法：
                public：公共权限，当前类内部、同包中的类、当前类子类、其他类中均可访问被public修饰的成员变量和成员方法；
                protected：保护权限，只能在当前类、同包中的类、当前类子类中访问被protected修饰的成员变量和成员方法；
                default：默认权限，无需任何权限关键字来修饰，只能在当前类、同包中的类中访问默认权限的成员变量和成员方法；
                private：私有权限，只能在当前类中访问被private修饰的成员变量和成员方法；
            对于外部类：
                public：公共权限，可以在当前类所处包中、当前类所处包以外访问当前类；
                default：默认权限，只能在当前类所处包中访问该类；

    2.继承：
        1：一个类使用extends关键字来扩展另一个类的过程称之为继承；被继承类称之为父类，继承的类称之为子类；
        2：继承语法：权限 修饰符 类名 extends 父类名{/*类实体*/}
        3：java中的继承特征：
            1：继承必须使用extends关键字；
            2：java仅支持单继承，即，一个类仅能有一个直接父类；如果要实现多继承，可以借助内部类的方式实现；
            3：子类将拥有父类所有protected权限以上的实例属性和实例方法：
                关于父类实例属性和实例方法的访问：
                    1：子类内部访问父类实例属性和实例方法：
                        父类实例属性、父类实例方法；
                        this.父类实例属性、this.父类实例方法；
                        super.父类实例属性、super.父类实例方法；
                    2：子类实例对象访问父类实例属性和实例方法：
                        子类实例对象.父类实例属性、子类实例对象.父类实例方法；
                    3：子类中重写父类方法：
                        子类中重写父类方法的基本原则：
                            1：子类仅能重写父类protected权限和public权限的方法；
                            2：三同：
                                1：方法名称必须保持父类中的方法名称，不能改变；
                                2：方法的形参列表必须保持父类方法的形参列表，不能改变；
                                3：方法属性不能改变，实例方法重写之后仍是实例方法，类方法重写之后仍是类方法；
                            3：两小：
                                1：方法重写之后返回值类型只能和父类类型相同或者更小；
                                2：方法重写之后抛出的异常范围只能和父类方法相同或者更小；
                            4：一大：
                                1：重写之后的方法权限应该和父类方法的权限相同或者更大；
                        子类重写父类方法之后的结果：
                            1：子类重写父类方法之后，子类内部其他方法中将不能继续使用this关键字访问父类中的同名方法，子类实例对象也不能访问父类同名方法，访问的都将是子类被重写之后的方法；
                            2：子类重写父类方法之后，如果必须在子类内部访问父类同名方法，只能使用以下访问方式：super.父类方法；
                        关于super关键字：
                            1：super是用来在子类实例方法中访问父类实例属性和实例方法的关键字；两个要点：
                                1：只能用在子类的实例方法中；
                                2：只能用来访问父类的实例方法和实例属性；
                                3：如果子类中没有覆盖父类的实例属性和实例方法，使用this关键字和super关键字均可访问父类的实例属性和实例方法，如果子类中覆盖掉了父类的实例属性和实例方法，只能使用super关键字来访问父类的实例属性和实例方法；
                关于父类类属性和类方法的访问：
                    1：子类内部访问父类类属性和类方法：
                        父类类属性、父类类方法
                        this.父类类属性、this.父类类方法
                        父类类名.父类类属性、父类类名.父类类方法
                    2：子类外部访问父类类属性和类方法：
                        子类实例对象.父类类属性、子类实例对象.父类类方法
                        父类类名.父类类属性、父类类名.父类类方法
                    3：子类覆盖父类类属性和类方法之后只能使用父类类名来访问父类类属性和父类类方法；
                注意：
                    1：如果子类未覆盖父类成员方法和成员变量，将会按照以下顺序访问：
                        （1）查找该方法中是否有名为a的局部变量。
                        （2）查找当前类中是否包含名为a的成员变量(优先实例变量后静态变量)。
                        （3）查找a的直接父类中是否包含名为a的成员变量(优先实例变量后静态变量)，依次上溯a的所有父类，直到java.lang.Object类，如果最终不能找到名为a的成员变量，则系统出现编译错误。
                    2：如果子类已经覆盖父类成员方法和成员变量，只能按照以下方式访问：
                        对于实例属性和实例方法：super.实例属性、super.实例方法
                        对于静态属性和静态方法：父类类名.类属性、父类类名.类方法
            4：系统在为一个类创建实例对象时，不仅会为当前类的实例属性和实例方法分配存储空间，也会为该类的所有父类的实例属性和实例方法分配存储空间；
            5：子类中定义父类同名属性和方法仅仅只是简单地隐藏父类被覆盖的属性和方法，并不是完全覆盖掉；将子类实例对象转为父类类型之后仍然能够访问父类属性和方法；
        4：关于继承使用时的注意事项：
            1：使用继承可以很方便的实现子类对父类的扩展，但是通过子类扩展父类的同时也严重破坏了父类的封装性；尤其注意避免在父类构造方法中调用有可能被子类改写的方法，避免引起未知结果；
            2：尽量隐藏父类内部的数据，避免子类随意修改父类成员变量、成员方法；
        5：关于组合和继承的使用：
            1：如果是新增属性，而非简单的改变属性值，则推荐使用继承，如果只是简单的改变属性值，则通过不同的实例对象即可实现；
            2：如果是在父类的基础上有新增或者有不同的行为，则推荐使用继承，如果只是为了复用父类的方法，则推荐使用组合即可；

    3.多态：
        1：多态的本质：多态本质上是指编程语言承认子类是一种父类类型；即父类类型的变量也能够引用子类类型的实例对象，接受父类类型的参数同样接受子类类型；

        2：多态的支持：
            1：对于弱数据类型的语言，因为对变量并无数据类型约束，变量可以存储或者引用任意类型的数据；因此天然支持多态；
            2：对于强数据类型的语言，因为对变量有严格的数据类型约束，变量仅能够存储或者引用与其数据类型相同的数据；多态需要语言本身支持才能实现；

        3：多态的意义：
            1：对于程序编码的便捷性有所提高，编程者只需关注具体数据的处理即可，无需过多关注需要何种数据类型的变量来引用数据；
            2：；因为语言承认子类是一种父类类型，因此能够通过增加子类的方式扩展父类，而且不会影响到客户端对父类的调用方式；进而实现面向对象中的”开闭原则”，即对修改关闭，对扩展开放。
                接受父类类型的参数同样接受子类类型；因此通过子类来扩展父类之后，客户端不必更改调用方式，可统一使用父类类型来接收扩展之后的子类类型，借助不同的子类类型来实现对原有功能的扩展；如下代码示例：
                public class Animal()
                {
                    public void run()
                    { 
                        System.out.println(“动物的奔跑方式");
                    }
                }
                
                /*兔子的奔跑方式*/
                public class Rabbit()
                {
                    public void run()
                    { 
                        System.out.println(“跳");
                    }
                }
                
                /*封装获取动物的奔跑方式*/
                public void animalRunWay(Animal animal)
                {
                    /*获取动物的奔跑方式*/
                    animal.run();
                }
                
                /*客户端获取动物的奔跑方式*/
                animalRunWay(new Rabbit())

                /*此时如果需要新增一种动物，只需新增一个Animal的子类，并实现run方法即可*/
                public class Tortoise()
                {
                    public void run() 
                    { 
                        System.out.println(“爬");
                    }
                }
                /*客户端获取乌龟的奔跑方式*/
                animalRunWay(new Tortoise())

                我们只需要提前约定好执行该业务的方法名称、参数、返回值类型并封装好调用该方法的代码即可，使用时通过向封装好的调用代码传入子类的实例对象，调用代码将会使用传入的实例对象调用提前约定好的方法，借此即可实现根据不同的对象执行同种方法的不同逻辑来达到功能扩展的目的，并且统一客户端调用代码的形式；
            3：因为多态的支持，java中允许将子类的实例对象赋值给父类类型的引用变量，但是以此种方式创建实例对象时，虽然实例对象本身是子类的实例对象，但是该对象的引用是父类类型，在编译阶段和运行阶段有所不同，编译阶段也只能调用父类中的成员变量和成员方法；运行阶段可以调用子类的成员变量和成员方法；
3：final关键字：
    1：final关键字作用：
        1.final表示最终的意思；
        2.可将类、成员变量、成员方法、局部变量修饰为不可修改的状态；
    2.final修饰成员变量：
        1.修饰方式：
            1.实例属性：权限 final 数据类型 数据名称 [= 值];
            2.静态属性：权限 final  static 数据类型 数据名称 [= 值];
        2.final修饰成员属性特征：
            1.被final修饰的成员属性只能在特定位置赋值：
                1.被final修饰的实例属性只能在声明时、构造函数中、初始化块这三个位置之一中赋上初值，不允许在其他地方对final修饰的实例属性赋值；
                2.被final修饰的静态属性只能在声明时、静态初始化块中赋上初值，不允许在其他地方赋值；
            2.成员属性一旦被final修饰之后，该成员属性值将固定，不允许再被修改：
                1.如果该成员属性是基本类型，那么该成员属性的值本身将不能再被修改，
                2.如果该成员属性是引用类型，那么该成员属性只能指向其引用的实例对象，不能再引用不同实例对象，但所引用的实例对象如果是可变对象的话，对象本身可以被更改；
                3.成员属性的值如果在编译阶段就能够确定下来，那么该成员属性将会作为一个常量，在编译阶段就会用该属性的值替换掉所有的成员属性，直接将其值编译至代码中；
    3.final修饰成员方法特征：
        1：修饰方式：
            1.修饰实例方法：权限 final 返回值类型 方法名(形参){/*方法体*/}
            2.修饰静态方法：权限 final [static] 返回值类型 方法名(形参){/*方法体*/}
        2：被final修饰的方法特征：
            1.被final修饰的方法，无论权限如何，都不允许被子类重写；
        
    4.final修饰类：
        1.修饰方式：权限 final class ClassName{/*类成员*/}
        2.final修饰的类特征：
            1.被final修饰的类不允许被其他类继承；
        3.不可变类：
            1.何为不可变类：该类创建的实例对象，在创建时就已完成初始化，之后将无法再修改该实例对象的属性值，该对象称为不可变对象，该类也称为不可变类；如java.lang.String就是一个不可变类；
            2.创建不可变类：
                1.类本身需要使用fianl修饰，禁止其他类继承该类来修改该类中的方法；
                2.类中的所有成员属性都必须使用private和final修饰，仅为属性提供getter方法；属性的初始化使用带参数的构造函数完成；
                3.所有成员属性都不允许持有其他可变对象的引用；
                4.如有必要必须重写hashCode()和equals()方法，保证这两个方法的协同；
                5.不可变对象的关键属性可以进行缓存，不必每次计算得到；
4：抽象类：
    1.抽象方法：
        1.只有方法声明，没有方法体的方法称为抽象方法，抽象方法需要使用abstract来修饰；
        2.抽象方法声明方式：权限 abstract [static] 返回值类型 方法名(形参列表);
        3.抽象方法声明的注意事项：
            1.抽象方法不能是private权限；(抽象方法需要通过抽象类的子类来重写实现，必须保证该方法有被子类重写的权限)
            2.抽象方法不能被final修饰；(抽象方法需要通过抽象类的子类来重写实现，必须保证该方法可被重写)
            3.抽象方法不能被static修饰；(不能通过类来调用未实现的方法，因此抽象方法禁止使用static修饰)
            
    2：抽象类：
        1.包含抽象方法的类称之为抽象类，抽象类需要通过abstract来修饰；
        2.抽象类声明方式：权限 abstract class 类名{/*类成员*/}
        3.抽象类声明的注意事项：
            1.抽象类不能直接创建实例对象，必须由子类继承抽象类，并实现抽象类中的抽象方法之后才能创建实例对象；
            2.抽象类为了能够被子类继承，不允许使用final关键字修饰抽象类；
            3.子类继承抽象类可以实现抽象类的抽象方法，也可以新增方法；子类如果未能实现抽象方法时子类仍然为抽象类。

    3：关于abstract关键字：abstract仅可用来修饰类和抽象类中的方法，不允许用abstract来修饰成员属性；

    4：抽象类的意义：
        1.抽象类本身包含了一部分具体的实现，可以作为子类的模板，实现子类对父类代码的复用；
        2.抽象类中的抽象方法是抽象类为子类提供扩展父类的插槽，子类通过实现抽象方法的方式对父类扩展时，不会导致父类以及其他类对该抽象方法的调用方式发生改变，能够充分保证开闭原则；
        3.如果是通过新增方法来实现抽象类的扩展，那么这种扩展方式和直接继承一个完整的类并无区别；

5：接口：
    1：关于接口的特征：
        1.接口是一个只有方法声明，无任何方法实现的类(JDK1.8之后允许有类方法和默认方法)；
        2.接口本身不能对外提供任何功能，要求必须有子类继承接口，并实现接口中的抽象方法通过子类对外提供功能；
        3.接口类似于客户端和功能实现方的桥梁，客户端面向接口编程，功能方面向接口实现，只要接口不改动，两端的代码都能够稳定扩展和修改：
            1.对于客户端而言，功能方的扩展和修改就不会引起客户端代码的修改
            2.对于功能方而言，功能的新增和修改可以通过扩展子类实现，不必修改原有的功能代码，能够很好的保证程序的开闭原则；
    
    2：接口的声明：
        1：声明方式：权限 interface 接口名称{/*接口内容*/}
        2：接口声明的注意事项：
            1.接口的权限可以是public和default;
            2：接口必须使用interface来定义；
            3：接口支持继承其他接口，继承使用extends关键字，并且一个接口可以继承多个接口，多个接口通过 , 隔开；如：
                public interface SelfInterface extends InterfaceA,InterfaceB{/*接口具体实现*/}
            4.类继承接口需要使用implements关键字，类可以继承多个接口，多个接口通过,分割；

    3：接口成员：
        1：成员属性：
            1：接口中的成员属性都必须是public static final状态的；如果没有显式的使用public final static 来修饰成员变量，系统也会自动为成员变量加上public final static修饰符；
            2：接口中无构造方法和初始化块，因此成员变量的值必须在声明时就指定初始值；
        2：成员方法：
            1：接口中的成员方法只能是类方法、default方法和抽象方法；
            2：对于default方法和类方法都必须要有具体的方法实现，而抽象方法则必须按照抽象方法的定义方式来定义；
        3：内部类、内部枚举类，内部接口：
            1：接口中允许定义内部类、内部接口、内部枚举类，因为接口中不能创建实例对象，所以必须是public static 状态的；
        4：成员访问方式：
            1.抽象方法和默认方法只能通过继承接口的子类的实例对象访问；
            2.其他静态成员可直接通过接口名称访问；