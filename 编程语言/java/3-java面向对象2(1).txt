

2：对象的打印：
    1：在使用System.out.println()来打印对象时，实际上是调用对象的toString()方法，toString()方法的返回值即是打印出的内容；
    2：toString()方法是Object类中的实例方法，每一个类都直接或者间接继承自Object,因此每一个实例对象都有toString()方法；
    3：默认情况下，toString()返回的是：该实例对象所属类所在的包名.类名@对象内存地址，也可以重写toString()方法，自定义返回值； 

3：变量的比较：
    ==:
        1：对于基本类型的数据：
            1：如果都是数值，则只比较数值是否相同，不管数值类型；
            2：如果一个是数值，一个不是数值，则无法比较，将会报错；
        2：对于引用类型数据:
            1：不可比较两个无父子关系的实例对象，否则将会报错；
            2：不可比较两个来自不同类的实例对象，否则将会报错；
            3：只有两个对象完全相同，即两个对象实质上是一个对象，两个对象的内存地址相同，==才会返回true；否则将返回false；
        3：对于包装类型的数据：
            1：对于包装类型的数据在使用==进行比较时，会先进行拆箱，然后比较拆箱之后的基本类型数据；
    
    equals：
        1：基本类型数据不能使用equals()和另一个数据比较；只有引用类型才能够使用equals()来和另一个数据比较；
        2：所有引用类型的变量均可使用equals()方法来进行比较，默认的比较方式和==相同，只有比较双方地址相同才会返回true，否则返回false；
        3：如果需要自定义比较方式，需要重写equals；重写之后，返回true，则说明比较双方相同，返回false，则说明比较双方不同；
        4：自定义equals方法时需要注意一下几个原则：
            1：自反性：自己和自己比较一定是相等的；即：a.equals(a)：true；
            2：传递性：链式相等，如：a.equals(b)：true,b.equals(c)：true,那么a.equals(c)一定是true;
            3：对称性：a.equals(b)为true,那么b.equals(a)一定为true；
            4：一致性：如果比较条件未变，那么无论调用多少次equals比较结果都必须是完全一样的；
            5：非null性：任何非null变量和null比较一定是false，反过来一样；
            6：比较条件由业务决定，根据业务来实现比较条件，但是务必遵守上述原则；
4：final修饰符：
    1：final关键字作用：
        1.final表示最终的意思；
        2.可将类、成员变量、成员方法、局部变量修饰为不可变动的状态；
    2.final修饰成员变量：
        1.修饰方式：
            1.实例属性：权限 final 数据类型 数据名称 [= 值];
            2.静态属性：权限 final  static 数据类型 数据名称 [= 值];
        2.final修饰成员属性特征：
            1.被final修饰的成员属性只能在特定位置赋值：
                1.被final修饰的实例属性只能在声明时、构造函数中、初始化块这三个位置之一中赋上初值，不允许在其他地方对final修饰的实例属性赋值；
                2.被final修饰的静态属性只能在声明时、静态初始化块中赋上初值，不允许在其他地方赋值；
            2.成员属性一旦被final修饰之后，该成员属性值将固定，不允许再被修改：
                1.如果该成员属性是基本类型，那么该成员属性的值本身将不能再被修改，
                2.如果该成员属性是引用类型，那么该成员属性只能指向其引用的实例对象，不能再引用不同实例对象，但所引用的实例对象如果是可变对象的话，对象本身可以被更改；
                3.成员属性的值如果在编译阶段就能够确定下来，那么该成员属性将会作为一个常量，在编译阶段就会用该属性的值替换掉所有的成员属性，直接将其值编译至代码中；
        3.final修饰成员方法特征：
            1：修饰方式：
                1.修饰实例方法：权限 final 返回值类型 方法名(形参){/*方法体*/}
                2.修饰静态方法：权限 final [static] 返回值类型 方法名(形参){/*方法体*/}
            2：被final修饰的方法特征：
                1.被final修饰的方法，无论权限如何，都不允许被子类重写；
        
        4..final修饰类：
            1.修饰方式：权限 final class ClassName{/*类成员*/}
            2.final修饰的类特征：
                1.被final修饰的类不允许被其他类继承；
            3.不可变类：
                1.何为不可变类：该类创建的实例对象，在创建时就已完成初始化，之后将无法再修改该实例对象的属性值，该对象称为不可变对象，该类也称为不可变类；如java.lang.String就是一个不可变类；
                2.创建不可变类：
                    1.类本身需要使用fianl修饰，禁止其他类继承该类来修改该类中的方法；
                    2.类中的所有成员属性都必须使用private和final修饰，仅为属性提供getter方法；属性的初始化使用带参数的构造函数完成；
                    3.所有成员属性都不允许持有其他可变对象的引用；
                    4.如有必要必须重写hashCode()和equals()方法，保证这两个方法的协同；
                    5.不可变对象的关键属性可以进行缓存，不必每次计算得到；

5：抽象类：
    1：包含抽象方法的类称之为抽象类，抽象类需要通过abstract来修饰
    2：抽象类的声明：权限 abstract class 类名{/*类成员*/}
    3：关于抽象方法：
        1：抽象方法存在的必要性是由面向对象的多态特征引起的：在多态特征中，根据开闭原则对原有的类进行扩展时，为了保持客户端调用方式不变，只需根据不同子类来调用即可，就必须提前约定可被扩展的方法的名称、参数、返回值类型，凡是扩展该方法都必须遵守该方法的声明；
        2：抽象方法仅仅声明了方法的权限、返回值类型、方法名称、形参列表，而方法体则由继承该类的子类来实现，为了子类都能够按照要求来实现抽象方法，java规定，抽象类不允许创建实例对象，除非通过子类继承抽象类，并且实现了抽象类的所有抽象方法；
        3：抽象方法的声明：权限 abstract 返回值类型 方法名称(形参列表)，特别注意：抽象方法不可以使用final来修饰，否则该抽象方法无法在子类中实现；
    4：关于abstract关键字：
        1：abstract表示未实现的意思，可以用来修饰类和抽象类中的方法，不可以用abstract来修饰成员变量；
        2：abstract修饰的类不能直接创建实例对象，需要通过子类来继承并实现抽象类中的所有抽象方法之后才能创建实例对象并使用，因此抽象类以及抽象方法均不能使用final来修饰，且不能为protected以下的权限；
        3：如果使用abstract和static同时修饰一个方法，那么该抽象方法将可以通过类来直接调用，但是抽象方法并无方法体，无法执行，此种方式将会导致出错，因此，不允许同时使用abstract和static关键字来修饰方法；
    5：抽象类的作用：可以作为类模板使用，为了达到开闭原则的效果，可以将抽象类作为一个通用模板，通过子类来进行扩展、改造，但是子类一定保持抽象类中的方法头部，保证被重写的方法能够满足开闭原则的实现要求；
6：接口：
    1：关于接口的特征：
        1：接口，是从众多相似类中抽象出的一套规范，接口不提供任何具体实现；
        2：接口存在的意义就在于为子类提供实现标准和实现要求，让实现和接口分离，通过接口中的一套标准和规范来连接实现，方便扩展不同的实现；
    2：接口的声明：
        1：声明方式：权限 interface 接口名称{/*接口内容*/}
        2：接口声明的注意事项：
            1：接口必须使用interface来定义；
            2：接口支持继承其他接口，继承使用extends关键字，可以继承多个接口，所继承的多个接口通过 , 隔开；如：public interface SelfInterface extends InterfaceA,InterfaceB{/*接口具体实现*/}
    3：接口成员：
        1：成员变量：
            1：接口中的成员变量都是public权限的静态最终量，如果没有显式的使用public final static 来修饰成员变量，系统也会自动为成员变量加上public final static修饰符；
            2：接口中无构造方法和初始化块，因此成员变量的值必须在声明时就指定初始值；
        2：成员方法：
            1：接口中的成员方法只能是类方法、default方法和抽象方法；
            2：对于default方法和类方法都必须要有具体的方法实现，而抽象方法则必须按照抽象方法的定义方式来定义；
        3：内部类、内部枚举类，内部接口：
            1：接口中允许定义内部类、内部接口、内部枚举类，但是都必须是public static的；
        4：关于接口中成员的访问：
            1：接口中的静态成员均可直接通过接口名称访问；
            2：接口不能直接创建实例对象，必须通过子类继承接口，并实现接口中的抽象方法之后才能创建实例对象；
            3：接口中的default方法和抽象放法必须通过接口子类的实例对象访问；
    4：接口与文件：接口本质上是一个特殊的类，因此同样一个文件中只能有一个public修饰的接口，并且此时文件名必须和public修饰的接口名称相同；
7：内部类：
    1：定义在类内部的类称之为内部类；
    2：内部类特征：
        1：内部类定义在某个类内部，内部类所在的类称之为外部类，内部类提供了更深层次的封装；
        2：内部类在定义的语法上和外部类相同，单更重要的是内部类是外部类的成员，因此内部类的权限修饰符可以是public、protected、default、private；并且内部类可以是静态的成员，即内部类能够使用static来修饰；
        3：内部类可以定义在外部类内的任意位置，甚至是外部类的方法内，内部类定义在外部类方法中时称之为局部内部类；
    3：非静态内部类：
        1：非静态内部类，即不使用static修饰的内部类；
        2：非静态内部类声明方式：权限 class 类名{/*类成员*/}，其中权限可以是public、protected、default、private；
        3：非静态内部类成员：
            1：非静态内部类中可以由实例属性、实例方法、构造方法、非静态初始化块；不能有静态属性、静态初始化块、静态方法；
            2：非静态内部类中可以直接访问外部类任意权限的任意成员；访问方式如下：外部类名.this.外部类成员名；
            3：外部类不能直接访问非静态内部类成员，必须先创建非静态内部类实例对象，然后通过该实例对象访问非静态内部类成员；特别注意，不能在外部类中的静态方法中创建非静态内部类实例对象，更不能访问非静态内部类成员；
        4：静态内部类：
            1：被static修饰的内部类称之为静态内部类；
            2：静态内部类声明方式：权限 static class 类名{/*类成员*/}，其中权限可以是public、protected、default、private；
            3：静态内部类成员：
                1：静态内部类中可以由实例属性、静态属性、实例方法、静态方法、构造方法、非静态初始化块、静态初始化块；
                2：静态内部类中可以直接访问外部类任意权限的静态成员；访问方式如下；外部类名.外部类静态成员；特别注意：静态内部类中不能访问外部类的实例成员，即便在静态内部类中的实例方法中也不可以访问外部类的实例成员；
                3：外部类不能直接访问非静态内部类成员，必须先创建非静态内部类实例对象，然后通过该实例对象访问静态内部类的实例成员或者使用静态内部类类名访问内部类的类成员；特别注意，不能在外部类中的静态方法中创建静态内部类实例对象，更不能访问静态内部类成员；
        5：关于内部类的访问：
            1：在外部类中访问内部类：
                1：对于非静态内部类，必须先创建内部类实例对象，然后访问内部类的实例成员；
                2：对于静态内部类，可以通过内部类名访问内部类静态成员，可以通过创建内部类实例对象来访问内部类实例成员；
                3：特别注意：不允许在外部类的静态方法中创建内部类的实例对象，并访问内部类的实例成员；
            2：在外部类以外访问非静态内部类：
                1：在外部类以外访问非静态内部类时有以下几项要求：
                    1：非静态内部类权限必须是private权限以上，并在各自对应的权限范围内访问内部类；
                    2：创建非静态内部实例对象前必须先创建外部类实例对象，然后通过外部类实例对象创建非静态内部类实例对象：
                        Out out= new Out();
                        Out.Inner in = out.new Inner();
            3：在外部类以外访问静态内部类：
                1：在外部类以外访问静态内部类时有以下几项要求：
                    1：静态内部类权限必须是private权限以上，并在各自对应的权限范围内访问内部类；
                    2：访问方式：
                        1：对于静态内部类的静态成员：外部类以外可以通过内部类名称访问内部类静态成员，如：Out.Inner.内部类静态成员；
                        2：对于静态内部类的实例成员，必须先创建外部类的实例对象，然后通过外部类的实例对象创建内部类的实例对象，然后通过内部类的实例对象来访问内部类的实例成员，方式如下：
                            Out out = new Out();
                            Out.Inner in = new Out.Inner();
                    
                    创建静态内部实例对象前必须先创建外部类实例对象，然后通过外部类实例对象创建非静态内部类实例对象：
                        Out out= new Out();
                        Out.Inner in = out.new Inner();
            4：匿名内部类：
                1：没有名称的内部类称之为匿名内部类；
                2：匿名内部类在声明时即创建对象，如下：
                    new 实现接口() | 父类构造器(参数列表){/*匿名内部类成员*/}
                3：关于匿名内部类的说明：
                    1：匿名内部类必须实现某个接口或者继承某个父类；不能单独声明；
                    2：匿名内部类在声明时即创建对象；
                    3：匿名内部类没有名称，因此匿名内部类没有构造方法；
                    4：匿名内部类没有名称，无从被其他类来继承，因此匿名内部类不能是抽象类；

        



        