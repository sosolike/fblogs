1.内存模型组成：
    共享：
        方法区
        堆内存
    私有：
        虚拟机栈
        本地方法栈
        程序计数器
    
    说明：
        1.共享部分是指所有线程共享该区域内存空间以及该区域内存空间中的数据；
        2.私有部分是指该部分空间存在于每个线程内部，不和其他线程共享，所有线程中都有这样一部分空间；

2.程序计数器：
    |-程序计数器作用：
        1.采用多线程工作时，对于单个cpu内核采用的是轮换的方式执行不同的线程，那么为了线程能够在切换之后恢复到正确的执行位置，必须记录当前线程当前执行到哪个指令，即指令的行号；
        2.实现程序的流程控制，记录下一条需要执行的指令位置，比如在顺序、循环、分支、异常处理中确定下一条待执行的指令；

    |-内存模型中的程序计数器：
        1.在os中，程序计数器又被称为指令计数器，通过pc寄存器来实现，而jvm中的程序计数器则是jvm抽象出的一个pc寄存器，用来模拟os中的pc寄存器，实现对当前线程正在执行的java字节码指令位置的记录；

        2.由于每个线程都需要记录各自的字节码指令执行位置，因此每个线程都会有一个程序计数器，由该线程私有，不和其他线程共享；

        3.在内存模型上看，程序计数器作用类似于一个方法内字节码指令的行号，用来表示当前线程正在执行的方法的字节码指令(?当前正在执行的字节码指令位置还是下一条字节码指令的位置)，在实际实现上，一般存储的是当前字节码指令相对于起始指令的偏移值；
            <img>

        3.由于java中存在两种不同类型的方法:本地方法(native方法)和java方法；线程在执行两种不同方法时程序计数器的值也不相同：
            1.执行java方法时，程序计数器的值是当前线程正在执行的方法内具体的字节码指令偏移值；
            2.执行native方法时，程序计数器的值是undefined；原因在于：native方法并非通过java实现，也不需要转换成java字节码指令之后再执行，因此也就无需再记录当前native方法的指令位置，但并不表示执行native方法无需程序计数器，而是使用了操作系统的程序计数器；
            说明：执行native方法时程序计数器为空，多线程切换之后是如何准确恢复当前线程具体执行位置的？
                虚拟机中的线程最终都要以某种形式映射至真实os中的线程，一般的映射模型有以下三种：
                    1.1:1映射：即虚拟机中的每一条线程都映射为一条os中真实的线程；
                    2.n:1映射：即用户态线程模型；
                    3.m:n映射：混合模型；
                在HotSpot虚拟机上采用的是1:1映射，因此，native方法将会由原生平台直接执行，因此native方法的执行位置由os的pc寄存器来记录和管理；无需jvm中抽象出的程序计数器来管理；
            虽然执行不同类型的方法时，虚拟机中程序计数器的值不同，但是程序计数器区域是唯一一个在java虚拟机规范中没有规定任何OOM的区域；

        4.虚拟机中程序计数器的特点：
            1.线程私有，不共享，仅记录当前线程字节码指令执行位置；
            2.声明周期和线程相同，随着线程创建而创建，销毁而销毁；
            3.因为仅用来存储字节码指令位置，因此占用内存较小，并且是虚拟机规范中唯一一个没有规定任何OOM情况的区域;

3.虚拟机栈：
    |-关于虚拟机栈：
        虚拟机栈是用来描述当前线程中方法执行和方法调用情况的内存空间，每个线程中都会有一个虚拟机栈，属于当前线程私有，不和其他线程共享；虚拟机栈则由若干个栈帧组成，每一个栈帧表示一个被调用的方法，栈帧中则存储着当前正在执行的方法的局部变量表、操作数栈、动态链接、方法出口信息；
    |-虚拟机栈特点：
        1.线程私有，不共享，仅记录当前线程中的方法执行和方法调用情况；
        2.虚拟机栈占用的内存空间可扩展，但是有两个维度的限制：
            1.栈深度：即虚拟机栈中的栈帧个数；如果当前线程向虚拟机栈中存放的栈帧多于虚拟机所允许的深度，将会抛出StackOverFlowError异常；
            2.栈内存：即虚拟机栈占用的实际内存大小；如果当前线程中的虚拟机栈在扩展时无法申请到足够的内存将会抛出OOM异常；
        3.虚拟机栈生命周期和线程生命周期相同，随着线程创建而创建，销毁而销毁；
    |-栈帧：
        1.虚拟机栈内存空间中存放的是若干个栈帧；线程中每调用一个方法将会为该方法创建一个栈帧，方法执行完时将会销毁为该方法创建的栈帧；栈帧的顺序和方法的调用顺序相同，先调用的先入栈，执行完成则按照顺序出栈；
        2.栈帧中则存放了当前方法的局部变量表、操作数栈、动态链接、方法出口信息；
        <img--虚拟机栈+栈帧信息>
        3.理论上栈帧与栈帧之间是完全独立的，但是实际上虚拟机为了优化会把上一层栈帧的局部变量表和下一层栈帧的操作数栈共用，来避免方法间参数的穿度、方法返回值的传递等引起的复制；
        |-局部变量表：
            1.局部变量表中存放着当前线程在当前方法的形参以及方法内创建的局部变量；
            
            2.局部变量则存放在变量槽中，虚拟机则通过变量槽的索引来查找变量(索引定位的方式)，索引的范围在0~局部变量表最大容量之间；虚拟机并未规定一个槽应该占用的内存空间大小，但是规定了一个槽应该可以存放一个32位以内的数据类型；包括：
                byte、short、int、float、boolean等5中基本数据类型
                reference引用类型：指方法中局部变量对其他对象的引用，而非全局属性对其他对象的引用，全局属性对其他对象的引用存储在为java对象分配的堆中；
                long和double类型的数据则使用两个槽位来存储；
                returnAddress
            
            3.虚拟机在查找局部变量时通过索引定位的方式查找局部变量的值，即通过变量所在的变量槽查找变量值；如果变量类型占用内存空间少于32位，则第其索引值就表示使用第n个变量槽存储变量值，如果变量类型占用内存空间大于32位，则表示变量值由索引值为n和n+1的两个变量槽表示；

            4.如果方法是实例方法时，第0位变量槽用来存储该方法所属的实例对象，即方法内this关键字指向的实例对象的地址；

            5.变量槽在实际中是可以复用的，因为方法体内的变量作用域不一定覆盖整个方法，因此如果当前字节码程序计数器的值已经超过了某个变量的作用域，那么这个变量相应的 Slot 就可以交给其他变量去使用，节省栈空间，但也有可能会影响到系统的垃圾收集行为；

            6.局部变量表允许的最大深度在编译阶段就已经确定，并且会在方法表的属性中记录，不会手动运行期数据的影响；

        |-操作数栈：
            1.操作数栈用来存储执行字节码指令时需要的数据，包括计算所需的原始数据，中间的临时结果、最终的计算结果等，类似于一个工作台，用来放置需要的数据以及产生的数据；
            (具体的有：1.局部变量表中的变量，2.其他实例对象的属性、3.临时的计算结果、4.调用其他方法时传递的参数、5.调用其他方法返回的结果)
            2.操作数栈是一个先进后出的栈结构，包括有出栈和进栈：
                1.进栈：字节码指令在执行时如果从局部变量表或者堆中读取了一个或者产生了一个数据，就会将数据存放在操作数栈中，称之为入栈；
                2.出栈：如果字节码指令执行时需要一个从操作数栈中取出一个数据进行计算或者返回给调用者，那么称之为出栈；
                方法在执行之初，操作数栈是空的，随着方法的执行，会有反复的入栈和出栈操作；
            3.操作数栈中存储的是执行字节码指令时需要的数据，因此操作数栈中可以存储任意java类型的数据，其中一个32位或者32位以内的数据占用一个栈容量，64位的数据类型则占用2个栈容量；并且操作数栈的最大深度在编译时已经确定，无论何时，操作数栈中的元素数量都不会超过操作数栈的最大深度；
            4.操作数栈的大小同样在编译阶段就已经确定好了，并且会写在方法表的属性中，不会手动运行期数据的影响；
        
        |-方法出口：
            1.被调用的方法在退出之后都需要返回到方法调用的位置，保证程序能够按预定的执行流程继续执行，因此需要在栈帧中存储当前方法的出口信息，即方法出口中保存的是当前方法退出后需要执行的字节码指令位置；
            2.被调用的方法在退出时有两种情况：
                1.方法正常执行完成，或者遇到方法返回的指令之后该方法就会退出；如果方法有返回值，那么返回值会被传递给上层该方法的调用者；这种方法退出方式称之为正常完成出口；
                2.方法执行期间遇到异常，无论是虚拟机产生的异常还是通过throw手动抛出的异常，只要当前方法内部没有对异常进行捕获并处理就会导致方法退出；这种退出方式称为异常完成出口
            3.退出情况不同，方法出口中存储的信息也不相同：
                1.如果是正常完成出口，调用者的程序计数器的值就可以作为返回地址，因此栈帧中有可能会保存该计数器值；
                2.如果是异常完成出口，返回地址需要通过异常处理表来确定，因此栈帧中通常不会保存异常完成出口的信息；
            4.方法退出的过程实际就是当前方法栈帧出栈的过程，当前栈帧出栈时会将下一层栈帧(即上层的调用者方法)中的局部变量表和操作数栈恢复，并且把返回值(如果有的话)压入调用者栈帧的操作数栈中，调整程序计数器的值指向方法调用指令的下一条指令；
        |-动态链接：
            1.每个栈帧中都包含一个指向运行时常量池中该栈帧所属方法的引用；持有这个引用的目的在于为了支持方法调用过程中的动态链接；